import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter/gestures.dart';
import 'package:flutter/foundation.dart';
import 'dart:math' as math;
import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_database/firebase_database.dart';
import 'dart:async';
import 'dart:html' as html;
import 'dart:js' as js;
import 'dart:typed_data';
import 'package:speech_to_text/speech_to_text.dart' as stt;
import 'package:permission_handler/permission_handler.dart';

// ì•± ë²„ì „ ë° ìºì‹œ ê´€ë¦¬
class AppVersion {
  static const String version = '1.0.1';
  static const String buildNumber = '2';
  static String get buildTime => DateTime.now().millisecondsSinceEpoch.toString();
  static String get cacheKey => '${version}_${buildTime}';
  
  // ì¹´ì¹´ì˜¤í†¡ ì¸ì•± ë¸Œë¼ìš°ì € ê°ì§€
  static bool get isKakaoTalk {
    if (kIsWeb) {
      return html.window.navigator.userAgent?.contains('KAKAOTALK') ?? false;
    }
    return false;
  }
  
  // PWA ëª¨ë“œ ê°ì§€ (í™ˆ í™”ë©´ì— ì¶”ê°€ëœ ì•±)
  static bool get isPWA {
    if (kIsWeb) {
      // display-mode: standalone ì²´í¬
      final isStandalone = js.context.callMethod('eval', [
        "(window.matchMedia('(display-mode: standalone)').matches)"
      ]) as bool;
      
      // iOS Safariì˜ navigator.standalone ì²´í¬
      final isIOSStandalone = js.context['navigator']['standalone'] ?? false;
      
      // ë””ë²„ê¹… ë¡œê·¸
      print('PWA ê°ì§€ - standalone: $isStandalone, iOS standalone: $isIOSStandalone');
      
      return isStandalone || isIOSStandalone;
    }
    return false;
  }
  
  // ìºì‹œ ë¬´íš¨í™”
  static void clearCache() {
    if (kIsWeb) {
      // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ ìºì‹œ ë¬´íš¨í™”
      html.window.localStorage.clear();
      html.window.sessionStorage.clear();
      
      // í˜ì´ì§€ ìƒˆë¡œê³ ì¹¨ ì‹œ ìºì‹œ ë¬´ì‹œ
      final currentUrl = html.window.location.href;
      final uri = Uri.parse(currentUrl);
      final newParams = Map<String, String>.from(uri.queryParameters);
      newParams['_v'] = cacheKey;
      newParams['_t'] = DateTime.now().millisecondsSinceEpoch.toString();
      
      final newUri = uri.replace(queryParameters: newParams);
      html.window.history.replaceState({}, '', newUri.toString());
    }
  }
}

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  
  // ì¹´ì¹´ì˜¤í†¡ ì¸ì•± ë¸Œë¼ìš°ì €ì—ì„œ ìºì‹œ ë¬´íš¨í™”
  if (AppVersion.isKakaoTalk) {
    AppVersion.clearCache();
    print('ì¹´ì¹´ì˜¤í†¡ ì¸ì•± ë¸Œë¼ìš°ì € ê°ì§€ - ìºì‹œ ë¬´íš¨í™” ì‹¤í–‰');
  }
  
  await Firebase.initializeApp(
    options: const FirebaseOptions(
      apiKey: "AIzaSyCQ1_7hbvODByDihzdPe0bAg8r7zLRPMeo",
      authDomain: "hv-line.firebaseapp.com",
      databaseURL: "https://hv-line-default-rtdb.firebaseio.com",
      projectId: "hv-line",
      storageBucket: "hv-line.firebasestorage.app",
      messagingSenderId: "651342907657",
      appId: "1:651342907657:web:2ce01d847b0bef45752bd8",
    ),
  );
  
  runApp(const LineDrawerApp());
}

class LineDrawerApp extends StatelessWidget {
  const LineDrawerApp({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'HV LINE',
      theme: ThemeData.dark().copyWith(
        scaffoldBackgroundColor: const Color(0xFF0D1117), // Cursor ë°°ê²½ìƒ‰
        cardColor: const Color(0xFF161B22),
        dividerColor: const Color(0xFF30363D),
        primaryColor: const Color(0xFF238636),
        colorScheme: const ColorScheme.dark(
          primary: Color(0xFF238636),
          secondary: Color(0xFF1F6FEB),
          surface: Color(0xFF161B22),
          background: Color(0xFF0D1117),
          onPrimary: Colors.white,
          onSecondary: Colors.white,
          onSurface: Color(0xFFE6EDF3),
          onBackground: Color(0xFFE6EDF3),
        ),
        elevatedButtonTheme: ElevatedButtonThemeData(
          style: ElevatedButton.styleFrom(
            backgroundColor: const Color(0xFF238636),
            foregroundColor: Colors.white,
            elevation: 0,
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(6),
            ),
          ),
        ),
        iconTheme: const IconThemeData(
          color: Color(0xFFE6EDF3),
        ),
      ),
      home: const LineDrawerScreen(),
    );
  }
}

class Line {
  Offset start;
  Offset end;
  String? openingType;
  bool isDiagonal;
  Map<String, dynamic>? connectedPoints;

  Line({
    required this.start,
    required this.end,
    this.openingType,
    this.isDiagonal = false,
    this.connectedPoints,
  });

  Line copy() {
    return Line(
      start: start,
      end: end,
      openingType: openingType,
      isDiagonal: isDiagonal,
      connectedPoints: connectedPoints != null ? Map.from(connectedPoints!) : null,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'startX': start.dx,
      'startY': start.dy,
      'endX': end.dx,
      'endY': end.dy,
      'openingType': openingType,
      'isDiagonal': isDiagonal,
      'connectedPoints': connectedPoints,
    };
  }

  static Line fromJson(Map<dynamic, dynamic> json) {
    return Line(
      start: Offset(
        (json['startX'] as num).toDouble(),
        (json['startY'] as num).toDouble(),
      ),
      end: Offset(
        (json['endX'] as num).toDouble(),
        (json['endY'] as num).toDouble(),
      ),
      openingType: json['openingType'] as String?,
      isDiagonal: json['isDiagonal'] as bool? ?? false,
      connectedPoints: json['connectedPoints'] as Map<String, dynamic>?,
    );
  }
}

class Circle {
  Offset center;
  double radius;

  Circle({
    required this.center,
    required this.radius,
  });

  Circle copy() {
    return Circle(
      center: center,
      radius: radius,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'centerX': center.dx,
      'centerY': center.dy,
      'radius': radius,
    };
  }

  static Circle fromJson(Map<dynamic, dynamic> json) {
    return Circle(
      center: Offset(
        (json['centerX'] as num).toDouble(),
        (json['centerY'] as num).toDouble(),
      ),
      radius: (json['radius'] as num).toDouble(),
    );
  }
}

// ì  ì—°ê²° ì•„ì´ì½˜ ìœ„ì ¯
class DiagonalDotsIcon extends StatelessWidget {
  final Color color;
  final double size;
  
  const DiagonalDotsIcon({
    Key? key,
    required this.color,
    this.size = 14,
  }) : super(key: key);
  
  @override
  Widget build(BuildContext context) {
    return CustomPaint(
      size: Size(size, size),
      painter: _DiagonalDotsPainter(color: color),
    );
  }
}

class _DiagonalDotsPainter extends CustomPainter {
  final Color color;
  
  _DiagonalDotsPainter({required this.color});
  
  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = color
      ..strokeWidth = 1.5
      ..style = PaintingStyle.stroke;
      
    final dotPaint = Paint()
      ..color = color
      ..style = PaintingStyle.fill;
    
    // ëŒ€ê°ì„  ê·¸ë¦¬ê¸°
    canvas.drawLine(
      Offset(size.width * 0.2, size.height * 0.8),
      Offset(size.width * 0.8, size.height * 0.2),
      paint,
    );
    
    // ì–‘ ëì— ì  ê·¸ë¦¬ê¸°
    final dotRadius = size.width * 0.15;
    canvas.drawCircle(Offset(size.width * 0.2, size.height * 0.8), dotRadius, dotPaint);
    canvas.drawCircle(Offset(size.width * 0.8, size.height * 0.2), dotRadius, dotPaint);
  }
  
  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;
}

// ì°½ë¬¸ ì•„ì´ì½˜ ìœ„ì ¯
class WindowIcon extends StatelessWidget {
  final Color color;
  final double size;
  
  const WindowIcon({
    Key? key,
    required this.color,
    this.size = 14,
  }) : super(key: key);
  
  @override
  Widget build(BuildContext context) {
    return CustomPaint(
      size: Size(size, size),
      painter: _WindowPainter(color: color),
    );
  }
}

class _WindowPainter extends CustomPainter {
  final Color color;
  
  _WindowPainter({required this.color});
  
  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = color
      ..strokeWidth = 1.5
      ..style = PaintingStyle.stroke;
    
    // ì •ì‚¬ê°í˜• ê·¸ë¦¬ê¸°
    final rect = Rect.fromLTWH(
      size.width * 0.15,
      size.height * 0.15,
      size.width * 0.7,
      size.height * 0.7,
    );
    canvas.drawRect(rect, paint);
    
    // ìˆ˜ì§ì„  (ê°€ìš´ë°)
    canvas.drawLine(
      Offset(size.width * 0.5, size.height * 0.15),
      Offset(size.width * 0.5, size.height * 0.85),
      paint,
    );
    
    // ìˆ˜í‰ì„  (ê°€ìš´ë°)
    canvas.drawLine(
      Offset(size.width * 0.15, size.height * 0.5),
      Offset(size.width * 0.85, size.height * 0.5),
      paint,
    );
  }
  
  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;
}

class LineDrawerScreen extends StatefulWidget {
  const LineDrawerScreen({Key? key}) : super(key: key);

  @override
  State<LineDrawerScreen> createState() => _LineDrawerScreenState();
}

class _LineDrawerScreenState extends State<LineDrawerScreen> {
  List<Line> lines = [];
  List<Circle> circles = [];
  List<Map<String, dynamic>> linesHistory = [];
  List<Map<String, dynamic>> circlesHistory = [];
  Offset currentPoint = const Offset(0, 0);
  double viewScale = 0.3;
  Offset viewOffset = const Offset(500, 500);
  double viewRotation = 0.0; // í™”ë©´ íšŒì „ ê°ë„ (ë¼ë””ì•ˆ)
  int selectedLineIndex = -1;
  int selectedCircleIndex = -1;
  
  // í˜ì´ì§€ ê´€ë ¨ ë³€ìˆ˜
  int currentPage = 1; // í˜„ì¬ ì„ íƒëœ í˜ì´ì§€ (1-5)
  bool isPageDropdownOpen = false; // ë“œë¡­ë‹¤ìš´ ì—´ë¦¼ ìƒíƒœ
  final LayerLink _dropdownLayerLink = LayerLink(); // ë“œë¡­ë‹¤ìš´ ìœ„ì¹˜ ì—°ê²°ìš©
  OverlayEntry? _dropdownOverlay; // ë“œë¡­ë‹¤ìš´ ì˜¤ë²„ë ˆì´
  // ì  ê°„ ë“œë˜ê·¸ ì„  ê·¸ë¦¬ê¸° ë³€ìˆ˜
  bool isPointDragging = false;
  Offset? pointDragStart;
  Offset? pointDragEnd;
  bool circleMode = false;
  bool diagonalMode = false; // ëŒ€ê°ì„ (ì ê³¼ ì  ì—°ê²°) ëª¨ë“œ
  Offset? circleCenter;
  String? pendingOpeningType;
  String? arrowDirection;
  bool isDoubleDirectionPressed = false; // ë°©í–¥í‚¤ ë‘ ë²ˆ ëˆ„ë¦„ ìƒíƒœ
  
  // ê·¸ë£¹ ë“œë˜ê·¸ ì•¤ ë“œë¡­ ë³€ìˆ˜
  bool isGroupDragging = false;
  Offset? groupDragStartPoint; // ë“œë˜ê·¸ ì‹œì‘í•œ ëì 
  Offset? groupDragCurrentPoint; // í˜„ì¬ ë“œë˜ê·¸ ìœ„ì¹˜
  Set<int> draggedGroupLines = {}; // ë“œë˜ê·¸ ì¤‘ì¸ ê·¸ë£¹ì˜ ì„ ë“¤
  Map<int, Offset> originalLineStarts = {}; // ì›ë˜ ì„ ë“¤ì˜ ì‹œì‘ì 
  Map<int, Offset> originalLineEnds = {}; // ì›ë˜ ì„ ë“¤ì˜ ëì 
  Offset? snapTargetPoint; // ìŠ¤ëƒ…ë  ëŒ€ìƒ ëì 
  
  // ë”ë¸”í´ë¦­ìœ¼ë¡œ ì„ íƒëœ ê·¸ë£¹
  Set<int> selectedGroupLines = {}; // ì„ íƒëœ ê·¸ë£¹ì˜ ì„ ë“¤
  DateTime? lastTapTime; // ë§ˆì§€ë§‰ íƒ­ ì‹œê°„ (ë”ë¸”í´ë¦­ ê°ì§€ìš©)
  
  // Firebase
  late DatabaseReference _linesRef;
  late DatabaseReference _circlesRef;
  late DatabaseReference _currentPointRef;
  late DatabaseReference _metadataRef;
  StreamSubscription? _linesSubscription;
  StreamSubscription? _circlesSubscription;
  StreamSubscription? _currentPointSubscription;
  StreamSubscription? _metadataSubscription;
  bool _isUpdating = false;
  
  // ì„¸ì…˜ ID (ê° ê¸°ê¸°ë¥¼ êµ¬ë¶„í•˜ê¸° ìœ„í•¨)
  final String sessionId = DateTime.now().millisecondsSinceEpoch.toString();
  
  // íƒ€ì„ìŠ¤íƒ¬í”„ ê¸°ë°˜ ë™ê¸°í™”
  int _lastUpdateTimestamp = 0;
  String _lastUpdateDevice = '';
  bool _isLocalUpdate = false;
  
  // íŒ¬/ì¤Œ ê´€ë ¨ ë³€ìˆ˜
  Offset? panStartOffset;
  double? zoomStartScale;
  Offset? dragStartPos;
  
  // ë§ˆìš°ìŠ¤ í˜¸ë²„ ê´€ë ¨ ë³€ìˆ˜
  Offset? hoveredPoint;
  Offset? mousePosition;
  int? hoveredLineIndex;
  
  // ì„ íƒëœ ëì 
  Offset? selectedEndpoint;
  int? selectedEndpointLineIndex;
  String? selectedEndpointType; // 'start' ë˜ëŠ” 'end'
  
  // í„°ì¹˜ ì´ë²¤íŠ¸ ê´€ë ¨ ë³€ìˆ˜
  Offset? _lastTapPosition;
  DateTime? _lastTapTime;
  bool _isScaling = false; // ìŠ¤ì¼€ì¼ ì œìŠ¤ì²˜ ì¤‘ì¸ì§€ ì¶”ì 
  
  // ì¸ë¼ì¸ ì…ë ¥ ê´€ë ¨ ë³€ìˆ˜
  bool showInlineInput = false;
  String inlineDirection = "";
  TextEditingController inlineController = TextEditingController();
  FocusNode inlineFocus = FocusNode();
  bool isProcessingInput = false;
  
  // ì „ì²´í™”ë©´ ê´€ë ¨ ë³€ìˆ˜
  bool isFullscreen = false;
  bool _userRequestedFullscreen = false; // ì‚¬ìš©ìê°€ ì§ì ‘ ì „ì²´í™”ë©´ì„ ìš”ì²­í–ˆëŠ”ì§€ ì¶”ì 
  bool _isRecovering = false; // ì „ì²´í™”ë©´ ë³µêµ¬ ì¤‘ì¸ì§€ ì¶”ì 
  
  // ì´ˆê¸° ë°ì´í„° ë¡œë”© ìƒíƒœ ì¶”ì 
  bool _linesLoaded = false;
  bool _circlesLoaded = false;
  bool _currentPointLoaded = false;
  bool _initialViewFitExecuted = false;
  
  // ì„  íŒì—… ê´€ë ¨ ë³€ìˆ˜
  bool showLinePopup = false;
  Offset? linePopupPosition;
  int? selectedLineForPopup;
  
  // ë ˆì´ì•„ì›ƒ ëª¨ë“œ ê´€ë¦¬
  String layoutMode = _getDefaultLayoutMode(); // ìë™ ê°ì§€
  
  // ìë™ ê¸°ê¸° ê°ì§€ í•¨ìˆ˜
  static String _getDefaultLayoutMode() {
    if (kIsWeb) {
      final userAgent = html.window.navigator.userAgent.toLowerCase();
      final platform = html.window.navigator.platform?.toLowerCase() ?? '';
      final maxTouchPoints = html.window.navigator.maxTouchPoints ?? 0;
      final screenWidth = html.window.screen?.width ?? 0;
      final screenHeight = html.window.screen?.height ?? 0;
      
      // ì•„ì´íŒ¨ë“œ ê°ì§€ (iPadOS 13+ í¬í•¨)
      final isIPad = userAgent.contains('ipad') || 
                    (userAgent.contains('macintosh') && maxTouchPoints > 0) ||
                    platform.contains('ipad');
      
      // ëª¨ë°”ì¼ ê¸°ê¸° ê°ì§€
      final isMobileDevice = userAgent.contains('iphone') ||
                            userAgent.contains('android') ||
                            userAgent.contains('mobile') ||
                            userAgent.contains('phone');
      
      // ë°ìŠ¤í¬í†± ê°ì§€ (í„°ì¹˜ê°€ ì—†ê³ , í™”ë©´ì´ í° ê²½ìš°)
      final isDesktopDevice = !isMobileDevice && 
                             !isIPad && 
                             maxTouchPoints == 0 &&
                             screenWidth >= 1024;
      
      print('=== ìë™ ê¸°ê¸° ê°ì§€ ===');
      print('User Agent: ${html.window.navigator.userAgent}');
      print('Platform: ${html.window.navigator.platform}');
      print('Touch Points: $maxTouchPoints');
      print('Screen: ${screenWidth}x$screenHeight');
      print('iPad: $isIPad, Mobile: $isMobileDevice, Desktop: $isDesktopDevice');
      
      if (isIPad) {
        print('ê°ì§€ ê²°ê³¼: íƒœë¸”ë¦¿ ëª¨ë“œ');
        return 'tablet';
      } else if (isMobileDevice) {
        print('ê°ì§€ ê²°ê³¼: ëª¨ë°”ì¼ ëª¨ë“œ');
        return 'mobile';
      } else if (isDesktopDevice) {
        print('ê°ì§€ ê²°ê³¼: ë°ìŠ¤í¬í†± ëª¨ë“œ');
        return 'desktop';
      } else {
        print('ê°ì§€ ê²°ê³¼: ê¸°ë³¸ê°’ (ë°ìŠ¤í¬í†± ëª¨ë“œ)');
        return 'desktop'; // ê¸°ë³¸ê°’ì„ ë°ìŠ¤í¬í†±ìœ¼ë¡œ ë³€ê²½
      }
    } else {
      // ëª¨ë°”ì¼ ì•±ì¸ ê²½ìš°
      return 'mobile';
    }
  }
  
  // ëª¨ë°”ì¼ ê¸°ê¸° ê°ì§€
  bool get isMobile {
    return layoutMode == 'mobile';
  }
  
  // íƒœë¸”ë¦¿ ëª¨ë“œ ê°ì§€ (ìë™ ê°ì§€ ì œê±°)
  bool get isTablet {
    // ìˆ˜ë™ íƒœë¸”ë¦¿ ëª¨ë“œë§Œ ì§€ì›
    return layoutMode == 'tablet';
  }
  
  // ë°ìŠ¤í¬í†± ëª¨ë“œ ê°ì§€
  bool get isDesktop {
    return layoutMode == 'desktop';
  }
  
  final FocusNode _focusNode = FocusNode();
  
  // ìŒì„± ì¸ì‹ ê´€ë ¨ ë³€ìˆ˜
  late stt.SpeechToText _speech;
  bool _isListening = false;
  bool _speechEnabled = false;
  String _lastWords = '';
  String _recognizedText = '';
  bool _speechAvailable = false;
  
  // ì›¹ ì „ìš© ìŒì„± ì¸ì‹ ë³€ìˆ˜
  html.SpeechRecognition? _webSpeechRecognition;
  bool _webSpeechAvailable = false;
  
  // Safari ì „ìš© ìŒì„± ì¸ì‹ ë³€ìˆ˜
  js.JsObject? _safariSpeechRecognition;
  
  // ë§ˆì§€ë§‰ ë°©í–¥ ì €ì¥
  String? lastDirection;
  
  // ìŒì„± ì¸ì‹ ì²˜ë¦¬ ì¤‘ë³µ ë°©ì§€ (ê°•í™”)
  bool _isSpeechProcessing = false;
  DateTime? _lastSpeechProcessTime;
  String? _lastProcessedText; // ë§ˆì§€ë§‰ ì²˜ë¦¬ëœ í…ìŠ¤íŠ¸
  int _speechProcessCount = 0; // ì²˜ë¦¬ íšŸìˆ˜ ì¹´ìš´í„°
  Set<String> _processedTexts = {}; // ì²˜ë¦¬ëœ í…ìŠ¤íŠ¸ ì§‘í•© (ì¤‘ë³µ ë°©ì§€)
  Set<double> _recentlyProcessedNumbers = {}; // ìµœê·¼ ì²˜ë¦¬ëœ ìˆ«ì ì§‘í•©
  double? _lastProcessedNumber; // ë§ˆì§€ë§‰ìœ¼ë¡œ ì²˜ë¦¬ëœ ìˆ«ì
  DateTime? _lastLineDrawTime; // ë§ˆì§€ë§‰ ì„  ê·¸ë¦¬ê¸° ì‹œê°„
  bool _isVoiceProcessing = false; // ìŒì„± ì²˜ë¦¬ ì¤‘ ìƒíƒœ (UIìš©)
  
  // ìŒì„± ì¸ì‹ í† ê¸€ ëª¨ë“œ ê´€ë ¨ ë³€ìˆ˜
  // ìë™ ìŒì„± ëª¨ë“œ ë³€ìˆ˜ë“¤ ì œê±° - ì„±ëŠ¥ ìµœì í™”ë¥¼ ìœ„í•´ ë‹¨ìˆœí•œ ìŒì„± ì¸ì‹ ëª¨ë“œë¡œ ë³€ê²½
  
  // í™”ë©´ ì´ë™ ë° ì¤Œ ê´€ë ¨ ë³€ìˆ˜
  bool _isPanning = false;
  Offset? _lastPanPosition;
  double _initialScale = 1.0;
  double _initialRotation = 0.0; // ì´ˆê¸° íšŒì „ ê°ë„
  Offset? _rotationCenterScreen; // íšŒì „ ì¤‘ì‹¬ì  (í™”ë©´ ì¢Œí‘œ)
  Offset? _rotationCenterModel; // íšŒì „ ì¤‘ì‹¬ì  (ëª¨ë¸ ì¢Œí‘œ)
  int _touchCount = 0;

  // Firebase ì°¸ì¡°ë¥¼ í˜ì´ì§€ë³„ë¡œ ì—…ë°ì´íŠ¸
  void _updateFirebaseRefs() {
    _linesRef = FirebaseDatabase.instance.ref('drawing/page$currentPage/lines');
    _circlesRef = FirebaseDatabase.instance.ref('drawing/page$currentPage/circles');
    _currentPointRef = FirebaseDatabase.instance.ref('drawing/page$currentPage/currentPoint');
    _metadataRef = FirebaseDatabase.instance.ref('drawing/page$currentPage/metadata');
  }
  
  // í˜ì´ì§€ ë³€ê²½ í•¨ìˆ˜
  void _changePage(int newPage) async {
    if (newPage == currentPage) return;
    
    print('í˜ì´ì§€ ë³€ê²½: $currentPage â†’ $newPage');
    
    // í˜„ì¬ í˜ì´ì§€ ë°ì´í„° ì €ì¥
    await _updateFirebase();
    
    // ê¸°ì¡´ êµ¬ë… ì·¨ì†Œ
    await _linesSubscription?.cancel();
    await _circlesSubscription?.cancel();
    await _currentPointSubscription?.cancel();
    await _metadataSubscription?.cancel();
    
    // êµ¬ë… ë³€ìˆ˜ ì´ˆê¸°í™”
    _linesSubscription = null;
    _circlesSubscription = null;
    _currentPointSubscription = null;
    _metadataSubscription = null;
    
    // í˜ì´ì§€ ë³€ê²½
    setState(() {
      currentPage = newPage;
      isPageDropdownOpen = false;
      
      // ë°ì´í„° ì´ˆê¸°í™” (ìƒˆ í˜ì´ì§€ ë°ì´í„° ë¡œë“œ ì „ê¹Œì§€ ë¹ˆ ìƒíƒœ)
      lines.clear();
      circles.clear();
      currentPoint = const Offset(0, 0);
      selectedLineIndex = -1;
      selectedCircleIndex = -1;
      selectedGroupLines.clear();
      linesHistory.clear();
      
      // ë¡œë”© ìƒíƒœ ì´ˆê¸°í™”
      _linesLoaded = false;
      _circlesLoaded = false;
      _currentPointLoaded = false;
      _initialViewFitExecuted = false;
    });
    
    // ìƒˆ í˜ì´ì§€ Firebase ì°¸ì¡° ì—…ë°ì´íŠ¸
    _updateFirebaseRefs();
    
    // ìƒˆ í˜ì´ì§€ ë°ì´í„° ì¦‰ì‹œ ë¡œë“œ
    await _loadCompleteDataFromFirebase();
    
    // ìƒˆ í˜ì´ì§€ ë°ì´í„° êµ¬ë… ì„¤ì •
    _setupRealtimeSync();
  }
  
  @override
  void initState() {
    super.initState();
    
    // Firebase ì´ˆê¸°í™” (í˜„ì¬ í˜ì´ì§€ ê¸°ì¤€)
    _updateFirebaseRefs();
    
    // ì‹¤ì‹œê°„ ë™ê¸°í™” ì„¤ì •
    _setupRealtimeSync();
    
    // ì „ì²´í™”ë©´ ë¦¬ìŠ¤ë„ˆ ì„¤ì •
    _setupFullscreenListener();
    
    // ê¸°ê¸° ê°ì§€ ë””ë²„ê¹… ì •ë³´ ì¶œë ¥
    _printDeviceInfo();
    
    // ìŒì„± ì¸ì‹ ì´ˆê¸°í™”
    _initSpeech();
    
    // ì•± ì‹œì‘ ì‹œ í¬ì»¤ìŠ¤ ì„¤ì • ë° ì¦‰ì‹œ ë·° ë§ì¶¤
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _focusNode.requestFocus();
      
      // ì•± ì‹œì‘ ì‹œ ì¦‰ì‹œ ë·° ë§ì¶¤ ì‹¤í–‰ (ê°•í™”ëœ ë²„ì „)
      Future.delayed(const Duration(milliseconds: 500), () {
        if (mounted) {
          print('ì•± ì‹œì‘ ì‹œ ìë™ ë·° ë§ì¶¤ ì‹¤í–‰');
          print('í˜„ì¬ ì„  ê°œìˆ˜: ${lines.length}, ì› ê°œìˆ˜: ${circles.length}');
          print('í˜„ì¬ ë·° ìŠ¤ì¼€ì¼: $viewScale, ì˜¤í”„ì…‹: $viewOffset');
          
          // ë°ì´í„°ê°€ ìˆìœ¼ë©´ fitViewToDrawing, ì—†ìœ¼ë©´ centerCurrentPoint
          if (lines.isNotEmpty || circles.isNotEmpty) {
            print('ë°ì´í„°ê°€ ìˆìŒ - fitViewToDrawing ì‹¤í–‰');
            fitViewToDrawing();
          } else {
            print('ë°ì´í„°ê°€ ì—†ìŒ - centerCurrentPoint ì‹¤í–‰');
            centerCurrentPoint();
          }
        }
      });
      
      // ì¶”ê°€ë¡œ 1ì´ˆ í›„ì—ë„ í•œ ë²ˆ ë” ì‹¤í–‰ (Firebase ë°ì´í„° ë¡œë”© ì™„ë£Œ í›„)
      Future.delayed(const Duration(milliseconds: 1500), () {
        if (mounted && (lines.isNotEmpty || circles.isNotEmpty)) {
          print('1.5ì´ˆ í›„ ì¶”ê°€ ë·° ë§ì¶¤ ì‹¤í–‰ (ë°ì´í„° ë¡œë”© ì™„ë£Œ í›„)');
          fitViewToDrawing();
        }
      });
    });
  }
  
  void _printDeviceInfo() {
    if (kIsWeb) {
      final userAgent = html.window.navigator.userAgent;
      final platform = html.window.navigator.platform;
      final maxTouchPoints = html.window.navigator.maxTouchPoints;
      final screenWidth = html.window.screen?.width;
      final screenHeight = html.window.screen?.height;
      
      // ìƒì„¸ ê°ì§€ ì •ë³´
      final userAgentLower = userAgent.toLowerCase();
      final platformLower = platform?.toLowerCase() ?? '';
      
      // ì•„ì´íŒ¨ë“œ ìë™ ê°ì§€ ë° ì„¤ì •
      final isIPad = userAgentLower.contains('ipad') || 
                    (userAgentLower.contains('macintosh') && maxTouchPoints! > 0) ||
                    platformLower.contains('ipad');
      
      if (isIPad && layoutMode == 'mobile') {
        print('ì•„ì´íŒ¨ë“œ ê°ì§€ë¨ - ìë™ìœ¼ë¡œ íƒœë¸”ë¦¿ ëª¨ë“œë¡œ ì „í™˜');
        layoutMode = 'tablet';
      }
      
      print('=== ê¸°ê¸° ê°ì§€ ì •ë³´ ===');
      print('User Agent: $userAgent');
      print('Platform: $platform');
      print('Max Touch Points: $maxTouchPoints');
      print('Screen Size: ${screenWidth}x$screenHeight');
      print('');
      print('=== ê°ì§€ ì¡°ê±´ ===');
      print('contains iphone: ${userAgentLower.contains('iphone')}');
      print('contains ipad: ${userAgentLower.contains('ipad')}');
      print('contains android: ${userAgentLower.contains('android')}');
      print('contains mobile: ${userAgentLower.contains('mobile')}');
      print('contains macintosh: ${userAgentLower.contains('macintosh')}');
      print('platform contains ipad: ${platformLower.contains('ipad')}');
      print('iPad detected: $isIPad');
      print('');
      print('=== ìµœì¢… ê²°ê³¼ ===');
      print('Layout Mode: ${layoutMode ?? "ìë™"}');
      print('isMobile: $isMobile');
      print('isTablet: $isTablet');
      print('isDesktop: $isDesktop');
      print('isPWA: ${AppVersion.isPWA}');
      print('==================');
    }
  }

  void _setupRealtimeSync() {
    // ë©”íƒ€ë°ì´í„° ë™ê¸°í™” (íƒ€ì„ìŠ¤íƒ¬í”„ ê¸°ë°˜)
    _metadataSubscription = _metadataRef.onValue.listen((event) {
      if (_isLocalUpdate) {
        print('ë¡œì»¬ ì—…ë°ì´íŠ¸ ì¤‘ - ë©”íƒ€ë°ì´í„° ë™ê¸°í™” ë¬´ì‹œ');
        return;
      }
      
      final data = event.snapshot.value;
      if (data != null && data is Map) {
        final timestamp = data['lastUpdateTimestamp'] as int? ?? 0;
        final device = data['lastUpdateDevice'] as String? ?? '';
        
        print('ë©”íƒ€ë°ì´í„° ìˆ˜ì‹  - íƒ€ì„ìŠ¤íƒ¬í”„: $timestamp, ê¸°ê¸°: $device, í˜„ì¬: $_lastUpdateTimestamp');
        
        // ë” ìµœì‹  ë°ì´í„°ê°€ ìˆìœ¼ë©´ ì „ì²´ ë°ì´í„° ë‹¤ì‹œ ë¡œë“œ
        if (timestamp > _lastUpdateTimestamp && device != sessionId) {
          print('ë” ìµœì‹  ë°ì´í„° ê°ì§€ - ì „ì²´ ë°ì´í„° ë™ê¸°í™” ì‹œì‘');
          _lastUpdateTimestamp = timestamp;
          _lastUpdateDevice = device;
          _loadCompleteDataFromFirebase();
        }
      }
    });
    
    // ì„ ë“¤ ë™ê¸°í™” (ì´ˆê¸° ë¡œë”©ìš©)
    _linesSubscription = _linesRef.onValue.listen((event) {
      if (_isUpdating || _isLocalUpdate) {
        print('ì—…ë°ì´íŠ¸ ì¤‘ - ì„  ë™ê¸°í™” ë¬´ì‹œ');
        return;
      }
      
      final data = event.snapshot.value;
      setState(() {
        final newLines = <Line>[];
        if (data != null && data is List) {
          newLines.addAll(data
              .where((item) => item != null)
              .map((item) => Line.fromJson(item as Map<dynamic, dynamic>))
              .toList());
        }
        
        lines = newLines;
        print('ì„  ë°ì´í„° ë¡œë”© - ${lines.length}ê°œ');
        
        // ì„  ë°ì´í„° ë¡œë”© ì™„ë£Œ í‘œì‹œ
        if (!_linesLoaded) {
          _linesLoaded = true;
          _checkInitialDataLoaded();
        }
      });
    });
    
    // ì›ë“¤ ë™ê¸°í™” (ì´ˆê¸° ë¡œë”©ìš©)
    _circlesSubscription = _circlesRef.onValue.listen((event) {
      if (_isUpdating || _isLocalUpdate) {
        print('ì—…ë°ì´íŠ¸ ì¤‘ - ì› ë™ê¸°í™” ë¬´ì‹œ');
        return;
      }
      
      final data = event.snapshot.value;
      setState(() {
        final newCircles = <Circle>[];
        if (data != null && data is List) {
          newCircles.addAll(data
              .where((item) => item != null)
              .map((item) => Circle.fromJson(item as Map<dynamic, dynamic>))
              .toList());
        }
        
        circles = newCircles;
        print('ì› ë°ì´í„° ë¡œë”© - ${circles.length}ê°œ');
        
        // ì› ë°ì´í„° ë¡œë”© ì™„ë£Œ í‘œì‹œ
        if (!_circlesLoaded) {
          _circlesLoaded = true;
          _checkInitialDataLoaded();
        }
      });
    });
    
    // í˜„ì¬ ì  ë™ê¸°í™” (ì´ˆê¸° ë¡œë”©ìš©)
    _currentPointSubscription = _currentPointRef.onValue.listen((event) {
      if (_isUpdating || _isLocalUpdate) return;
      
      final data = event.snapshot.value;
      setState(() {
        if (data != null && data is Map) {
          currentPoint = Offset(
            (data['x'] as num).toDouble(),
            (data['y'] as num).toDouble(),
          );
        } else {
          currentPoint = const Offset(0, 0); // ë°ì´í„°ê°€ ì—†ìœ¼ë©´ ì›ì 
        }
        
        // í˜„ì¬ ì  ë°ì´í„° ë¡œë”© ì™„ë£Œ í‘œì‹œ
        if (!_currentPointLoaded) {
          _currentPointLoaded = true;
          _checkInitialDataLoaded();
        }
      });
    });
  }

  void _checkInitialDataLoaded() {
    // ëª¨ë“  ì´ˆê¸° ë°ì´í„°ê°€ ë¡œë”©ë˜ê³  ì•„ì§ ë·° ë§ì¶¤ì„ ì‹¤í–‰í•˜ì§€ ì•Šì•˜ë‹¤ë©´
    if (_linesLoaded && _circlesLoaded && _currentPointLoaded && !_initialViewFitExecuted) {
      _initialViewFitExecuted = true;
      
      print('ì´ˆê¸° ë°ì´í„° ë¡œë”© ì™„ë£Œ - ë·° ë§ì¶¤ ìë™ ì‹¤í–‰');
      print('í˜„ì¬ ê¸°ê¸° ëª¨ë“œ - isMobile: $isMobile, isTablet: $isTablet');
      
      // ì•½ê°„ì˜ ì§€ì—° í›„ ë·° ë§ì¶¤ ì‹¤í–‰ (UI ë Œë”ë§ ì™„ë£Œ ëŒ€ê¸°)
      WidgetsBinding.instance.addPostFrameCallback((_) {
        Future.delayed(const Duration(milliseconds: 300), () {
          if (mounted) {
            // ëª¨ë°”ì¼/íƒœë¸”ë¦¿ì—ì„œëŠ” í•­ìƒ currentPointë¥¼ í™”ë©´ ì¤‘ì‹¬ì— ë§ì¶¤
            if (isMobile || isTablet) {
              print('ëª¨ë°”ì¼/íƒœë¸”ë¦¿ ëª¨ë“œ - currentPoint ì¤‘ì‹¬ ë§ì¶¤ ì‹¤í–‰');
              centerCurrentPoint();
            } else {
              // ë°ìŠ¤í¬í†±ì—ì„œëŠ” ê¸°ì¡´ ë°©ì‹ ì‚¬ìš©
              fitViewToDrawing();
            }
          }
        });
      });
    }
  }

  Future<void> _updateFirebase() async {
    if (_isUpdating) {
      print('Firebase ì—…ë°ì´íŠ¸ ì¤‘ - ì¤‘ë³µ í˜¸ì¶œ ë¬´ì‹œ');
      return;
    }
    
    _isUpdating = true;
    _isLocalUpdate = true;
    
    try {
      final currentTimestamp = DateTime.now().millisecondsSinceEpoch;
      
      print('Firebase ì—…ë°ì´íŠ¸ ì‹œì‘ - í˜ì´ì§€: $currentPage, íƒ€ì„ìŠ¤íƒ¬í”„: $currentTimestamp');
      print('ì—…ë°ì´íŠ¸í•  ì„  ê°œìˆ˜: ${lines.length}');
      print('ì—…ë°ì´íŠ¸í•  ì› ê°œìˆ˜: ${circles.length}');
      print('í˜„ì¬ ì : $currentPoint');
      
      // ë¡œì»¬ ë°ì´í„°ë¥¼ Firebase í˜•ì‹ìœ¼ë¡œ ë³€í™˜
      final localLinesJson = lines.map((line) => line.toJson()).toList();
      final localCirclesJson = circles.map((circle) => circle.toJson()).toList();
      
      // ëª¨ë“  ë°ì´í„°ë¥¼ í•œ ë²ˆì— ì—…ë°ì´íŠ¸ (ì›ìì  ì—…ë°ì´íŠ¸)
      final updates = <String, dynamic>{};
      updates['drawing/page$currentPage/lines'] = localLinesJson;
      updates['drawing/page$currentPage/circles'] = localCirclesJson;
      updates['drawing/page$currentPage/currentPoint'] = {
        'x': currentPoint.dx,
        'y': currentPoint.dy,
        'timestamp': currentTimestamp,
      };
      updates['drawing/page$currentPage/metadata'] = {
        'lastUpdateTimestamp': currentTimestamp,
        'lastUpdateDevice': sessionId,
        'deviceInfo': {
          'sessionId': sessionId,
          'platform': kIsWeb ? 'web' : 'mobile',
          'layoutMode': layoutMode,
          'timestamp': currentTimestamp,
        }
      };
      
      // íƒ€ì„ìŠ¤íƒ¬í”„ ì—…ë°ì´íŠ¸
      _lastUpdateTimestamp = currentTimestamp;
      _lastUpdateDevice = sessionId;
      
      print('Firebase ì—…ë°ì´íŠ¸ ì‹¤í–‰ ì¤‘...');
      
      // Firebase ì—…ë°ì´íŠ¸ ì‹¤í–‰
      await FirebaseDatabase.instance.ref().update(updates);
      
      print('Firebase ì—…ë°ì´íŠ¸ ì™„ë£Œ - ì„ : ${localLinesJson.length}, ì›: ${localCirclesJson.length}');
      print('íƒ€ì„ìŠ¤íƒ¬í”„: $currentTimestamp, ê¸°ê¸°: $sessionId');
      print('ì—…ë°ì´íŠ¸ ì„±ê³µ - ëª¨ë“  ë°ì´í„° ì €ì¥ë¨');
      
    } catch (e) {
      print('Firebase ì—…ë°ì´íŠ¸ ì˜¤ë¥˜: $e');
      print('ì˜¤ë¥˜ ìƒì„¸ ì •ë³´: ${e.toString()}');
    } finally {
      _isUpdating = false;
      // ì•½ê°„ì˜ ì§€ì—° í›„ ë¡œì»¬ ì—…ë°ì´íŠ¸ í”Œë˜ê·¸ í•´ì œ
      Future.delayed(const Duration(milliseconds: 500), () {
        _isLocalUpdate = false;
      });
    }
  }
  
  // Firebaseì—ì„œ ì™„ì „í•œ ë°ì´í„° ë¡œë“œ (íƒ€ì„ìŠ¤íƒ¬í”„ ê¸°ë°˜ ë™ê¸°í™”)
  Future<void> _loadCompleteDataFromFirebase() async {
    if (_isUpdating) return;
    
    _isUpdating = true;
    
    try {
      print('Firebaseì—ì„œ ì™„ì „í•œ ë°ì´í„° ë¡œë“œ ì‹œì‘... (í˜ì´ì§€: $currentPage)');
      
      // ëª¨ë“  ë°ì´í„°ë¥¼ ë³‘ë ¬ë¡œ ê°€ì ¸ì˜¤ê¸°
      final futures = await Future.wait([
        _linesRef.get(),
        _circlesRef.get(),
        _currentPointRef.get(),
      ]);
      
      final linesSnapshot = futures[0];
      final circlesSnapshot = futures[1];
      final currentPointSnapshot = futures[2];
      
      setState(() {
        // ì„  ë°ì´í„° ë¡œë“œ
        final newLines = <Line>[];
        if (linesSnapshot.exists && linesSnapshot.value != null) {
          final data = linesSnapshot.value as List;
          newLines.addAll(data
              .where((item) => item != null)
              .map((item) => Line.fromJson(item as Map<dynamic, dynamic>))
              .toList());
        }
        lines = newLines;
        
        // ì› ë°ì´í„° ë¡œë“œ
        final newCircles = <Circle>[];
        if (circlesSnapshot.exists && circlesSnapshot.value != null) {
          final data = circlesSnapshot.value as List;
          newCircles.addAll(data
              .where((item) => item != null)
              .map((item) => Circle.fromJson(item as Map<dynamic, dynamic>))
              .toList());
        }
        circles = newCircles;
        
        // í˜„ì¬ ì  ë¡œë“œ
        if (currentPointSnapshot.exists && currentPointSnapshot.value != null) {
          final data = currentPointSnapshot.value as Map;
          currentPoint = Offset(
            (data['x'] as num).toDouble(),
            (data['y'] as num).toDouble(),
          );
        }
        
        print('ì™„ì „í•œ ë°ì´í„° ë¡œë“œ ì™„ë£Œ (í˜ì´ì§€: $currentPage) - ì„ : ${lines.length}, ì›: ${circles.length}');
      });
      
    } catch (e) {
      print('ì™„ì „í•œ ë°ì´í„° ë¡œë“œ ì˜¤ë¥˜: $e');
    } finally {
      _isUpdating = false;
    }
  }
  


  // ìŒì„± ì¸ì‹ ì´ˆê¸°í™”
  Future<void> _initSpeech() async {
    print('ìŒì„± ì¸ì‹ ì´ˆê¸°í™” ì‹œì‘...');
    
    if (kIsWeb) {
      // ì›¹ì—ì„œëŠ” ë„¤ì´í‹°ë¸Œ Web Speech API ì‚¬ìš©
      await _initWebSpeech();
    } else {
      // ëª¨ë°”ì¼ì—ì„œëŠ” speech_to_text íŒ¨í‚¤ì§€ ì‚¬ìš©
      await _initMobileSpeech();
    }
  }
  
  // ì›¹ ì „ìš© ìŒì„± ì¸ì‹ ì´ˆê¸°í™”
  Future<void> _initWebSpeech() async {
    print('ì›¹ ìŒì„± ì¸ì‹ ì´ˆê¸°í™” ì‹œì‘...');
    print('PWA ëª¨ë“œ: ${AppVersion.isPWA}');
    
    // iPad PWAì—ì„œ ê¶Œí•œ ì‚¬ì „ ìš”ì²­
    if (AppVersion.isPWA && isTablet) {
      print('iPad PWA ê°ì§€ - ì‚¬ì „ ê¶Œí•œ ìš”ì²­ ì‹œë„');
      try {
        // ê¶Œí•œ ìƒíƒœ ë¨¼ì € í™•ì¸
        final permissionStatus = await html.window.navigator.permissions?.query({
          'name': 'microphone'
        });
        print('í˜„ì¬ ë§ˆì´í¬ ê¶Œí•œ ìƒíƒœ: ${permissionStatus?.state}');
        
        // ê¶Œí•œì´ prompt ìƒíƒœë©´ ì‚¬ìš©ìì—ê²Œ ì•ˆë‚´
        if (permissionStatus?.state == 'prompt') {
          if (mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(
                content: Text('ìŒì„±ì¸ì‹ì„ ì‚¬ìš©í•˜ë ¤ë©´ ë§ˆì´í¬ ê¶Œí•œì„ í—ˆìš©í•´ì£¼ì„¸ìš”.'),
                duration: Duration(seconds: 3),
                backgroundColor: Color(0xFF569CD6),
              ),
            );
          }
        }
      } catch (e) {
        print('ê¶Œí•œ ìƒíƒœ í™•ì¸ ì‹¤íŒ¨: $e');
      }
    }
    
    try {
      // Web Speech API ì§€ì› í™•ì¸
      final userAgent = html.window.navigator.userAgent;
      print('ì‚¬ìš©ì ì—ì´ì „íŠ¸: $userAgent');
      
      // Safari, Chrome, Edge ë“± ì§€ì› ë¸Œë¼ìš°ì € í™•ì¸
      if (userAgent.contains('Chrome') || 
          userAgent.contains('Edge') || 
          userAgent.contains('Safari')) {
        print('Web Speech API ì§€ì› ë¸Œë¼ìš°ì € ê°ì§€');
        
        try {
          // ë¨¼ì € í‘œì¤€ SpeechRecognition ì‹œë„
          _webSpeechRecognition = html.SpeechRecognition();
          print('SpeechRecognition ê°ì²´ ìƒì„± ì„±ê³µ');
        } catch (e) {
          print('SpeechRecognition ê°ì²´ ìƒì„± ì‹¤íŒ¨: $e');
          
          // Safari ë¸Œë¼ìš°ì €ì—ì„œ webkit ì ‘ë‘ì‚¬ ì‹œë„
          if (userAgent.contains('Safari') && !userAgent.contains('Chrome')) {
            print('Safari ë¸Œë¼ìš°ì € ê°ì§€ - webkit ì ‘ë‘ì‚¬ ì‹œë„');
            
            try {
              // PWAì™€ ì¼ë°˜ ë¸Œë¼ìš°ì € ëª¨ë‘ì—ì„œ ë™ì¼í•œ ë°©ì‹ìœ¼ë¡œ í™•ì¸
              final webkitSupported = js.context.callMethod('eval', [
                'typeof webkitSpeechRecognition !== "undefined"'
              ]) as bool;
              
              print('webkitSpeechRecognition ì§€ì›: $webkitSupported (PWA: ${AppVersion.isPWA})');
              
              if (webkitSupported) {
                // iPad PWAì—ì„œ ì¶”ê°€ ì´ˆê¸°í™”
                if (AppVersion.isPWA && isTablet) {
                  print('iPad PWA ëª¨ë“œ - webkitSpeechRecognition ì¶”ê°€ ì´ˆê¸°í™”');
                  
                  // PWAì—ì„œ webkitSpeechRecognition ê°ì²´ ìƒì„± í…ŒìŠ¤íŠ¸
                  try {
                    js.context.callMethod('eval', ['''
                      // webkitSpeechRecognition í…ŒìŠ¤íŠ¸ ê°ì²´ ìƒì„±
                      window._testSpeechRecognition = new webkitSpeechRecognition();
                      window._testSpeechRecognition = null; // ì¦‰ì‹œ í•´ì œ
                      console.log('iPad PWA: webkitSpeechRecognition ê°ì²´ ìƒì„± í…ŒìŠ¤íŠ¸ ì„±ê³µ');
                    ''']);
                  } catch (e) {
                    print('iPad PWA webkitSpeechRecognition ê°ì²´ ìƒì„± ì‹¤íŒ¨: $e');
                    throw Exception('iPad PWAì—ì„œ ìŒì„±ì¸ì‹ ê°ì²´ë¥¼ ìƒì„±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                  }
                }
                
                _webSpeechAvailable = true;
                _speechAvailable = true;
                print('Safari ìŒì„±ì¸ì‹ ì´ˆê¸°í™” ì„±ê³µ (PWA: ${AppVersion.isPWA})');
                return;
              }
              
              throw Exception('Safariì—ì„œ webkitSpeechRecognitionì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
            } catch (e3) {
              print('Safari webkit ì²˜ë¦¬ ì‹¤íŒ¨: $e3');
              _webSpeechAvailable = false;
              _speechAvailable = false;
              
              if (mounted) {
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(
                    content: Text('Safariì—ì„œëŠ” ìŒì„± ì¸ì‹ ì§€ì›ì´ ì œí•œë©ë‹ˆë‹¤. Chrome ë˜ëŠ” Edge ì‚¬ìš©ì„ ê¶Œì¥í•©ë‹ˆë‹¤.'),
                    duration: Duration(seconds: 5),
                    backgroundColor: Color(0xFFCE9178),
                  ),
                );
              }
              return;
            }
          }
          
          throw Exception('ì´ ë¸Œë¼ìš°ì €ëŠ” ìŒì„± ì¸ì‹ì„ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.');
        }
        
        if (_webSpeechRecognition != null) {
          print('SpeechRecognition ê°ì²´ ìƒì„± ì„±ê³µ');
          
          // ìŒì„± ì¸ì‹ ì„¤ì • (ê°ë„ í–¥ìƒ)
          _webSpeechRecognition!.lang = 'ko-KR';
          _webSpeechRecognition!.continuous = true;
          _webSpeechRecognition!.interimResults = true;
          _webSpeechRecognition!.maxAlternatives = 3; // ëŒ€ì•ˆ ê²°ê³¼ ì¦ê°€
          
          // ê°ë„ í–¥ìƒì„ ìœ„í•œ ì¶”ê°€ ì„¤ì •
          js.context.callMethod('eval', ['''
            if (window.webkitSpeechRecognition) {
              window.webkitSpeechRecognition.prototype.constructor.prototype.grammars = null;
              window.webkitSpeechRecognition.prototype.constructor.prototype.serviceURI = null;
            }
            
            // ìŒì„± ì¸ì‹ ê°ë„ í–¥ìƒ ì„¤ì •
            if (window.speechSynthesis && window.speechSynthesis.getVoices) {
              // ìŒì„± í•©ì„± ë³¼ë¥¨ì„ í†µí•œ ë§ˆì´í¬ ê°ë„ ê°„ì ‘ ì¡°ì •
              window.speechSynthesis.volume = 1.0;
            }
          ''']);
          
          // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì„¤ì •
          _webSpeechRecognition!.onResult.listen((event) {
            print('ì›¹ ìŒì„± ì¸ì‹ ê²°ê³¼ ìˆ˜ì‹ : ${event.results}');
            if (event.results!.isNotEmpty) {
              final result = event.results!.last;
              // SpeechRecognitionResultì˜ ì²« ë²ˆì§¸ alternative ì ‘ê·¼
              final length = result.length;
              if (length != null && length > 0) {
                final alternative = result.item(0);
                final transcript = alternative?.transcript;
                print('ì¸ì‹ëœ í…ìŠ¤íŠ¸: $transcript');
                
                setState(() {
                  _recognizedText = transcript ?? '';
                  _lastWords = transcript ?? '';
                });
                
                // ìµœì¢… ê²°ê³¼ë§Œ ì²˜ë¦¬í•˜ì—¬ ì¤‘ë³µ ë°©ì§€
                if (result.isFinal == true) {
                  print('ìµœì¢… ê²°ê³¼ ì²˜ë¦¬');
                  _processRecognizedText(_recognizedText);
                  // ì—°ì† ëª¨ë“œì´ë¯€ë¡œ ìŒì„± ì¸ì‹ì„ ì¤‘ì§€í•˜ì§€ ì•ŠìŒ
                  print('ì›¹ ì—°ì† ëª¨ë“œ - ìŒì„± ì¸ì‹ ê³„ì† ìœ ì§€');
                } else {
                  // ì¤‘ê°„ ê²°ê³¼ëŠ” UI ì—…ë°ì´íŠ¸ë§Œ í•˜ê³  ì²˜ë¦¬í•˜ì§€ ì•ŠìŒ
                  print('ì¤‘ê°„ ê²°ê³¼ - UI ì—…ë°ì´íŠ¸ë§Œ: $_recognizedText');
                }
              }
            }
          });
          
          _webSpeechRecognition!.onError.listen((event) {
            print('ì›¹ ìŒì„± ì¸ì‹ ì˜¤ë¥˜: ${event.error}');
            
            // aborted ì˜¤ë¥˜ ì²˜ë¦¬
            if (event.error == 'aborted') {
              print('ìŒì„± ì¸ì‹ì´ ì¤‘ë‹¨ë¨ (ì •ìƒ ì¢…ë£Œ ë˜ëŠ” ê¶Œí•œ ë¬¸ì œ)');
              setState(() {
                _isListening = false;
              });
              // continuous=false ëª¨ë“œì—ì„œ stop() í˜¸ì¶œ ì‹œ abortedëŠ” ì •ìƒ ë™ì‘
              // ì‚¬ìš©ìì—ê²Œ ì˜¤ë¥˜ ë©”ì‹œì§€ë¥¼ í‘œì‹œí•˜ì§€ ì•ŠìŒ
              return;
            }
            
            // no-speech ì˜¤ë¥˜ëŠ” ë¬´ì‹œ (ìŒì„±ì´ ê°ì§€ë˜ì§€ ì•ŠìŒ)
            if (event.error == 'no-speech') {
              print('ìŒì„±ì´ ê°ì§€ë˜ì§€ ì•ŠìŒ - ì •ìƒ ë™ì‘');
              return;
            }
            
            // ê¸°íƒ€ ì˜¤ë¥˜ ì²˜ë¦¬
            setState(() {
              _isListening = false;
            });
            
            if (mounted && event.error != 'not-allowed') {
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(
                  content: Text('ìŒì„± ì¸ì‹ ì˜¤ë¥˜: ${event.error}'),
                  duration: const Duration(seconds: 3),
                  backgroundColor: const Color(0xFFCE9178),
                ),
              );
            }
          });
          
          _webSpeechRecognition!.onEnd.listen((event) {
            print('ì›¹ ìŒì„± ì¸ì‹ ì¢…ë£Œ');
                         // ì—°ì† ëª¨ë“œë¥¼ ìœ„í•´ ìë™ìœ¼ë¡œ ë‹¤ì‹œ ì‹œì‘
             if (_isListening && mounted) {
               print('ì›¹ ì—°ì† ëª¨ë“œ - ìŒì„± ì¸ì‹ ìë™ ì¬ì‹œì‘');
               Future.delayed(const Duration(milliseconds: 100), () {
                if (_isListening && mounted && _webSpeechRecognition != null) {
                  try {
                    _webSpeechRecognition!.start();
                  } catch (e) {
                    print('ì›¹ ìŒì„± ì¸ì‹ ì¬ì‹œì‘ ì‹¤íŒ¨: $e');
                    setState(() {
                      _isListening = false;
                    });
                  }
                }
              });
            } else {
              setState(() {
                _isListening = false;
              });
            }
          });
          
          _webSpeechAvailable = true;
          _speechAvailable = true;
          print('ì›¹ ìŒì„± ì¸ì‹ ì´ˆê¸°í™” ì™„ë£Œ!');
          
          // ì´ˆê¸°í™” ì„±ê³µ ë©”ì‹œì§€ ì œê±° (íŒì—… ì—†ì´ ì¡°ìš©íˆ ì²˜ë¦¬)
        }
              } else {
          print('Web Speech APIë¥¼ ì§€ì›í•˜ì§€ ì•ŠëŠ” ë¸Œë¼ìš°ì €');
          _webSpeechAvailable = false;
          _speechAvailable = false;
          
          if (mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(
                content: Text('ì´ ë¸Œë¼ìš°ì €ëŠ” ìŒì„± ì¸ì‹ì„ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. Chrome, Edge, ë˜ëŠ” Safarië¥¼ ì‚¬ìš©í•´ì£¼ì„¸ìš”.'),
                duration: Duration(seconds: 4),
                backgroundColor: Color(0xFFCE9178),
              ),
            );
          }
        }
    } catch (e) {
      print('ì›¹ ìŒì„± ì¸ì‹ ì´ˆê¸°í™” ì˜¤ë¥˜: $e');
      _webSpeechAvailable = false;
      _speechAvailable = false;
      
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('ìŒì„± ì¸ì‹ ì´ˆê¸°í™” ì‹¤íŒ¨: $e'),
            duration: const Duration(seconds: 3),
            backgroundColor: const Color(0xFFCE9178),
          ),
        );
      }
    }
  }
  
  // ëª¨ë°”ì¼ ì „ìš© ìŒì„± ì¸ì‹ ì´ˆê¸°í™”
  Future<void> _initMobileSpeech() async {
    print('ëª¨ë°”ì¼ ìŒì„± ì¸ì‹ ì´ˆê¸°í™” ì‹œì‘...');
    try {
      _speech = stt.SpeechToText();
      print('SpeechToText ê°ì²´ ìƒì„± ì™„ë£Œ');
      
      _speechEnabled = await _speech.initialize(
        onStatus: (val) {
          print('ìŒì„± ì¸ì‹ ìƒíƒœ ë³€ê²½: $val');
          if (val == 'done' || val == 'notListening') {
            setState(() {
              _isListening = false;
            });
          }
        },
        onError: (val) {
          print('ìŒì„± ì¸ì‹ ì˜¤ë¥˜ ë°œìƒ: $val');
          setState(() {
            _isListening = false;
          });
        },
        debugLogging: true, // ë””ë²„ê¹… ë¡œê·¸ í™œì„±í™”
      );
      
      _speechAvailable = _speechEnabled;
      print('ëª¨ë°”ì¼ ìŒì„± ì¸ì‹ ì´ˆê¸°í™” ì™„ë£Œ - ì‚¬ìš© ê°€ëŠ¥: $_speechAvailable');
      
      if (!_speechAvailable) {
        print('ê²½ê³ : ìŒì„± ì¸ì‹ì„ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ê¶Œí•œì„ í™•ì¸í•´ì£¼ì„¸ìš”.');
        
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('ìŒì„± ì¸ì‹ì„ ì‚¬ìš©í•˜ë ¤ë©´ ë§ˆì´í¬ ê¶Œí•œì„ í—ˆìš©í•´ì£¼ì„¸ìš”.'),
              duration: Duration(seconds: 3),
              backgroundColor: Color(0xFFCE9178),
            ),
          );
        }
      }
    } catch (e) {
      print('ëª¨ë°”ì¼ ìŒì„± ì¸ì‹ ì´ˆê¸°í™” ì¤‘ ì˜¤ë¥˜: $e');
      _speechAvailable = false;
      _speechEnabled = false;
      
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('ìŒì„± ì¸ì‹ ì´ˆê¸°í™” ì‹¤íŒ¨: $e'),
            duration: const Duration(seconds: 3),
            backgroundColor: const Color(0xFFCE9178),
          ),
        );
      }
    }
  }

  // ìŒì„± ì¸ì‹ ì‹œì‘
  void _startListening() async {
    print('ìŒì„± ì¸ì‹ ì‹œì‘ ë²„íŠ¼ í´ë¦­ë¨');
    print('í˜„ì¬ ìƒíƒœ - _speechEnabled: $_speechEnabled, _speechAvailable: $_speechAvailable');
    
    // ìŒì„± ì¸ì‹ ì‹œì‘ ì‹œ ì²˜ë¦¬ í”Œë˜ê·¸ ë° ì¹´ìš´í„° ë¦¬ì…‹
    _isSpeechProcessing = false;
    _speechProcessCount = 0;
    _lastProcessedText = null;
    _lastProcessedNumber = null;
    _processedTexts.clear(); // ì²˜ë¦¬ëœ í…ìŠ¤íŠ¸ ì§‘í•© ì´ˆê¸°í™”
    _recentlyProcessedNumbers.clear(); // ì²˜ë¦¬ëœ ìˆ«ì ì§‘í•© ì´ˆê¸°í™”
    _lastLineDrawTime = null;
    
    if (!_speechAvailable) {
      print('ìŒì„± ì¸ì‹ì„ ì‚¬ìš©í•  ìˆ˜ ì—†ìŒ - ì¬ì´ˆê¸°í™” ì‹œë„');
      await _initSpeech();
      
      if (!_speechAvailable) {
        print('ì¬ì´ˆê¸°í™” í›„ì—ë„ ìŒì„± ì¸ì‹ ì‚¬ìš© ë¶ˆê°€');
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('ìŒì„± ì¸ì‹ì„ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë¸Œë¼ìš°ì € ì„¤ì •ì„ í™•ì¸í•´ì£¼ì„¸ìš”.'),
              duration: Duration(seconds: 3),
              backgroundColor: Color(0xFFCE9178),
            ),
          );
        }
        return;
      }
    }
    
    if (kIsWeb) {
      await _startWebListening();
    } else {
      await _startMobileListening();
    }
  }

  // ì›¹ ì „ìš© ìŒì„± ì¸ì‹ ì‹œì‘
  Future<void> _startWebListening() async {
    print('ì›¹ ìŒì„± ì¸ì‹ ì‹œì‘ ì¤‘...');
    print('PWA ëª¨ë“œ: ${AppVersion.isPWA}');
    print('í˜„ì¬ ë ˆì´ì•„ì›ƒ: $layoutMode');
    
    try {
      // ëª¨ë“  í”Œë«í¼ì—ì„œ ë§ˆì´í¬ ê¶Œí•œ ìš”ì²­ (iPad PWA í¬í•¨)
      final isIPadPWA = AppVersion.isPWA && isTablet;
      
      if (isIPadPWA) {
        print('ì•„ì´íŒ¨ë“œ PWA ëª¨ë“œ - ë§ˆì´í¬ ê¶Œí•œ ìš”ì²­ ì‹œì‘');
      }
      
      try {
        // ê¶Œí•œ ìš”ì²­ ì „ì— webkitSpeechRecognition ê°€ìš©ì„± í™•ì¸
        if (isIPadPWA) {
          final webkitAvailable = js.context.callMethod('eval', [
            'typeof webkitSpeechRecognition !== "undefined"'
          ]) as bool;
          print('iPad PWA webkitSpeechRecognition ê°€ìš©ì„±: $webkitAvailable');
          
          if (!webkitAvailable) {
            throw Exception('iPad PWAì—ì„œ ìŒì„±ì¸ì‹ APIë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
          }
        }
        
        final mediaStream = await html.window.navigator.mediaDevices?.getUserMedia({
          'audio': {
            'echoCancellation': true,
            'noiseSuppression': false, // ë…¸ì´ì¦ˆ ì–µì œ ë„ê¸°ë¡œ ê°ë„ í–¥ìƒ
            'autoGainControl': true,
            'sampleRate': 44100,
            'channelCount': 1,
          },
        });
        print('ë§ˆì´í¬ ê¶Œí•œ í—ˆìš©ë¨ (ê°ë„ í–¥ìƒ ì„¤ì •)');
        
        // iPad PWAì—ì„œëŠ” ìŠ¤íŠ¸ë¦¼ì„ ë” ì˜¤ë˜ ìœ ì§€
        if (mediaStream != null) {
          final delay = isIPadPWA ? 500 : 100;
          Future.delayed(Duration(milliseconds: delay), () {
            mediaStream.getTracks().forEach((track) => track.stop());
            print('ê¶Œí•œ ì²´í¬ìš© ìŠ¤íŠ¸ë¦¼ ì¢…ë£Œ (${delay}ms í›„)');
          });
        }
      } catch (e) {
        print('ë§ˆì´í¬ ê¶Œí•œ ìš”ì²­ ì‹¤íŒ¨: $e');
        
        if (isIPadPWA) {
          // iPad PWAì—ì„œ ê¶Œí•œ ì‹¤íŒ¨ ì‹œ ëª…í™•í•œ ì•ˆë‚´
          if (mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(
                content: Text('ğŸ“± iPad ê¶Œí•œ ì„¤ì • í•„ìš”:\n\n'
                    '1. ì„¤ì • > ê°œì¸ì •ë³´ ë³´í˜¸ ë° ë³´ì•ˆ > ë§ˆì´í¬\n'
                    '2. Safariê°€ ìˆìœ¼ë©´ ì¼œê¸°\n'
                    '3. ì—†ìœ¼ë©´ Safariì—ì„œ hvl.kr ì ‘ì† í›„ ìŒì„±ì¸ì‹ í—ˆìš©'),
                duration: Duration(seconds: 8),
                backgroundColor: Color(0xFFCE9178),
              ),
            );
          }
          throw Exception('iPad PWA ë§ˆì´í¬ ê¶Œí•œ ê±°ë¶€ë¨');
        }
      }
      
      final userAgent = html.window.navigator.userAgent;
      
      // Safariì—ì„œëŠ” webkit ì ‘ë‘ì‚¬ ì‚¬ìš©
      if (userAgent.contains('Safari') && !userAgent.contains('Chrome')) {
        print('Safariì—ì„œ webkit ìŒì„± ì¸ì‹ ì‹œì‘');
        await _startSafariListening();
      } else if (_webSpeechRecognition != null && _webSpeechAvailable) {
        print('í‘œì¤€ ì›¹ ìŒì„± ì¸ì‹ ì‹œì‘');
        _webSpeechRecognition!.start();
        
        setState(() {
          _isListening = true;
          _recognizedText = '';
          _lastWords = '';
        });
        
        print('ì›¹ ìŒì„± ì¸ì‹ ì‹œì‘ë¨ - ìƒíƒœ: $_isListening');
        
        // ìŒì„± ì¸ì‹ ì‹œì‘ ë©”ì‹œì§€ ì œê±° (íŒì—… ì—†ì´ ì¡°ìš©íˆ ì²˜ë¦¬)
      } else {
        print('ì›¹ ìŒì„± ì¸ì‹ ê°ì²´ê°€ ì—†ìŒ');
        throw Exception('ì›¹ ìŒì„± ì¸ì‹ì„ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
      }
    } catch (e) {
      print('ì›¹ ìŒì„± ì¸ì‹ ì‹œì‘ ì¤‘ ì˜¤ë¥˜: $e');
      setState(() {
        _isListening = false;
      });
      
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('ìŒì„± ì¸ì‹ ì‹œì‘ ì‹¤íŒ¨: $e'),
            duration: const Duration(seconds: 3),
            backgroundColor: const Color(0xFFCE9178),
          ),
        );
      }
    }
  }
  
  // Safari ì „ìš© ìŒì„± ì¸ì‹ ì‹œì‘
  Future<void> _startSafariListening() async {
    print('Safari webkit ìŒì„± ì¸ì‹ ì‹œì‘');
    print('PWA ëª¨ë“œ: ${AppVersion.isPWA}');
    
    try {
      // ì•„ì´íŒ¨ë“œ PWAì—ì„œë§Œ ì¶”ê°€ ê¶Œí•œ í™•ì¸
      final isIPadPWA = AppVersion.isPWA && isTablet;
      
      if (isIPadPWA) {
        print('ì•„ì´íŒ¨ë“œ PWA ëª¨ë“œ - ìŒì„±ì¸ì‹ ê¶Œí•œ í™•ì¸');
        
        // ë§ˆì´í¬ ê¶Œí•œ í™•ì¸ (ì•„ì´íŒ¨ë“œ PWAì—ì„œëŠ” í•„ìˆ˜)
        try {
          final permissionStatus = await html.window.navigator.permissions?.query({'name': 'microphone'});
          print('ì•„ì´íŒ¨ë“œ PWA ë§ˆì´í¬ ê¶Œí•œ ìƒíƒœ: ${permissionStatus?.state}');
          
          if (permissionStatus?.state == 'denied') {
            throw Exception('ë§ˆì´í¬ ê¶Œí•œì´ ê±°ë¶€ë˜ì—ˆìŠµë‹ˆë‹¤.');
          }
        } catch (e) {
          print('ì•„ì´íŒ¨ë“œ PWA ê¶Œí•œ í™•ì¸ ì‹¤íŒ¨: $e');
          // ê¶Œí•œ í™•ì¸ ì‹¤íŒ¨í•´ë„ ê³„ì† ì§„í–‰
        }
      }
      
      // iPad PWAì—ì„œ íŠ¹ë³„í•œ ì²˜ë¦¬ê°€ í•„ìš”í•œì§€ í™•ì¸
      if (isIPadPWA) {
        print('iPad PWA ëª¨ë“œ - Safari ìŒì„±ì¸ì‹ íŠ¹ë³„ ì²˜ë¦¬');
        
        // PWAì—ì„œ ê¶Œí•œ ì¬í™•ì¸
        try {
          final permissionResult = await html.window.navigator.permissions?.query({
            'name': 'microphone'
          });
          print('iPad PWA í˜„ì¬ ë§ˆì´í¬ ê¶Œí•œ ìƒíƒœ: ${permissionResult?.state}');
        } catch (e) {
          print('ê¶Œí•œ ìƒíƒœ í™•ì¸ ì‹¤íŒ¨: $e');
        }
      }
      
      // JavaScript ì½”ë“œë¥¼ ì§ì ‘ ì‹¤í–‰í•˜ì—¬ ìŒì„± ì¸ì‹ ì²˜ë¦¬
      js.context.callMethod('eval', ['''
        try {
          // PWA ëª¨ë“œì—ì„œ webkitSpeechRecognition ìƒì„± ì‹œë„
          if (typeof webkitSpeechRecognition === 'undefined') {
            console.error('webkitSpeechRecognitionì´ ì •ì˜ë˜ì§€ ì•ŠìŒ');
            throw new Error('webkitSpeechRecognition not available');
          }
          
          // iPad PWAì—ì„œëŠ” ë‹¤ë¥¸ ì„¤ì • ì‚¬ìš©
          var isIPadPWA = ${isIPadPWA ? 'true' : 'false'};
          
          window.safariSpeechRecognition = new webkitSpeechRecognition();
          window.safariSpeechRecognition.lang = 'ko-KR';
          
          // iPad PWAì—ì„œëŠ” continuousë¥¼ trueë¡œ ì„¤ì • (ë” ë‚˜ì€ í˜¸í™˜ì„±)
          window.safariSpeechRecognition.continuous = isIPadPWA ? true : false;
          window.safariSpeechRecognition.interimResults = true;
          window.safariSpeechRecognition.maxAlternatives = 1;
          
          console.log('Safari ìŒì„±ì¸ì‹ ê°ì²´ ìƒì„± ì„±ê³µ (iPad PWA: ' + isIPadPWA + ')');
        } catch (e) {
          console.error('Safari ìŒì„±ì¸ì‹ ê°ì²´ ìƒì„± ì‹¤íŒ¨:', e);
          window.safariSpeechRecognitionError = e.toString();
        }
        
        // ê°ë„ í–¥ìƒì„ ìœ„í•œ ì¶”ê°€ ì„¤ì •
        try {
          window.safariSpeechRecognition.grammars = null;
          window.safariSpeechRecognition.serviceURI = null;
          
          // Safariì—ì„œ ìŒì„± ì¸ì‹ ê°ë„ í–¥ìƒ
          if (window.speechSynthesis && window.speechSynthesis.getVoices) {
            window.speechSynthesis.volume = 1.0;
          }
          
          // ì¶”ê°€ Safari ìµœì í™”
          window.safariSpeechRecognition.sensitivity = 0.7; // ê°ë„ ì„¤ì • (0.0 ~ 1.0)
        } catch(e) {
          console.log('Safari ì¶”ê°€ ì„¤ì • ì‹¤íŒ¨:', e);
        }
        
        console.log('Safari ìŒì„± ì¸ì‹ ì„¤ì • ì™„ë£Œ');
        
        window.safariSpeechRecognition.onresult = function(event) {
          console.log('Safari ìŒì„± ì¸ì‹ ê²°ê³¼:', event);
          
          var results = event.results;
          var lastResult = results[results.length - 1];
          var transcript = lastResult[0].transcript;
          var isFinal = lastResult.isFinal;
          
          console.log('Safari ì¸ì‹ëœ í…ìŠ¤íŠ¸:', transcript);
          console.log('Safari ìµœì¢… ê²°ê³¼:', isFinal);
          
          // Dartë¡œ ê²°ê³¼ ì „ë‹¬
          window.dartSafariSpeechResult(transcript, isFinal);
        };
        
        window.safariSpeechRecognition.onerror = function(event) {
          console.log('Safari ìŒì„± ì¸ì‹ ì˜¤ë¥˜:', event.error);
          window.dartSafariSpeechError(event.error);
        };
        
        window.safariSpeechRecognition.onend = function(event) {
          console.log('Safari ìŒì„± ì¸ì‹ ì¢…ë£Œ');
          window.dartSafariSpeechEnd();
        };
        
        window.safariSpeechRecognition.onstart = function(event) {
          console.log('Safari ìŒì„± ì¸ì‹ ì‹œì‘');
          window.dartSafariSpeechStart();
        };
        
        window.safariSpeechRecognition.onspeechstart = function(event) {
          console.log('Safari ìŒì„± ê°ì§€ ì‹œì‘');
        };
        
        window.safariSpeechRecognition.onaudiostart = function(event) {
          console.log('Safari ì˜¤ë””ì˜¤ ì…ë ¥ ì‹œì‘');
        };
      ''']);
      
             // Dart ì½œë°± í•¨ìˆ˜ë“¤ ë“±ë¡
       js.context['dartSafariSpeechResult'] = js.allowInterop((String transcript, bool isFinal) {
         print('Dart ì½œë°± - Safari ìŒì„± ê²°ê³¼: $transcript, ìµœì¢…: $isFinal');
         
         setState(() {
           _recognizedText = transcript;
           _lastWords = transcript;
         });
         
         // ìµœì¢… ê²°ê³¼ë§Œ ì²˜ë¦¬í•˜ì—¬ ì¤‘ë³µ ë°©ì§€
         if (isFinal) {
           print('Safari ìµœì¢… ê²°ê³¼ ì²˜ë¦¬ ì‹œì‘');
           _processRecognizedText(transcript);
           // ì—°ì† ëª¨ë“œì´ë¯€ë¡œ ìŒì„± ì¸ì‹ì„ ì¤‘ì§€í•˜ì§€ ì•ŠìŒ
           print('Safari ì—°ì† ëª¨ë“œ - ìŒì„± ì¸ì‹ ê³„ì† ìœ ì§€');
         } else {
           // ì¤‘ê°„ ê²°ê³¼ëŠ” UI ì—…ë°ì´íŠ¸ë§Œ
           print('Safari ì¤‘ê°„ ê²°ê³¼: $transcript (UI ì—…ë°ì´íŠ¸ë§Œ)');
         }
       });
      
      js.context['dartSafariSpeechError'] = js.allowInterop((String error) {
        print('Dart ì½œë°± - Safari ìŒì„± ì˜¤ë¥˜: $error');
        
        // aborted ì˜¤ë¥˜ ì²˜ë¦¬
        if (error == 'aborted') {
          print('Safari ìŒì„± ì¸ì‹ì´ ì¤‘ë‹¨ë¨ (ì •ìƒ ì¢…ë£Œ ë˜ëŠ” ê¶Œí•œ ë¬¸ì œ)');
          setState(() {
            _isListening = false;
          });
          // continuous=false ëª¨ë“œì—ì„œ stop() í˜¸ì¶œ ì‹œ abortedëŠ” ì •ìƒ ë™ì‘
          return;
        }
        
        // no-speech ì˜¤ë¥˜ëŠ” ë¬´ì‹œ
        if (error == 'no-speech') {
          print('Safari ìŒì„±ì´ ê°ì§€ë˜ì§€ ì•ŠìŒ - ì •ìƒ ë™ì‘');
          return;
        }
        
        // ê¸°íƒ€ ì˜¤ë¥˜ ì²˜ë¦¬
        setState(() {
          _isListening = false;
        });
        
        if (mounted && error != 'not-allowed') {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('ìŒì„± ì¸ì‹ ì˜¤ë¥˜: $error'),
              duration: const Duration(seconds: 3),
              backgroundColor: const Color(0xFFCE9178),
            ),
          );
        }
      });
      
      js.context['dartSafariSpeechEnd'] = js.allowInterop(() {
        print('Dart ì½œë°± - Safari ìŒì„± ì¸ì‹ ì¢…ë£Œ');
                 // ì—°ì† ëª¨ë“œë¥¼ ìœ„í•´ ìë™ìœ¼ë¡œ ë‹¤ì‹œ ì‹œì‘
         if (_isListening && mounted) {
           print('Safari ì—°ì† ëª¨ë“œ - ìŒì„± ì¸ì‹ ìë™ ì¬ì‹œì‘');
           Future.delayed(const Duration(milliseconds: 100), () {
            if (_isListening && mounted) {
              try {
                js.context.callMethod('eval', ['window.safariSpeechRecognition && window.safariSpeechRecognition.start();']);
              } catch (e) {
                print('Safari ìŒì„± ì¸ì‹ ì¬ì‹œì‘ ì‹¤íŒ¨: $e');
                setState(() {
                  _isListening = false;
                });
              }
            }
          });
        } else {
          setState(() {
            _isListening = false;
          });
        }
      });
      
      js.context['dartSafariSpeechStart'] = js.allowInterop(() {
        print('Dart ì½œë°± - Safari ìŒì„± ì¸ì‹ ì‹œì‘');
        setState(() {
          _isListening = true;
          _recognizedText = '';
          _lastWords = '';
        });
      });
      
      // ì—ëŸ¬ ì²´í¬
      final creationError = js.context['safariSpeechRecognitionError'];
      if (creationError != null) {
        print('Safari ìŒì„±ì¸ì‹ ìƒì„± ì˜¤ë¥˜ ê°ì§€: $creationError');
        throw Exception('Safari ìŒì„±ì¸ì‹ ìƒì„± ì‹¤íŒ¨: $creationError');
      }
      
      // ìŒì„± ì¸ì‹ ì‹œì‘
      final hasRecognition = js.context.callMethod('eval', [
        'window.safariSpeechRecognition != null'
      ]) as bool;
      
      if (!hasRecognition) {
        throw Exception('Safari ìŒì„±ì¸ì‹ ê°ì²´ê°€ ìƒì„±ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
      }
      
      // iPad PWAì—ì„œëŠ” ì•½ê°„ì˜ ì§€ì—° í›„ ì‹œì‘
      if (isIPadPWA) {
        print('iPad PWA - ìŒì„±ì¸ì‹ ì‹œì‘ ì „ ì§€ì—° (ê¶Œí•œ ì•ˆì •í™”)');
        await Future.delayed(const Duration(milliseconds: 300));
      }
      
      // ìŒì„±ì¸ì‹ ì‹œì‘ ì‹œë„
      js.context.callMethod('eval', ['''
        try {
          window.safariSpeechRecognition.start();
          console.log('Safari ìŒì„±ì¸ì‹ start() í˜¸ì¶œ ì„±ê³µ');
        } catch (e) {
          console.error('Safari ìŒì„±ì¸ì‹ start() ì‹¤íŒ¨:', e);
          window.safariStartError = e.toString();
          throw e;
        }
      ''']);
      
      print('Safari ìŒì„± ì¸ì‹ ì‹œì‘ ìš”ì²­ ì™„ë£Œ');
      
      // Safari ìŒì„± ì¸ì‹ ì‹œì‘ ë©”ì‹œì§€ ì œê±° (íŒì—… ì—†ì´ ì¡°ìš©íˆ ì²˜ë¦¬)

    } catch (e) {
      print('Safari ìŒì„± ì¸ì‹ ì‹œì‘ ì‹¤íŒ¨: $e');
      
      // ì‹œì‘ ì—ëŸ¬ ìƒì„¸ ì •ë³´ í™•ì¸
      try {
        final startError = js.context['safariStartError'];
        if (startError != null) {
          print('Safari ì‹œì‘ ì—ëŸ¬ ìƒì„¸: $startError');
        }
      } catch (e2) {
        print('ì—ëŸ¬ ì •ë³´ í™•ì¸ ì‹¤íŒ¨: $e2');
      }
      
      setState(() {
        _isListening = false;
      });
      
      if (mounted) {
        String errorMessage = 'Safari ìŒì„± ì¸ì‹ ì‹œì‘ ì‹¤íŒ¨: $e';
        
        // ì•„ì´íŒ¨ë“œ PWA ëª¨ë“œì—ì„œë§Œ íŠ¹ë³„í•œ ì•ˆë‚´ ë©”ì‹œì§€
        final isIPadPWA = AppVersion.isPWA && isTablet;
        if (isIPadPWA) {
          // ë” êµ¬ì²´ì ì¸ í•´ê²° ë°©ë²• ì•ˆë‚´
          errorMessage = 'âœ… iPad í™ˆí™”ë©´ ì•± ìŒì„±ì¸ì‹ í•´ê²° ë°©ë²•:\n\n'
              'ë°©ë²• 1 (ê¶Œì¥):\n'
              'â€¢ í™ˆí™”ë©´ ì•± ì‚­ì œ â†’ Safariì—ì„œ hvl.kr ì ‘ì†\n'
              'â€¢ ìŒì„±ì¸ì‹ ë²„íŠ¼ í´ë¦­í•˜ì—¬ ê¶Œí•œ í—ˆìš©\n'
              'â€¢ ê³µìœ  ë²„íŠ¼ â†’ í™ˆí™”ë©´ì— ì¶”ê°€\n\n'
              'ë°©ë²• 2 (ì„¤ì •ì—ì„œ í™•ì¸):\n'
              'â€¢ ì„¤ì • > ê°œì¸ì •ë³´ ë³´í˜¸ ë° ë³´ì•ˆ > ë§ˆì´í¬ > Safari ì¼œê¸°\n'
              'â€¢ ì„¤ì • > Safari > ì¹´ë©”ë¼ ë° ë§ˆì´í¬ ì ‘ê·¼ > "í™•ì¸" ì„ íƒ\n\n'
              'ë°©ë²• 3:\n'
              'â€¢ Safari ë¸Œë¼ìš°ì €ì—ì„œ hvl.kr ì§ì ‘ ì‚¬ìš©';
        }
        
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(errorMessage),
            duration: const Duration(seconds: 5),
            backgroundColor: const Color(0xFFCE9178),
          ),
        );
      }
    }
  }

  // ëª¨ë°”ì¼ ì „ìš© ìŒì„± ì¸ì‹ ì‹œì‘
  Future<void> _startMobileListening() async {
    print('ëª¨ë°”ì¼ ìŒì„± ì¸ì‹ ì‹œì‘ ì¤‘...');
    
    try {
      print('ìŒì„± ì¸ì‹ listen() í˜¸ì¶œ ì‹œì‘...');
      await _speech.listen(
        onResult: (val) {
          print('ìŒì„± ì¸ì‹ ê²°ê³¼ ì½œë°± í˜¸ì¶œë¨: ${val.recognizedWords}');
          setState(() {
            _lastWords = val.recognizedWords;
            _recognizedText = val.recognizedWords;
            print('ìŒì„± ì¸ì‹ ê²°ê³¼ ì—…ë°ì´íŠ¸: $_recognizedText');
            
            // ìµœì¢… ê²°ê³¼ë§Œ ì²˜ë¦¬í•˜ì—¬ ì¤‘ë³µ ë°©ì§€
            if (val.finalResult) {
              print('ìµœì¢… ê²°ê³¼ ì²˜ë¦¬ ì‹œì‘');
              _processRecognizedText(_recognizedText);
              // ì—°ì† ëª¨ë“œë¥¼ ìœ„í•´ ì ì‹œ í›„ ë‹¤ì‹œ ì‹œì‘
              print('ëª¨ë°”ì¼ ì—°ì† ëª¨ë“œ - ìŒì„± ì¸ì‹ ì¬ì‹œì‘ ì˜ˆì•½');
              Future.delayed(const Duration(milliseconds: 100), () {
                if (_isListening && mounted) {
                  _startMobileListening();
                }
              });
            } else {
              // ì¤‘ê°„ ê²°ê³¼ëŠ” UI ì—…ë°ì´íŠ¸ë§Œ
              print('ëª¨ë°”ì¼ ì¤‘ê°„ ê²°ê³¼: $_recognizedText (UI ì—…ë°ì´íŠ¸ë§Œ)');
            }
          });
        },
        listenFor: const Duration(seconds: 30),
        pauseFor: const Duration(milliseconds: 750), // ê°ë„ í–¥ìƒì„ ìœ„í•´ 0.75ì´ˆë¡œ ë‹¨ì¶•
        partialResults: true,
        localeId: 'ko_KR', // í•œêµ­ì–´ ì„¤ì •
        cancelOnError: false,
        listenMode: stt.ListenMode.dictation, // ê°ë„ í–¥ìƒì„ ìœ„í•´ dictation ëª¨ë“œ ì‚¬ìš©
        onSoundLevelChange: (level) {
          // ìŒì„± ë ˆë²¨ ëª¨ë‹ˆí„°ë§ìœ¼ë¡œ ê°ë„ í™•ì¸
          print('ìŒì„± ë ˆë²¨: $level');
        },
      );
      
      print('ìŒì„± ì¸ì‹ listen() í˜¸ì¶œ ì™„ë£Œ - ìƒíƒœë¥¼ listeningìœ¼ë¡œ ë³€ê²½');
      setState(() {
        _isListening = true;
      });
      
    } catch (e) {
      print('ëª¨ë°”ì¼ ìŒì„± ì¸ì‹ ì‹œì‘ ì¤‘ ì˜¤ë¥˜: $e');
      setState(() {
        _isListening = false;
      });
    }
  }

  // ìŒì„± ì¸ì‹ ì¤‘ì§€
  void _stopListening() async {
    print('ìŒì„± ì¸ì‹ ì¤‘ì§€ ë²„íŠ¼ í´ë¦­ë¨');
    
    try {
      if (kIsWeb) {
        final userAgent = html.window.navigator.userAgent;
        
        // Safariì—ì„œëŠ” webkit ê°ì²´ ì‚¬ìš©
        if (userAgent.contains('Safari') && !userAgent.contains('Chrome')) {
          print('Safari ìŒì„± ì¸ì‹ ì¤‘ì§€');
          try {
            js.context.callMethod('eval', ['window.safariSpeechRecognition && window.safariSpeechRecognition.stop();']);
          } catch (e) {
            print('Safari ìŒì„± ì¸ì‹ ì¤‘ì§€ ì‹¤íŒ¨: $e');
          }
        } else if (_webSpeechRecognition != null) {
          print('ì›¹ ìŒì„± ì¸ì‹ ì¤‘ì§€');
          _webSpeechRecognition!.stop();
        }
      } else {
        print('ëª¨ë°”ì¼ ìŒì„± ì¸ì‹ ì¤‘ì§€');
        await _speech.stop();
      }
      
      setState(() {
        _isListening = false;
      });
      
      print('ìŒì„± ì¸ì‹ ì¤‘ì§€ë¨');
      
    } catch (e) {
      print('ìŒì„± ì¸ì‹ ì¤‘ì§€ ì¤‘ ì˜¤ë¥˜: $e');
      setState(() {
        _isListening = false;
      });
    }
  }

  // ë¹ ë¥¸ ìŒì„± ì²˜ë¦¬ (ì¤‘ê°„ ê²°ê³¼ìš©) - ê°•í™”ëœ ì¤‘ë³µ ë°©ì§€
  void _processRecognizedTextFast(String text) {
    print('ë¹ ë¥¸ ìŒì„± í…ìŠ¤íŠ¸ ì²˜ë¦¬: $text');
    
    // ê¸°ë³¸ ì¤‘ë³µ ë°©ì§€
    if (_isSpeechProcessing) {
      print('ìŒì„± ì²˜ë¦¬ ì¤‘ - ë¹ ë¥¸ ì²˜ë¦¬ ë¬´ì‹œ');
      return;
    }
    
    final now = DateTime.now();
    final trimmedText = text.trim();
    
    // ì´ë¯¸ ì²˜ë¦¬ëœ í…ìŠ¤íŠ¸ì¸ì§€ í™•ì¸
    if (_processedTexts.contains(trimmedText)) {
      print('ì´ë¯¸ ì²˜ë¦¬ëœ í…ìŠ¤íŠ¸ - ë¬´ì‹œ: $trimmedText');
      return;
    }
    
    // ìµœê·¼ ì„  ê·¸ë¦¬ê¸° í›„ ë„ˆë¬´ ë¹ ë¥¸ í˜¸ì¶œ ë°©ì§€ (1ì´ˆ ì´ë‚´)
    if (_lastLineDrawTime != null && 
        now.difference(_lastLineDrawTime!).inMilliseconds < 500) {
      print('ìµœê·¼ ì„  ê·¸ë¦¬ê¸° í›„ 500ms ì´ë‚´ - ë¹ ë¥¸ ì²˜ë¦¬ ë¬´ì‹œ (${now.difference(_lastLineDrawTime!).inMilliseconds}ms)');
      return;
    }
    
    // ì‹œê°„ ê°„ê²© ê¸°ë°˜ ë¶„ë¦¬ ì²˜ë¦¬ (ì„±ëŠ¥ ìµœì í™”: 800ms â†’ 400ms)
    final speechGapThreshold = 400; // ë°˜ì‘ ì†ë„ ê°œì„ ì„ ìœ„í•´ ë” ë‹¨ì¶•
    bool isNewSpeechSession = false;
    
    if (_lastSpeechProcessTime == null || 
        now.difference(_lastSpeechProcessTime!).inMilliseconds >= speechGapThreshold) {
      isNewSpeechSession = true;
      print('ìƒˆë¡œìš´ ìŒì„± ì„¸ì…˜ ì‹œì‘ (${_lastSpeechProcessTime == null ? 'ì²˜ìŒ' : '${now.difference(_lastSpeechProcessTime!).inMilliseconds}ms ê²½ê³¼'})');
      // ìƒˆ ì„¸ì…˜ ì‹œì‘ ì‹œ ì²˜ë¦¬ëœ í…ìŠ¤íŠ¸ ì§‘í•© ì´ˆê¸°í™”
      _processedTexts.clear();
    }
    
    // ìƒˆë¡œìš´ ì„¸ì…˜ì´ ì•„ë‹ˆê³  ë™ì¼í•œ í…ìŠ¤íŠ¸ë©´ ë¬´ì‹œ
    if (!isNewSpeechSession && _lastProcessedText == trimmedText) {
      print('ë™ì¼ ì„¸ì…˜ ë‚´ ë™ì¼í•œ í…ìŠ¤íŠ¸ ì¤‘ë³µ ì²˜ë¦¬ ë°©ì§€: $text');
      return;
    }
    
    // ìƒˆë¡œìš´ ì„¸ì…˜ì´ ì•„ë‹ˆê³  ë„ˆë¬´ ë¹ ë¥¸ í˜¸ì¶œì´ë©´ ë¬´ì‹œ (ì„±ëŠ¥ ìµœì í™”: 400ms â†’ 200ms)
    if (!isNewSpeechSession && _lastSpeechProcessTime != null && 
        now.difference(_lastSpeechProcessTime!).inMilliseconds < 200) {
      print('ë™ì¼ ì„¸ì…˜ ë‚´ ë¹ ë¥¸ ì²˜ë¦¬ 200ms ì´ë‚´ ì¤‘ë³µ í˜¸ì¶œ ë¬´ì‹œ (${now.difference(_lastSpeechProcessTime!).inMilliseconds}ms)');
      return;
    }
    
    // í…ìŠ¤íŠ¸ ê¸¸ì´ ê²€ì¦ (ê°ë„ í–¥ìƒì„ ìœ„í•´ ìµœì†Œ ê¸¸ì´ ì¤„ì„)
    if (trimmedText.length < 1 || trimmedText.length > 30) {
      print('í…ìŠ¤íŠ¸ ê¸¸ì´ ë¶€ì ì ˆ - ë¬´ì‹œ: ${trimmedText.length}');
      return;
    }
    
    // ë¹ ë¥¸ ìˆ«ì ê²€ì¦ - ìˆ«ìê°€ í¬í•¨ë˜ì–´ ìˆëŠ”ì§€ ë¨¼ì € í™•ì¸
    if (!RegExp(r'\d').hasMatch(trimmedText) && 
        !RegExp(r'[ì¼ì´ì‚¼ì‚¬ì˜¤ìœ¡ì¹ íŒ”êµ¬ì‹­ë°±ì²œë§Œì˜ê³µí•˜ë‚˜ë‘˜ì…‹ë„·ë‹¤ì„¯ì—¬ì„¯ì¼ê³±ì—¬ëŸì•„í™‰ì—´ìŠ¤ë¬´ì„œë¥¸ë§ˆí”ì‰°ì˜ˆìˆœì¼í”ì—¬ë“ ì•„í”]').hasMatch(trimmedText)) {
      print('ìˆ«ì ê´€ë ¨ í…ìŠ¤íŠ¸ê°€ ì—†ìŒ - ë¹ ë¥¸ ë¬´ì‹œ: $trimmedText');
      return;
    }
    
    // í•œêµ­ì–´ ìˆ«ì ë‹¨ì–´ë¥¼ ìˆ«ìë¡œ ë³€í™˜
    String convertedText = _convertKoreanNumbersToDigits(trimmedText);
    print('ë¹ ë¥¸ ì²˜ë¦¬ - ë³€í™˜ëœ í…ìŠ¤íŠ¸: $convertedText');
    
    // ìˆ«ì ì¶”ì¶œ
    RegExp numberRegex = RegExp(r'\b(\d+(?:\.\d+)?)\b');
    final matches = numberRegex.allMatches(convertedText);
    
    if (matches.isNotEmpty) {
      // ìœ íš¨í•œ ìˆ«ìë§Œ ì„ íƒ (1-10000 ë²”ìœ„)
      double? bestNumber;
      for (final match in matches) {
        final numberStr = match.group(1);
        final number = double.tryParse(numberStr ?? '');
        if (number != null && number >= 1 && number <= 10000) {
          if (bestNumber == null || number > bestNumber) {
            bestNumber = number;
          }
        }
      }
      
      if (bestNumber != null) {
        // ìµœê·¼ì— ì²˜ë¦¬ëœ ìˆ«ìì¸ì§€ í™•ì¸
        if (_recentlyProcessedNumbers.contains(bestNumber)) {
          print('ë¹ ë¥¸ ì²˜ë¦¬ - ìµœê·¼ ì²˜ë¦¬ëœ ìˆ«ì ì¤‘ë³µ ë°©ì§€: $bestNumber');
          return;
        }
        
        print('ë¹ ë¥¸ ì²˜ë¦¬ - ì¶”ì¶œëœ ìˆ«ì: $bestNumber (ìƒˆë¡œìš´ ì„¸ì…˜: $isNewSpeechSession)');
        
        setState(() {
          _isSpeechProcessing = true;
          _isVoiceProcessing = true; // UI ë¡œë”© ìƒíƒœ í™œì„±í™”
        });
        
        _lastProcessedText = trimmedText;
        _lastSpeechProcessTime = now;
        _lastLineDrawTime = now; // ì„  ê·¸ë¦¬ê¸° ì‹œê°„ ê¸°ë¡
        
        // ì²˜ë¦¬ëœ í…ìŠ¤íŠ¸ì™€ ìˆ«ìë¥¼ ì§‘í•©ì— ì¶”ê°€
        _processedTexts.add(trimmedText);
        if (_processedTexts.length > 10) {
          _processedTexts.clear();
          _processedTexts.add(trimmedText);
        }
        
        _recentlyProcessedNumbers.add(bestNumber);
        if (_recentlyProcessedNumbers.length > 5) {
          _recentlyProcessedNumbers.clear();
          _recentlyProcessedNumbers.add(bestNumber);
        }
        
        // 1ì´ˆ í›„ ìˆ«ì ì¤‘ë³µ ë°©ì§€ ëª©ë¡ì—ì„œ ì œê±°
        Future.delayed(const Duration(seconds: 1), () {
          _recentlyProcessedNumbers.remove(bestNumber);
        });
        
        // ì„ íƒëœ ì„ ì´ ìˆë‹¤ë©´ í•´ë‹¹ ì„ ì˜ ê¸¸ì´ë¥¼ ë³€ê²½
        if (selectedLineIndex >= 0 && selectedLineIndex < lines.length) {
          print('ë¹ ë¥¸ ì²˜ë¦¬ - ì„ íƒëœ ì„  ê¸¸ì´ ë³€ê²½: ì¸ë±ìŠ¤ $selectedLineIndex, ìƒˆ ê¸¸ì´ $bestNumber');
          _resizeSelectedLine(bestNumber);
        } else {
          print('ë¹ ë¥¸ ì²˜ë¦¬ - ìœ íš¨í•œ ìˆ«ìë¡œ ì„  ê·¸ë¦¬ê¸°');
          if (lastDirection != null) {
            print('ë¹ ë¥¸ ì²˜ë¦¬ - ë§ˆì§€ë§‰ ë°©í–¥($lastDirection)ìœ¼ë¡œ ì„  ê·¸ë¦¬ê¸°');
            drawLineWithDistance(lastDirection!, bestNumber);
          } else {
            print('ë¹ ë¥¸ ì²˜ë¦¬ - ìœ„ìª½ ë°©í–¥ìœ¼ë¡œ ì„  ê·¸ë¦¬ê¸°');
            drawLineWithDistance('Up', bestNumber);
          }
        }
        
        // ì„±ê³µ ë©”ì‹œì§€ ì œê±° (íŒì—… ì—†ì´ ì¡°ìš©íˆ ì²˜ë¦¬)
        
        // ìë™ ìŒì„± ëª¨ë“œ ì œê±° - ì‚¬ìš©ìê°€ ì§ì ‘ ìŒì„± ì¸ì‹ì„ ì œì–´í•˜ë„ë¡ ë³€ê²½
        
        // ì¦‰ì‹œ ì²˜ë¦¬ ê°€ëŠ¥í•œ ê²½ìš° ì§€ì—° ì‹œê°„ ë” ë‹¨ì¶• (200ms â†’ 100ms)
        Future.delayed(const Duration(milliseconds: 100), () {
          setState(() {
            _isSpeechProcessing = false;
            _isVoiceProcessing = false; // UI ë¡œë”© ìƒíƒœ ë¹„í™œì„±í™”
          });
        });
      }
    }
  }

  // ì¸ì‹ëœ í…ìŠ¤íŠ¸ì—ì„œ ìˆ«ì ì¶”ì¶œ ë° ì²˜ë¦¬ - ê°•í™”ëœ ì¤‘ë³µ ë°©ì§€
  void _processRecognizedText(String text) {
    print('ìŒì„± í…ìŠ¤íŠ¸ ì²˜ë¦¬: $text');
    
    // ì¤‘ë³µ ì²˜ë¦¬ ë°©ì§€ (í”Œë˜ê·¸ ê¸°ë°˜)
    if (_isSpeechProcessing) {
      print('ìŒì„± ì²˜ë¦¬ ì¤‘ - ì¤‘ë³µ í˜¸ì¶œ ë¬´ì‹œ');
      return;
    }
    
    final now = DateTime.now();
    final trimmedText = text.trim();
    
    // í…ìŠ¤íŠ¸ ê¸¸ì´ ê²€ì¦ (ê°ë„ í–¥ìƒ)
    if (trimmedText.isEmpty || trimmedText.length > 40) {
      print('í…ìŠ¤íŠ¸ ê¸¸ì´ ë¶€ì ì ˆ - ë¬´ì‹œ: ${trimmedText.length}');
      return;
    }
    
    // ì´ë¯¸ ì²˜ë¦¬ëœ í…ìŠ¤íŠ¸ì¸ì§€ í™•ì¸
    if (_processedTexts.contains(trimmedText)) {
      print('ì´ë¯¸ ì²˜ë¦¬ëœ í…ìŠ¤íŠ¸ - ë¬´ì‹œ: $trimmedText');
      return;
    }
    
    // ìµœê·¼ ì„  ê·¸ë¦¬ê¸° í›„ ë„ˆë¬´ ë¹ ë¥¸ í˜¸ì¶œ ë°©ì§€ (ì„±ëŠ¥ ìµœì í™”: 500ms â†’ 250ms)
    if (_lastLineDrawTime != null && 
        now.difference(_lastLineDrawTime!).inMilliseconds < 250) {
      print('ìµœê·¼ ì„  ê·¸ë¦¬ê¸° í›„ 250ms ì´ë‚´ - ì¼ë°˜ ì²˜ë¦¬ ë¬´ì‹œ (${now.difference(_lastLineDrawTime!).inMilliseconds}ms)');
      return;
    }
    
    // ì‹œê°„ ê°„ê²© ê¸°ë°˜ ë¶„ë¦¬ ì²˜ë¦¬ (ì„±ëŠ¥ ìµœì í™”: 800ms â†’ 400ms)
    final speechGapThreshold = 400; // ë°˜ì‘ ì†ë„ ê°œì„ ì„ ìœ„í•´ ë” ë‹¨ì¶•
    bool isNewSpeechSession = false;
    
    if (_lastSpeechProcessTime == null || 
        now.difference(_lastSpeechProcessTime!).inMilliseconds >= speechGapThreshold) {
      isNewSpeechSession = true;
      print('ìƒˆë¡œìš´ ìŒì„± ì„¸ì…˜ ì‹œì‘ (${_lastSpeechProcessTime == null ? 'ì²˜ìŒ' : '${now.difference(_lastSpeechProcessTime!).inMilliseconds}ms ê²½ê³¼'})');
      // ìƒˆ ì„¸ì…˜ ì‹œì‘ ì‹œ ì²˜ë¦¬ëœ í…ìŠ¤íŠ¸ ì§‘í•© ì´ˆê¸°í™”
      _processedTexts.clear();
    }
    
    // ìƒˆë¡œìš´ ì„¸ì…˜ì´ ì•„ë‹ˆê³  ë™ì¼í•œ í…ìŠ¤íŠ¸ë©´ ë¬´ì‹œ
    if (!isNewSpeechSession && _lastProcessedText == trimmedText) {
      print('ë™ì¼ ì„¸ì…˜ ë‚´ ë™ì¼í•œ í…ìŠ¤íŠ¸ ì¤‘ë³µ ì²˜ë¦¬ ë°©ì§€: $trimmedText');
      return;
    }
    
    // ìƒˆë¡œìš´ ì„¸ì…˜ì´ ì•„ë‹ˆê³  ë„ˆë¬´ ë¹ ë¥¸ í˜¸ì¶œì´ë©´ ë¬´ì‹œ (ì„±ëŠ¥ ìµœì í™”: 500ms â†’ 250ms)
    if (!isNewSpeechSession && _lastSpeechProcessTime != null && 
        now.difference(_lastSpeechProcessTime!).inMilliseconds < 250) {
      print('ë™ì¼ ì„¸ì…˜ ë‚´ ìŒì„± ì²˜ë¦¬ 250ms ì´ë‚´ ì¤‘ë³µ í˜¸ì¶œ ë¬´ì‹œ (${now.difference(_lastSpeechProcessTime!).inMilliseconds}ms)');
      return;
    }
    
    setState(() {
      _isSpeechProcessing = true;
      _isVoiceProcessing = true; // UI ë¡œë”© ìƒíƒœ í™œì„±í™”
    });
    
    _lastSpeechProcessTime = now;
    _lastProcessedText = trimmedText;
    _lastLineDrawTime = now; // ì„  ê·¸ë¦¬ê¸° ì‹œê°„ ê¸°ë¡
    
    // ì²˜ë¦¬ëœ í…ìŠ¤íŠ¸ë¥¼ ì§‘í•©ì— ì¶”ê°€ (ë©”ëª¨ë¦¬ ìµœì í™”: ìµœëŒ€ 10ê°œê¹Œì§€ë§Œ ìœ ì§€)
    _processedTexts.add(trimmedText);
    if (_processedTexts.length > 10) {
      _processedTexts.clear();
      _processedTexts.add(trimmedText);
    }
    
    // ë¨¼ì € ìŒì„± ëª…ë ¹ í™•ì¸
    final lowerText = trimmedText.toLowerCase();
    
    // ë°©í–¥ê³¼ ìˆ«ìê°€ í•¨ê»˜ ìˆëŠ”ì§€ í™•ì¸ (ì˜ˆ: "ì˜¤ë¥¸ìª½ 200", "ìœ„ë¡œ 300")
    String? detectedDirection;
    String remainingText = lowerText;
    
    // ë°©í–¥ íŒ¨í„´ ê²€ì‚¬
    if (lowerText.contains('ìœ„') || lowerText.contains('ìœ„ë¡œ') || lowerText.contains('ìœ„ìª½')) {
      detectedDirection = 'Up';
      remainingText = lowerText.replaceAll('ìœ„ìª½', '').replaceAll('ìœ„ë¡œ', '').replaceAll('ìœ„', '').trim();
    } else if (lowerText.contains('ì•„ë˜') || lowerText.contains('ì•„ë˜ë¡œ') || lowerText.contains('ì•„ë˜ìª½')) {
      detectedDirection = 'Down';
      remainingText = lowerText.replaceAll('ì•„ë˜ìª½', '').replaceAll('ì•„ë˜ë¡œ', '').replaceAll('ì•„ë˜', '').trim();
    } else if (lowerText.contains('ì™¼ìª½') || lowerText.contains('ì¢Œ')) {
      detectedDirection = 'Left';
      remainingText = lowerText.replaceAll('ì™¼ìª½ìœ¼ë¡œ', '').replaceAll('ì™¼ìª½', '').replaceAll('ì¢Œ', '').trim();
    } else if (lowerText.contains('ì˜¤ë¥¸ìª½') || lowerText.contains('ìš°')) {
      detectedDirection = 'Right';
      remainingText = lowerText.replaceAll('ì˜¤ë¥¸ìª½ìœ¼ë¡œ', '').replaceAll('ì˜¤ë¥¸ìª½', '').replaceAll('ìš°', '').trim();
    }
    
    // ë°©í–¥ê³¼ í•¨ê»˜ ìˆ«ìê°€ ìˆëŠ”ì§€ í™•ì¸
    if (detectedDirection != null && remainingText.isNotEmpty) {
      // ë‚¨ì€ í…ìŠ¤íŠ¸ì—ì„œ ìˆ«ìë¥¼ ì°¾ì•„ë³´ê¸°
      final processedRemainingText = _convertKoreanNumbersToDigits(remainingText);
      final numberRegex = RegExp(r'\b(\d+(?:\.\d+)?)\b');
      final matches = numberRegex.allMatches(processedRemainingText);
      
      if (matches.isNotEmpty) {
        // ìˆ«ìê°€ ìˆìœ¼ë©´ ë°©í–¥ ì„¤ì • í›„ ìˆ«ì ì²˜ë¦¬
        print('ë°©í–¥ê³¼ ìˆ«ì ë™ì‹œ ì¸ì‹: ë°©í–¥=$detectedDirection, í…ìŠ¤íŠ¸=$remainingText');
        
        // ë°©í–¥ ì„¤ì •
        onDirectionKey(detectedDirection);
        
        // ì ì‹œ í›„ ìˆ«ì ì²˜ë¦¬ë¥¼ ìœ„í•´ í…ìŠ¤íŠ¸ ì¬ì²˜ë¦¬
        Future.delayed(const Duration(milliseconds: 100), () {
          // ìˆ«ìë§Œ í¬í•¨ëœ í…ìŠ¤íŠ¸ë¡œ ë‹¤ì‹œ ì²˜ë¦¬
          _processRecognizedText(remainingText);
        });
        
        setState(() {
          _isSpeechProcessing = false;
          _isVoiceProcessing = false;
        });
        
        return;
      }
    }
    
    // ì°½ë¬¸ ëª…ë ¹
    if (lowerText.contains('ì°½ë¬¸')) {
      print('ìŒì„± ëª…ë ¹: ì°½ë¬¸');
      setState(() {
        // ì°½ë¬¸ ëª¨ë“œ í† ê¸€
        final newOpeningType = pendingOpeningType == 'window' ? null : 'window';
        pendingOpeningType = newOpeningType;
        print('ì°½ë¬¸ ëª¨ë“œ ${newOpeningType != null ? 'í™œì„±í™”' : 'ë¹„í™œì„±í™”'}');
        
        _isSpeechProcessing = false;
        _isVoiceProcessing = false;
      });
      
      // ì²˜ë¦¬ ì™„ë£Œ í›„ í”Œë˜ê·¸ ë¦¬ì…‹
      Future.delayed(const Duration(milliseconds: 150), () {
        setState(() {
          _isSpeechProcessing = false;
          _isVoiceProcessing = false;
        });
      });
      return;
    }
    
    // ì ì—°ê²°/ëŒ€ê°ì„  ëª…ë ¹
    if (lowerText.contains('ì ì—°ê²°') || lowerText.contains('ëŒ€ê°ì„ ')) {
      print('ìŒì„± ëª…ë ¹: ì ì—°ê²°/ëŒ€ê°ì„ ');
      setState(() {
        // ì ì—°ê²° ëª¨ë“œ í† ê¸€
        diagonalMode = !diagonalMode;
        print('ì ì—°ê²° ëª¨ë“œ ${diagonalMode ? 'í™œì„±í™”' : 'ë¹„í™œì„±í™”'}');
        
        _isSpeechProcessing = false;
        _isVoiceProcessing = false;
      });
      
      // ì²˜ë¦¬ ì™„ë£Œ í›„ í”Œë˜ê·¸ ë¦¬ì…‹
      Future.delayed(const Duration(milliseconds: 150), () {
        setState(() {
          _isSpeechProcessing = false;
          _isVoiceProcessing = false;
        });
      });
      return;
    }
    
    // ì·¨ì†Œ/ë’¤ë¡œ ëª…ë ¹
    if (lowerText.contains('ì·¨ì†Œ') || lowerText.contains('ë’¤ë¡œ')) {
      print('ìŒì„± ëª…ë ¹: ì·¨ì†Œ/ë’¤ë¡œ');
      
      // ë˜ëŒë¦¬ê¸° ì‹¤í–‰
      undo();
      
      setState(() {
        _isSpeechProcessing = false;
        _isVoiceProcessing = false;
      });
      
      // ì²˜ë¦¬ ì™„ë£Œ í›„ í”Œë˜ê·¸ ë¦¬ì…‹
      Future.delayed(const Duration(milliseconds: 150), () {
        setState(() {
          _isSpeechProcessing = false;
          _isVoiceProcessing = false;
        });
      });
      return;
    }
    
    // ì› ëª…ë ¹
    if (lowerText == 'ì›' || lowerText.contains('ì› ëª¨ë“œ')) {
      print('ìŒì„± ëª…ë ¹: ì›');
      setState(() {
        // ì› ëª¨ë“œ í† ê¸€
        circleMode = !circleMode;
        if (circleMode) {
          // ì› ëª¨ë“œ í™œì„±í™” ì‹œ ë‹¤ë¥¸ ëª¨ë“œ ë¹„í™œì„±í™”
          diagonalMode = false;
          selectedLineIndex = -1;
          selectedCircleIndex = -1;
          selectedEndpoint = null;
          selectedEndpointLineIndex = null;
          selectedEndpointType = null;
          selectedGroupLines.clear();
        }
        print('ì› ëª¨ë“œ ${circleMode ? 'í™œì„±í™”' : 'ë¹„í™œì„±í™”'}');
        
        _isSpeechProcessing = false;
        _isVoiceProcessing = false;
      });
      
      // ì²˜ë¦¬ ì™„ë£Œ í›„ í”Œë˜ê·¸ ë¦¬ì…‹
      Future.delayed(const Duration(milliseconds: 150), () {
        setState(() {
          _isSpeechProcessing = false;
          _isVoiceProcessing = false;
        });
      });
      return;
    }
    
    // ë°©í–¥í‚¤ ëª…ë ¹
    if (lowerText == 'ìœ„' || lowerText == 'ìœ„ë¡œ' || lowerText.contains('ìœ„ìª½')) {
      print('ìŒì„± ëª…ë ¹: ìœ„');
      onDirectionKey('Up');
      
      setState(() {
        _isSpeechProcessing = false;
        _isVoiceProcessing = false;
      });
      
      Future.delayed(const Duration(milliseconds: 150), () {
        setState(() {
          _isSpeechProcessing = false;
          _isVoiceProcessing = false;
        });
      });
      return;
    }
    
    if (lowerText == 'ì•„ë˜' || lowerText == 'ì•„ë˜ë¡œ' || lowerText.contains('ì•„ë˜ìª½')) {
      print('ìŒì„± ëª…ë ¹: ì•„ë˜');
      onDirectionKey('Down');
      
      setState(() {
        _isSpeechProcessing = false;
        _isVoiceProcessing = false;
      });
      
      Future.delayed(const Duration(milliseconds: 150), () {
        setState(() {
          _isSpeechProcessing = false;
          _isVoiceProcessing = false;
        });
      });
      return;
    }
    
    if (lowerText == 'ì™¼ìª½' || lowerText == 'ì¢Œ' || lowerText.contains('ì™¼ìª½ìœ¼ë¡œ')) {
      print('ìŒì„± ëª…ë ¹: ì™¼ìª½');
      onDirectionKey('Left');
      
      setState(() {
        _isSpeechProcessing = false;
        _isVoiceProcessing = false;
      });
      
      Future.delayed(const Duration(milliseconds: 150), () {
        setState(() {
          _isSpeechProcessing = false;
          _isVoiceProcessing = false;
        });
      });
      return;
    }
    
    if (lowerText == 'ì˜¤ë¥¸ìª½' || lowerText == 'ìš°' || lowerText.contains('ì˜¤ë¥¸ìª½ìœ¼ë¡œ')) {
      print('ìŒì„± ëª…ë ¹: ì˜¤ë¥¸ìª½');
      onDirectionKey('Right');
      
      setState(() {
        _isSpeechProcessing = false;
        _isVoiceProcessing = false;
      });
      
      Future.delayed(const Duration(milliseconds: 150), () {
        setState(() {
          _isSpeechProcessing = false;
          _isVoiceProcessing = false;
        });
      });
      return;
    }
    
    // ì´ˆê¸°í™” ëª…ë ¹
    if (lowerText.contains('ì´ˆê¸°í™”') || lowerText.contains('ë‹¤ì‹œ') || lowerText.contains('ë¦¬ì…‹')) {
      print('ìŒì„± ëª…ë ¹: ì´ˆê¸°í™”');
      
      // ì´ˆê¸°í™” ì‹¤í–‰
      setState(() {
        lines.clear();
        circles.clear();
        currentPoint = const Offset(0, 0);
        selectedLineIndex = -1;
        selectedCircleIndex = -1;
        selectedEndpoint = null;
        selectedEndpointLineIndex = null;
        selectedEndpointType = null;
        diagonalMode = false;
        circleMode = false;
        pendingOpeningType = null;
        selectedGroupLines.clear();
        _lastProcessedNumber = null;
        arrowDirection = null;
        inlineDirection = "";
        showInlineInput = false;
        inlineController.clear();
      });
      
      // Firebase ì—…ë°ì´íŠ¸
      _updateFirebase();
      
      setState(() {
        _isSpeechProcessing = false;
        _isVoiceProcessing = false;
      });
      
      // ì²˜ë¦¬ ì™„ë£Œ í›„ í”Œë˜ê·¸ ë¦¬ì…‹
      Future.delayed(const Duration(milliseconds: 150), () {
        setState(() {
          _isSpeechProcessing = false;
          _isVoiceProcessing = false;
        });
      });
      return;
    }
    
    // í•œêµ­ì–´ ìˆ«ì ë‹¨ì–´ë¥¼ ìˆ«ìë¡œ ë³€í™˜
    final processedText = _convertKoreanNumbersToDigits(trimmedText);
    print('ë³€í™˜ëœ í…ìŠ¤íŠ¸: $processedText');
    
    // ìˆ«ì ì¶”ì¶œ (ê°œì„ ëœ ë²„ì „ - ë” ì •í™•í•œ íŒ¨í„´)
    final numberRegex = RegExp(r'\b(\d+(?:\.\d+)?)\b');
    final matches = numberRegex.allMatches(processedText);
    
    if (matches.isNotEmpty) {
      // ìœ íš¨í•œ ìˆ«ìë§Œ ì„ íƒ (1-10000 ë²”ìœ„)
      double? bestNumber;
      for (final match in matches) {
        final numberStr = match.group(1);
        final number = double.tryParse(numberStr ?? '');
        if (number != null && number >= 1 && number <= 10000) {
          // ê°€ì¥ ì ì ˆí•œ ìˆ«ì ì„ íƒ (10-500 ë²”ìœ„ ìš°ì„ , ê·¸ ë‹¤ìŒ 1-10000)
          if (bestNumber == null) {
            bestNumber = number;
          } else if (number >= 10 && number <= 500 && (bestNumber < 10 || bestNumber > 500)) {
            bestNumber = number;
          } else if (number >= 10 && number <= 500 && bestNumber >= 10 && bestNumber <= 500) {
            bestNumber = number > bestNumber ? number : bestNumber;
          }
        }
      }
      
      if (bestNumber != null) {
        // ìµœê·¼ì— ì²˜ë¦¬ëœ ìˆ«ìì¸ì§€ í™•ì¸
        if (_recentlyProcessedNumbers.contains(bestNumber)) {
          print('ìµœê·¼ ì²˜ë¦¬ëœ ìˆ«ì ì¤‘ë³µ ë°©ì§€: $bestNumber');
          setState(() {
            _isSpeechProcessing = false;
            _isVoiceProcessing = false;
          });
          return;
        }
        
        // ë§ˆì§€ë§‰ ì²˜ë¦¬ëœ ìˆ«ìê°€ í˜„ì¬ ìˆ«ìì— í¬í•¨ë˜ëŠ”ì§€ í™•ì¸ (ì˜ˆ: 1000 < 1300)
        if (_lastProcessedNumber != null && 
            DateTime.now().difference(_lastSpeechProcessTime ?? DateTime.now()).inMilliseconds < 1000) {
          // ì²œ(1000) -> ì²œì‚¼ë°±(1300)ì²˜ëŸ¼ ì‘ì€ ìˆ«ìê°€ í° ìˆ«ìì— í¬í•¨ë˜ëŠ” ê²½ìš°
          if (bestNumber > _lastProcessedNumber! && 
              _lastProcessedNumber == 1000 && bestNumber >= 1000 && bestNumber < 2000) {
            print('ì²œ ë‹¨ìœ„ í¬í•¨ ê´€ê³„ ê°ì§€ - ì´ì „: $_lastProcessedNumber, í˜„ì¬: $bestNumber');
            // ì´ì „ ì„ ì„ ì‚­ì œí•˜ê³  ìƒˆë¡œìš´ ì„ ìœ¼ë¡œ ëŒ€ì²´
            if (lines.isNotEmpty) {
              setState(() {
                lines.removeLast();
              });
            }
          }
          // ë°±(100) -> ë°±XXì²˜ëŸ¼ ì‘ì€ ìˆ«ìê°€ í° ìˆ«ìì— í¬í•¨ë˜ëŠ” ê²½ìš°
          else if (bestNumber > _lastProcessedNumber! && 
                   _lastProcessedNumber == 100 && bestNumber >= 100 && bestNumber < 200) {
            print('ë°± ë‹¨ìœ„ í¬í•¨ ê´€ê³„ ê°ì§€ - ì´ì „: $_lastProcessedNumber, í˜„ì¬: $bestNumber');
            if (lines.isNotEmpty) {
              setState(() {
                lines.removeLast();
              });
            }
          }
        }
        
        print('ì¶”ì¶œëœ ìˆ«ì: $bestNumber');
        
        // ì²˜ë¦¬ëœ ìˆ«ì ì¶”ê°€
        _recentlyProcessedNumbers.add(bestNumber);
        if (_recentlyProcessedNumbers.length > 5) {
          _recentlyProcessedNumbers.clear();
          _recentlyProcessedNumbers.add(bestNumber);
        }
        
        // 1ì´ˆ í›„ ìˆ«ì ì¤‘ë³µ ë°©ì§€ ëª©ë¡ì—ì„œ ì œê±°
        Future.delayed(const Duration(seconds: 1), () {
          _recentlyProcessedNumbers.remove(bestNumber);
        });
        
        // ë§ˆì§€ë§‰ ì²˜ë¦¬ëœ ìˆ«ì ì—…ë°ì´íŠ¸
        _lastProcessedNumber = bestNumber;
        
        // ì„ íƒëœ ì„ ì´ ìˆë‹¤ë©´ í•´ë‹¹ ì„ ì˜ ê¸¸ì´ë¥¼ ë³€ê²½
        if (selectedLineIndex >= 0 && selectedLineIndex < lines.length) {
          print('ì„ íƒëœ ì„  ê¸¸ì´ ë³€ê²½: ì¸ë±ìŠ¤ $selectedLineIndex, ìƒˆ ê¸¸ì´ $bestNumber');
          _resizeSelectedLine(bestNumber);
        }
        // í˜„ì¬ ì¸ë¼ì¸ ì…ë ¥ì´ í™œì„±í™”ë˜ì–´ ìˆë‹¤ë©´ í•´ë‹¹ ì…ë ¥ í•„ë“œì— ìˆ«ì ì…ë ¥
        else if (showInlineInput) {
          print('ì¸ë¼ì¸ ì…ë ¥ í™œì„±í™” ìƒíƒœ - ìˆ«ì ì…ë ¥ ë° ì„  ê·¸ë¦¬ê¸°');
          setState(() {
            inlineController.text = bestNumber.toString();
            inlineController.selection = TextSelection.fromPosition(
              TextPosition(offset: inlineController.text.length),
            );
          });
          
          // ìë™ìœ¼ë¡œ ì„  ê·¸ë¦¬ê¸° ì‹¤í–‰
          WidgetsBinding.instance.addPostFrameCallback((_) {
            confirmInlineInput();
          });
        } else {
          // ì¸ë¼ì¸ ì…ë ¥ì´ ë¹„í™œì„±í™”ë˜ì–´ ìˆë‹¤ë©´ ìë™ìœ¼ë¡œ ë§ˆì§€ë§‰ ë°©í–¥ìœ¼ë¡œ ì„  ê·¸ë¦¬ê¸°
          print('ì¸ë¼ì¸ ì…ë ¥ ë¹„í™œì„±í™” ìƒíƒœ - ìë™ìœ¼ë¡œ ë§ˆì§€ë§‰ ë°©í–¥ìœ¼ë¡œ ì„  ê·¸ë¦¬ê¸°');
          
          // ë§ˆì§€ë§‰ ë°©í–¥ì´ ìˆë‹¤ë©´ í•´ë‹¹ ë°©í–¥ìœ¼ë¡œ ì„  ê·¸ë¦¬ê¸°
          if (lastDirection != null) {
            print('ë§ˆì§€ë§‰ ë°©í–¥: $lastDirection ìœ¼ë¡œ $bestNumber í”½ì…€ ì„  ê·¸ë¦¬ê¸°');
            
            // ë§ˆì§€ë§‰ ë°©í–¥ìœ¼ë¡œ ì„  ê·¸ë¦¬ê¸°
            drawLineWithDistance(lastDirection!, bestNumber);
            
            // ì„±ê³µ ë©”ì‹œì§€ ì œê±° (íŒì—… ì—†ì´ ì¡°ìš©íˆ ì²˜ë¦¬)
          } else {
            // ë§ˆì§€ë§‰ ë°©í–¥ì´ ì—†ë‹¤ë©´ ìœ„ìª½ìœ¼ë¡œ ê¸°ë³¸ ì„¤ì •
            print('ë§ˆì§€ë§‰ ë°©í–¥ì´ ì—†ìŒ - ìœ„ìª½ìœ¼ë¡œ ê¸°ë³¸ ì„¤ì •í•˜ì—¬ ì„  ê·¸ë¦¬ê¸°');
            drawLineWithDistance('Up', bestNumber);
            
            // ì„±ê³µ ë©”ì‹œì§€ ì œê±° (íŒì—… ì—†ì´ ì¡°ìš©íˆ ì²˜ë¦¬)
          }
        }
      }
    } else {
      print('í…ìŠ¤íŠ¸ì—ì„œ ìœ íš¨í•œ ìˆ«ìë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ');
      // ì—ëŸ¬ ë©”ì‹œì§€ëŠ” ë„ˆë¬´ ìì£¼ ë‚˜ì˜¤ì§€ ì•Šë„ë¡ ì œí•œ
      if (_speechProcessCount % 3 == 0) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('1-10000 ì‚¬ì´ì˜ ìˆ«ìë¥¼ ëª…í™•íˆ ë§í•´ì£¼ì„¸ìš”.'),
            duration: Duration(seconds: 2),
            backgroundColor: Color(0xFFCE9178),
          ),
        );
      }
    }
    
    _speechProcessCount++;
    
    // ìë™ ìŒì„± ëª¨ë“œ ì œê±° - ì‚¬ìš©ìê°€ ì§ì ‘ ìŒì„± ì¸ì‹ì„ ì œì–´í•˜ë„ë¡ ë³€ê²½
    
    // ì²˜ë¦¬ ì™„ë£Œ í›„ í”Œë˜ê·¸ ë¦¬ì…‹ (ì„±ëŠ¥ ìµœì í™”: 300ms â†’ 150ms)
    Future.delayed(const Duration(milliseconds: 150), () {
      setState(() {
        _isSpeechProcessing = false;
        _isVoiceProcessing = false; // UI ë¡œë”© ìƒíƒœ ë¹„í™œì„±í™”
      });
      print('ìŒì„± ì²˜ë¦¬ ì™„ë£Œ - í”Œë˜ê·¸ ë¦¬ì…‹');
    });
  }

  // í•œêµ­ì–´ ìˆ«ì ë‹¨ì–´ë¥¼ ìˆ«ìë¡œ ë³€í™˜ (ê°œì„ ëœ ë²„ì „)
  String _convertKoreanNumbersToDigits(String text) {
    print('ì›ë³¸ í…ìŠ¤íŠ¸: $text');
    
    // í…ìŠ¤íŠ¸ë¥¼ ì†Œë¬¸ìë¡œ ë³€í™˜í•˜ê³  ë¶ˆí•„ìš”í•œ ë¬¸ì ì œê±°
    String processedText = text.toLowerCase()
        .replaceAll(RegExp(r'[^\wê°€-í£]'), '') // íŠ¹ìˆ˜ë¬¸ì ì œê±°
        .replaceAll(' ', '');
    
    // ìŒì„± ì¸ì‹ ì˜¤ë¥˜ íŒ¨í„´ ìˆ˜ì • (ì˜ˆ: "1003ë°±" -> "ì²œì‚¼ë°±")
    processedText = processedText.replaceAllMapped(RegExp(r'(\d+)([ë°±ì²œë§Œ])'), (match) {
      final number = match.group(1)!;
      final unit = match.group(2)!;
      
      // 1003ë°± -> ì²œì‚¼ë°±
      if (number == '1003' && unit == 'ë°±') return 'ì²œì‚¼ë°±';
      if (number == '1004' && unit == 'ë°±') return 'ì²œì‚¬ë°±';
      if (number == '1005' && unit == 'ë°±') return 'ì²œì˜¤ë°±';
      if (number == '1006' && unit == 'ë°±') return 'ì²œìœ¡ë°±';
      if (number == '1007' && unit == 'ë°±') return 'ì²œì¹ ë°±';
      if (number == '1008' && unit == 'ë°±') return 'ì²œíŒ”ë°±';
      if (number == '1009' && unit == 'ë°±') return 'ì²œêµ¬ë°±';
      
      return match.group(0)!;
    });
    
    print('ì „ì²˜ë¦¬ëœ í…ìŠ¤íŠ¸: $processedText');
    
    // ë³µí•© ìˆ«ì ë¨¼ì € ì²˜ë¦¬ (ê¸´ ë‹¨ì–´ë¶€í„° - ìˆœì„œ ì¤‘ìš”)
    final complexNumbers = {
      // 1000 ì´ìƒ (ì²œ ë‹¨ìœ„ ì¶”ê°€)
      'êµ¬ì²œêµ¬ë°±êµ¬ì‹­êµ¬': '9999', 'êµ¬ì²œêµ¬ë°±êµ¬ì‹­': '9990', 'êµ¬ì²œêµ¬ë°±': '9900',
      'êµ¬ì²œíŒ”ë°±êµ¬ì‹­': '9890', 'êµ¬ì²œíŒ”ë°±': '9800', 'êµ¬ì²œì¹ ë°±': '9700',
      'êµ¬ì²œìœ¡ë°±': '9600', 'êµ¬ì²œì˜¤ë°±': '9500', 'êµ¬ì²œì‚¬ë°±': '9400',
      'êµ¬ì²œì‚¼ë°±': '9300', 'êµ¬ì²œì´ë°±': '9200', 'êµ¬ì²œì¼ë°±': '9100', 'êµ¬ì²œ': '9000',
      
      'íŒ”ì²œêµ¬ë°±êµ¬ì‹­êµ¬': '8999', 'íŒ”ì²œêµ¬ë°±êµ¬ì‹­': '8990', 'íŒ”ì²œêµ¬ë°±': '8900',
      'íŒ”ì²œíŒ”ë°±': '8800', 'íŒ”ì²œì¹ ë°±': '8700', 'íŒ”ì²œìœ¡ë°±': '8600',
      'íŒ”ì²œì˜¤ë°±': '8500', 'íŒ”ì²œì‚¬ë°±': '8400', 'íŒ”ì²œì‚¼ë°±': '8300',
      'íŒ”ì²œì´ë°±': '8200', 'íŒ”ì²œì¼ë°±': '8100', 'íŒ”ì²œ': '8000',
      
      'ì¹ ì²œêµ¬ë°±': '7900', 'ì¹ ì²œíŒ”ë°±': '7800', 'ì¹ ì²œì¹ ë°±': '7700',
      'ì¹ ì²œìœ¡ë°±': '7600', 'ì¹ ì²œì˜¤ë°±': '7500', 'ì¹ ì²œì‚¬ë°±': '7400',
      'ì¹ ì²œì‚¼ë°±': '7300', 'ì¹ ì²œì´ë°±': '7200', 'ì¹ ì²œì¼ë°±': '7100', 'ì¹ ì²œ': '7000',
      
      'ìœ¡ì²œêµ¬ë°±': '6900', 'ìœ¡ì²œíŒ”ë°±': '6800', 'ìœ¡ì²œì¹ ë°±': '6700',
      'ìœ¡ì²œìœ¡ë°±': '6600', 'ìœ¡ì²œì˜¤ë°±': '6500', 'ìœ¡ì²œì‚¬ë°±': '6400',
      'ìœ¡ì²œì‚¼ë°±': '6300', 'ìœ¡ì²œì´ë°±': '6200', 'ìœ¡ì²œì¼ë°±': '6100', 'ìœ¡ì²œ': '6000',
      
      'ì˜¤ì²œêµ¬ë°±': '5900', 'ì˜¤ì²œíŒ”ë°±': '5800', 'ì˜¤ì²œì¹ ë°±': '5700',
      'ì˜¤ì²œìœ¡ë°±': '5600', 'ì˜¤ì²œì˜¤ë°±': '5500', 'ì˜¤ì²œì‚¬ë°±': '5400',
      'ì˜¤ì²œì‚¼ë°±': '5300', 'ì˜¤ì²œì´ë°±': '5200', 'ì˜¤ì²œì¼ë°±': '5100', 'ì˜¤ì²œ': '5000',
      
      'ì‚¬ì²œêµ¬ë°±': '4900', 'ì‚¬ì²œíŒ”ë°±': '4800', 'ì‚¬ì²œì¹ ë°±': '4700',
      'ì‚¬ì²œìœ¡ë°±': '4600', 'ì‚¬ì²œì˜¤ë°±': '4500', 'ì‚¬ì²œì‚¬ë°±': '4400',
      'ì‚¬ì²œì‚¼ë°±': '4300', 'ì‚¬ì²œì´ë°±': '4200', 'ì‚¬ì²œì¼ë°±': '4100', 'ì‚¬ì²œ': '4000',
      
      'ì‚¼ì²œêµ¬ë°±': '3900', 'ì‚¼ì²œíŒ”ë°±': '3800', 'ì‚¼ì²œì¹ ë°±': '3700',
      'ì‚¼ì²œìœ¡ë°±': '3600', 'ì‚¼ì²œì˜¤ë°±': '3500', 'ì‚¼ì²œì‚¬ë°±': '3400',
      'ì‚¼ì²œì‚¼ë°±': '3300', 'ì‚¼ì²œì´ë°±': '3200', 'ì‚¼ì²œì¼ë°±': '3100', 'ì‚¼ì²œ': '3000',
      
      'ì´ì²œêµ¬ë°±': '2900', 'ì´ì²œíŒ”ë°±': '2800', 'ì´ì²œì¹ ë°±': '2700',
      'ì´ì²œìœ¡ë°±': '2600', 'ì´ì²œì˜¤ë°±': '2500', 'ì´ì²œì‚¬ë°±': '2400',
      'ì´ì²œì‚¼ë°±': '2300', 'ì´ì²œì´ë°±': '2200', 'ì´ì²œì¼ë°±': '2100', 'ì´ì²œ': '2000',
      
      'ì¼ì²œêµ¬ë°±êµ¬ì‹­êµ¬': '1999', 'ì¼ì²œêµ¬ë°±êµ¬ì‹­': '1990', 'ì¼ì²œêµ¬ë°±': '1900',
      'ì¼ì²œíŒ”ë°±êµ¬ì‹­': '1890', 'ì¼ì²œíŒ”ë°±': '1800', 'ì¼ì²œì¹ ë°±': '1700',
      'ì¼ì²œìœ¡ë°±': '1600', 'ì¼ì²œì˜¤ë°±': '1500', 'ì¼ì²œì‚¬ë°±': '1400',
      'ì¼ì²œì‚¼ë°±': '1300', 'ì¼ì²œì´ë°±': '1200', 'ì¼ì²œì¼ë°±': '1100', 'ì¼ì²œ': '1000',
      
      // ì²œ ë‹¨ìœ„ (ê°„ë‹¨í•œ í˜•íƒœ)
      'ì²œêµ¬ë°±êµ¬ì‹­êµ¬': '1999', 'ì²œêµ¬ë°±êµ¬ì‹­': '1990', 'ì²œêµ¬ë°±': '1900',
      'ì²œíŒ”ë°±êµ¬ì‹­': '1890', 'ì²œíŒ”ë°±': '1800', 'ì²œì¹ ë°±': '1700',
      'ì²œìœ¡ë°±': '1600', 'ì²œì˜¤ë°±': '1500', 'ì²œì‚¬ë°±': '1400',
      'ì²œì‚¼ë°±': '1300', 'ì²œì´ë°±': '1200', 'ì²œì¼ë°±': '1100', 'ì²œ': '1000',
      
      // 100 ì´ìƒ (ê¸°ì¡´)
      'êµ¬ë°±êµ¬ì‹­êµ¬': '999', 'êµ¬ë°±êµ¬ì‹­': '990', 'êµ¬ë°±': '900',
      'íŒ”ë°±êµ¬ì‹­': '890', 'íŒ”ë°±': '800',
      'ì¹ ë°±êµ¬ì‹­': '790', 'ì¹ ë°±': '700',
      'ìœ¡ë°±êµ¬ì‹­': '690', 'ìœ¡ë°±': '600',
      'ì˜¤ë°±êµ¬ì‹­': '590', 'ì˜¤ë°±': '500',
      'ì‚¬ë°±êµ¬ì‹­': '490', 'ì‚¬ë°±': '400',
      'ì‚¼ë°±êµ¬ì‹­': '390', 'ì‚¼ë°±': '300',
      'ì´ë°±êµ¬ì‹­': '290', 'ì´ë°±': '200',
      'ì¼ë°±êµ¬ì‹­': '190', 'ì¼ë°±': '100',
      'ë°±êµ¬ì‹­': '190', 'ë°±': '100',
      
      // 90-99
      'ì•„í”ì•„í™‰': '99', 'ì•„í”ì—¬ëŸ': '98', 'ì•„í”ì¼ê³±': '97', 'ì•„í”ì—¬ì„¯': '96',
      'ì•„í”ë‹¤ì„¯': '95', 'ì•„í”ë„·': '94', 'ì•„í”ì…‹': '93', 'ì•„í”ë‘˜': '92',
      'ì•„í”í•˜ë‚˜': '91', 'ì•„í”': '90',
      
      // 80-89
      'ì—¬ë“ ì•„í™‰': '89', 'ì—¬ë“ ì—¬ëŸ': '88', 'ì—¬ë“ ì¼ê³±': '87', 'ì—¬ë“ ì—¬ì„¯': '86',
      'ì—¬ë“ ë‹¤ì„¯': '85', 'ì—¬ë“ ë„·': '84', 'ì—¬ë“ ì…‹': '83', 'ì—¬ë“ ë‘˜': '82',
      'ì—¬ë“ í•˜ë‚˜': '81', 'ì—¬ë“ ': '80',
      
      // 70-79
      'ì¼í”ì•„í™‰': '79', 'ì¼í”ì—¬ëŸ': '78', 'ì¼í”ì¼ê³±': '77', 'ì¼í”ì—¬ì„¯': '76',
      'ì¼í”ë‹¤ì„¯': '75', 'ì¼í”ë„·': '74', 'ì¼í”ì…‹': '73', 'ì¼í”ë‘˜': '72',
      'ì¼í”í•˜ë‚˜': '71', 'ì¼í”': '70',
      
      // 60-69
      'ì˜ˆìˆœì•„í™‰': '69', 'ì˜ˆìˆœì—¬ëŸ': '68', 'ì˜ˆìˆœì¼ê³±': '67', 'ì˜ˆìˆœì—¬ì„¯': '66',
      'ì˜ˆìˆœë‹¤ì„¯': '65', 'ì˜ˆìˆœë„·': '64', 'ì˜ˆìˆœì…‹': '63', 'ì˜ˆìˆœë‘˜': '62',
      'ì˜ˆìˆœí•˜ë‚˜': '61', 'ì˜ˆìˆœ': '60',
      
      // 50-59
      'ì‰°ì•„í™‰': '59', 'ì‰°ì—¬ëŸ': '58', 'ì‰°ì¼ê³±': '57', 'ì‰°ì—¬ì„¯': '56',
      'ì‰°ë‹¤ì„¯': '55', 'ì‰°ë„·': '54', 'ì‰°ì…‹': '53', 'ì‰°ë‘˜': '52',
      'ì‰°í•˜ë‚˜': '51', 'ì‰°': '50',
      
      // 40-49
      'ë§ˆí”ì•„í™‰': '49', 'ë§ˆí”ì—¬ëŸ': '48', 'ë§ˆí”ì¼ê³±': '47', 'ë§ˆí”ì—¬ì„¯': '46',
      'ë§ˆí”ë‹¤ì„¯': '45', 'ë§ˆí”ë„·': '44', 'ë§ˆí”ì…‹': '43', 'ë§ˆí”ë‘˜': '42',
      'ë§ˆí”í•˜ë‚˜': '41', 'ë§ˆí”': '40',
      
      // 30-39
      'ì„œë¥¸ì•„í™‰': '39', 'ì„œë¥¸ì—¬ëŸ': '38', 'ì„œë¥¸ì¼ê³±': '37', 'ì„œë¥¸ì—¬ì„¯': '36',
      'ì„œë¥¸ë‹¤ì„¯': '35', 'ì„œë¥¸ë„·': '34', 'ì„œë¥¸ì…‹': '33', 'ì„œë¥¸ë‘˜': '32',
      'ì„œë¥¸í•˜ë‚˜': '31', 'ì„œë¥¸': '30',
      
      // 20-29
      'ìŠ¤ë¬´ì•„í™‰': '29', 'ìŠ¤ë¬´ì—¬ëŸ': '28', 'ìŠ¤ë¬´ì¼ê³±': '27', 'ìŠ¤ë¬´ì—¬ì„¯': '26',
      'ìŠ¤ë¬´ë‹¤ì„¯': '25', 'ìŠ¤ë¬´ë„·': '24', 'ìŠ¤ë¬´ì…‹': '23', 'ìŠ¤ë¬´ë‘˜': '22',
      'ìŠ¤ë¬´í•˜ë‚˜': '21', 'ìŠ¤ë¬´': '20',
      
      // 10-19 (í•œìì–´)
      'ì‹­êµ¬': '19', 'ì‹­íŒ”': '18', 'ì‹­ì¹ ': '17', 'ì‹­ìœ¡': '16', 'ì‹­ì˜¤': '15',
      'ì‹­ì‚¬': '14', 'ì‹­ì‚¼': '13', 'ì‹­ì´': '12', 'ì‹­ì¼': '11', 'ì‹­': '10',
      
      // ê¸°íƒ€ ë‹¨ìœ„
      'ì—´': '10',
    };
    
    // ë³µí•© ìˆ«ì ë³€í™˜ (ê¸´ ê²ƒë¶€í„°)
    final sortedComplexNumbers = complexNumbers.entries.toList()
      ..sort((a, b) => b.key.length.compareTo(a.key.length));
    
    for (final entry in sortedComplexNumbers) {
      processedText = processedText.replaceAll(entry.key, entry.value);
    }
    
    // ê¸°ë³¸ ìˆ«ì ë³€í™˜
    final basicNumbers = {
      // í•œêµ­ì–´ ìˆ«ì (ê³ ìœ ì–´)
      'ì•„í™‰': '9', 'ì—¬ëŸ': '8', 'ì¼ê³±': '7', 'ì—¬ì„¯': '6', 'ë‹¤ì„¯': '5',
      'ë„·': '4', 'ì…‹': '3', 'ë‘˜': '2', 'í•˜ë‚˜': '1', 'ì˜': '0',
      
      // í•œêµ­ì–´ ìˆ«ì (í•œìì–´)
      'êµ¬': '9', 'íŒ”': '8', 'ì¹ ': '7', 'ìœ¡': '6', 'ì˜¤': '5',
      'ì‚¬': '4', 'ì‚¼': '3', 'ì´': '2', 'ì¼': '1', 'ê³µ': '0',
      
      // ìì£¼ ì˜ëª» ì¸ì‹ë˜ëŠ” ë³€í˜•ë“¤
      'ë‚˜ì¸': '9', 'ì—ì´íŠ¸': '8', 'ì„¸ë¸': '7', 'ì‹ìŠ¤': '6', 'íŒŒì´ë¸Œ': '5',
      'í¬': '4', 'ì“°ë¦¬': '3', 'íˆ¬': '2', 'ì›': '1', 'ì œë¡œ': '0',
      
      // ë°œìŒ ë³€í˜•
      'êµ¬ìš°': '9', 'íŒ”íŒ”': '8', 'ì¹ ì¹ ': '7', 'ìœ¡ìœ¡': '6', 'ì˜¤ì˜¤': '5',
      'ë„¤': '4', 'ì„¸': '3', 'ë‘': '2', 'í•œ': '1', 'ë¹µ': '0',
    };
    
    // ê¸°ë³¸ ìˆ«ì ë³€í™˜
    basicNumbers.forEach((korean, digit) {
      processedText = processedText.replaceAll(korean, digit);
    });
    
    // ì˜ëª» ì¸ì‹ë  ìˆ˜ ìˆëŠ” ë‹¨ì–´ë“¤ ì²˜ë¦¬ (ë” ì •í™•í•˜ê²Œ)
    final corrections = {
      // ìŒì„± ì¸ì‹ ì˜¤ë¥˜ ë³´ì •
      'ì‰¬': '6', 'ì¹˜': '7', 'íŒŒ': '8', 'ê°€': '9',
      'ì‹œ': '10', 'ì”¨': '3', 'í”¼': '5', 'í‹°': '2',
      'ì§€': '2', 'ë¹„': '3', 'ë””': '2', 'í‚¤': '7',
      'ë¦¬': '2', 'ë¯¸': '3', 'ë‹ˆ': '2', 'íˆ': '7',
    };
    
    corrections.forEach((wrong, correct) {
      // ë‹¨ì–´ ê²½ê³„ì—ì„œë§Œ ë³€í™˜ (ë¶€ë¶„ ë¬¸ìì—´ ì˜¤ë³€í™˜ ë°©ì§€)
      processedText = processedText.replaceAll(RegExp(r'\b' + wrong + r'\b'), correct);
    });
    
    print('ìµœì¢… ë³€í™˜ëœ í…ìŠ¤íŠ¸: $processedText');
    return processedText;
  }

  @override
  void dispose() {
    _dropdownOverlay?.remove();
    _linesSubscription?.cancel();
    _circlesSubscription?.cancel();
    _currentPointSubscription?.cancel();
    _metadataSubscription?.cancel();
    _focusNode.dispose();
    inlineController.dispose();
    inlineFocus.dispose();
    super.dispose();
  }

  void saveState() {
    linesHistory.add({
      'lines': lines.map((line) => line.copy()).toList(),
      'circles': circles.map((circle) => circle.copy()).toList(),
      'currentPoint': currentPoint,
    });
    
    if (linesHistory.length > 20) {
      linesHistory.removeAt(0);
    }
  }

  void undo() {
    if (linesHistory.isEmpty) return;
    
    final lastState = linesHistory.removeLast();
    setState(() {
      lines = (lastState['lines'] as List<Line>).map((line) => line.copy()).toList();
      circles = (lastState['circles'] as List<Circle>).map((circle) => circle.copy()).toList();
      currentPoint = lastState['currentPoint'] as Offset;
    });
    _updateFirebase();
  }

  void reset() {
    if (lines.isEmpty && circles.isEmpty && viewScale == 0.3 && viewOffset == const Offset(500, 500)) return;
    
    // í™•ì¸ íŒì—… í‘œì‹œ
    showDialog(
      context: context,
      builder: (BuildContext context) {
        return AlertDialog(
          backgroundColor: const Color(0xFF161B22),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(12),
            side: const BorderSide(color: Color(0xFF30363D)),
          ),
          title: const Text(
            'ì´ˆê¸°í™” í™•ì¸',
            style: TextStyle(
              color: Color(0xFFE6EDF3),
              fontSize: 18,
              fontWeight: FontWeight.w600,
            ),
          ),
          content: const Text(
            'ëª¨ë“  ê·¸ë¦¼ì„ ì‚­ì œí•˜ê³  ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ?\nì´ ì‘ì—…ì€ ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.',
            style: TextStyle(
              color: Color(0xFFE6EDF3),
              fontSize: 14,
            ),
          ),
          actions: [
            TextButton(
              onPressed: () {
                Navigator.of(context).pop(); // íŒì—… ë‹«ê¸°
              },
              child: const Text(
                'ì·¨ì†Œ',
                style: TextStyle(
                  color: Color(0xFF9CDCFE),
                  fontSize: 14,
                  fontWeight: FontWeight.w500,
                ),
              ),
            ),
            ElevatedButton(
              onPressed: () {
                Navigator.of(context).pop(); // íŒì—… ë‹«ê¸°
                // ì‹¤ì œ ì´ˆê¸°í™” ì‹¤í–‰
                _performReset();
              },
              style: ElevatedButton.styleFrom(
                backgroundColor: const Color(0xFFCE9178),
                foregroundColor: Colors.white,
                elevation: 0,
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(6),
                ),
              ),
              child: const Text(
                'ì´ˆê¸°í™”',
                style: TextStyle(
                  fontSize: 14,
                  fontWeight: FontWeight.w600,
                ),
              ),
            ),
          ],
        );
      },
    );
  }

  void _performReset() {
    saveState();
    setState(() {
      lines.clear();
      circles.clear();
      currentPoint = const Offset(0, 0);
      selectedLineIndex = -1;
      selectedCircleIndex = -1;
      circleMode = false;
      circleCenter = null;
      viewScale = 0.3;
      viewOffset = const Offset(500, 500);
      viewRotation = 0.0;
    });
    _updateFirebase();
    
    // ì´ˆê¸°í™” í›„ ë·° ë§ì¶¤ ìë™ ì‹¤í–‰
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (isMobile || isTablet) {
        print('ëª¨ë°”ì¼/íƒœë¸”ë¦¿ ì´ˆê¸°í™” í›„ - currentPoint ì¤‘ì‹¬ ë§ì¶¤');
        centerCurrentPoint();
      } else {
        fitViewToDrawing();
      }
    });
  }

  void onDirectionKey(String direction) {
    // ì´ë¯¸ ì²˜ë¦¬ ì¤‘ì´ë©´ ë¬´ì‹œ
    if (isProcessingInput) {
      print('onDirectionKey: ì´ë¯¸ ì²˜ë¦¬ ì¤‘ - ë¬´ì‹œ');
      return;
    }
    
    print('onDirectionKey í˜¸ì¶œë¨: $direction');
    print('í˜„ì¬ ìƒíƒœ - showInlineInput: $showInlineInput, inlineController.text: "${inlineController.text}"');
    print('í˜„ì¬ ìƒíƒœ - lines.length: ${lines.length}, currentPoint: $currentPoint');
    print('í˜„ì¬ ìƒíƒœ - selectedLineIndex: $selectedLineIndex, selectedCircleIndex: $selectedCircleIndex');
    print('í˜„ì¬ ìƒíƒœ - arrowDirection: $arrowDirection, isDoubleDirectionPressed: $isDoubleDirectionPressed');
    
    // ë°©í–¥í‚¤ ë‘ ë²ˆ ëˆ„ë¦„ ê°ì§€
    bool wasDoublePressed = false;
    if (arrowDirection == direction && !isDoubleDirectionPressed) {
      wasDoublePressed = true;
      print('ë°©í–¥í‚¤ ë‘ ë²ˆ ëˆ„ë¦„ ê°ì§€: $direction');
    }
    
    // ì„ íƒëœ ì„ ì´ë‚˜ ì›ì´ ìˆì„ ë•Œì˜ ì²˜ë¦¬
    if (selectedLineIndex >= 0 || selectedCircleIndex >= 0) {
      if (selectedCircleIndex >= 0) {
        print('ì„ íƒëœ ì›ì´ ìˆìŒ - ì› ì´ë™ì„ ìœ„í•œ ë°©í–¥í‚¤ ì„¤ì •');
        // ì›ì´ ì„ íƒëœ ê²½ìš° ì„ íƒ ì·¨ì†Œí•˜ì§€ ì•Šê³  ë°©í–¥í‚¤ë§Œ ì„¤ì •
      } else {
        print('ì„ íƒëœ ì„ ì´ ìˆìŒ - ì„ íƒ ì·¨ì†Œí•˜ê³  ë°©í–¥í‚¤ ì„¤ì •');
        // ì„ ì´ ì„ íƒëœ ê²½ìš° ì„ íƒ ì·¨ì†Œ
      }
    }
    
    // ìë™ ìŒì„± ëª¨ë“œ ì œê±° - í™”ì‚´í‘œ ë²„íŠ¼ ëˆ„ë¥¼ ë•Œë§ˆë‹¤ ìŒì„± ì¸ì‹ ì‹œì‘í•˜ì§€ ì•ŠìŒ
    // ì„±ëŠ¥ í–¥ìƒì„ ìœ„í•´ ì‚¬ìš©ìê°€ ëª…ì‹œì ìœ¼ë¡œ ìŒì„± ë²„íŠ¼ì„ ëˆ„ë¥¼ ë•Œë§Œ ìŒì„± ì¸ì‹ ì‹œì‘
    
    setState(() {
      // ì„ íƒëœ ì„ /ì›ì´ ìˆì„ ë•Œì˜ ì²˜ë¦¬
      if (selectedLineIndex >= 0 || selectedCircleIndex >= 0) {
        if (selectedCircleIndex >= 0) {
          // ì›ì´ ì„ íƒëœ ê²½ìš° ì„ íƒ ìƒíƒœ ìœ ì§€í•˜ê³  ë°©í–¥í‚¤ë§Œ ì„¤ì •
          print('ì› ì„ íƒ ìƒíƒœ ìœ ì§€í•˜ê³  ë°©í–¥í‚¤ ì„¤ì •');
        } else {
          // ì„ ì´ ì„ íƒëœ ê²½ìš° ì„ íƒ ì·¨ì†Œ (íŒŒë€ì„  ê·¸ë£¹ ì„ íƒì€ ìœ ì§€)
          selectedLineIndex = -1;
          selectedCircleIndex = -1;
          print('ì„  ì„ íƒ ì·¨ì†Œ ì™„ë£Œ - ê·¸ë£¹ ì„ íƒ ìƒíƒœ: ${selectedGroupLines.length}ê°œ');
        }
      }
      
      // ë°©í–¥í‚¤ ë‘ ë²ˆ ëˆ„ë¦„ ìƒíƒœ ì—…ë°ì´íŠ¸
      if (wasDoublePressed) {
        isDoubleDirectionPressed = true;
        print('ë°©í–¥í‚¤ ë‘ ë²ˆ ëˆ„ë¦„ ìƒíƒœ í™œì„±í™”');
      } else if (arrowDirection != direction) {
        isDoubleDirectionPressed = false;
        print('ë‹¤ë¥¸ ë°©í–¥í‚¤ ëˆ„ë¦„ - ë‘ ë²ˆ ëˆ„ë¦„ ìƒíƒœ í•´ì œ');
      }
      
      arrowDirection = direction;
      inlineDirection = direction;
      lastDirection = direction; // ë°©í–¥í‚¤ í´ë¦­ ì‹œ ë§ˆì§€ë§‰ ë°©í–¥ ì„¤ì •
      
      print('ë°©í–¥í‚¤ ì„¤ì • í›„ - selectedGroupLines: $selectedGroupLines');
      
      // ì´ë¯¸ ì¸ë¼ì¸ ì…ë ¥ì´ í‘œì‹œ ì¤‘ì´ê³  í…ìŠ¤íŠ¸ê°€ ìˆë‹¤ë©´ ë°”ë¡œ ì‹¤í–‰
      if (showInlineInput && inlineController.text.isNotEmpty) {
        print('ì¸ë¼ì¸ ì…ë ¥ì´ ìˆìŒ - ì¦‰ì‹œ ì‹¤í–‰');
        // ì¦‰ì‹œ ì„  ê·¸ë¦¬ê¸° ì‹¤í–‰
        WidgetsBinding.instance.addPostFrameCallback((_) {
          confirmInlineInput();
        });
      } else {
        print('ë°©í–¥í‚¤ ì„¤ì • ì™„ë£Œ - í™”ì‚´í‘œ í‘œì‹œ ë° ìˆ«ì ì…ë ¥ ëŒ€ê¸° ì¤‘');
        // ë°©í–¥í‚¤ë§Œ ì„¤ì •í•˜ê³  ìˆ«ìì…ë ¥ì°½ì€ í‘œì‹œí•˜ì§€ ì•ŠìŒ
        // ìˆ«ìë¥¼ ì…ë ¥í•  ë•Œ ìˆ«ìì…ë ¥ì°½ì´ ë‚˜íƒ€ë‚˜ë„ë¡ í•¨
        showInlineInput = false;
        isProcessingInput = false;
      }
    });
    
    // ë°©í–¥í‚¤ ë²„íŠ¼ í´ë¦­ í›„ í¬ì»¤ìŠ¤ ë³µì›
    WidgetsBinding.instance.addPostFrameCallback((_) {
      print('ë©”ì¸ í¬ì»¤ìŠ¤ ë³µì›');
      _focusNode.requestFocus();
    });
  }

  void drawLineWithDistance(String direction, double distance) {
    print('drawLineWithDistance í˜¸ì¶œë¨ - ë°©í–¥: $direction, ê±°ë¦¬: $distance');
    print('drawLineWithDistance - isProcessingInput: $isProcessingInput');
    
    // ì´ë¯¸ confirmInlineInputì—ì„œ isProcessingInputì´ trueë¡œ ì„¤ì •ë˜ì—ˆìœ¼ë¯€ë¡œ
    // ì—¬ê¸°ì„œëŠ” ì¶”ê°€ë¡œ ì„¤ì •í•˜ì§€ ì•ŠìŒ
    if (!isProcessingInput) {
      print('ì²˜ë¦¬ ì¤‘ ìƒíƒœê°€ ì•„ë‹˜ - ì˜ˆìƒì¹˜ ëª»í•œ í˜¸ì¶œ');
      isProcessingInput = true;
    }
    
    // í™”ë©´ íšŒì „ì„ ê³ ë ¤í•œ ë°©í–¥ ë³€í™˜
    String transformedDirection = _transformDirectionForRotation(direction);
    print('í™”ë©´ íšŒì „ ê³ ë ¤ - ì›ë˜ ë°©í–¥: $direction, ë³€í™˜ëœ ë°©í–¥: $transformedDirection');
    
    Offset newPoint;
    switch (transformedDirection) {
      case 'Up':
        newPoint = Offset(currentPoint.dx, currentPoint.dy + distance);
        break;
      case 'Down':
        newPoint = Offset(currentPoint.dx, currentPoint.dy - distance);
        break;
      case 'Left':
        newPoint = Offset(currentPoint.dx - distance, currentPoint.dy);
        break;
      case 'Right':
        newPoint = Offset(currentPoint.dx + distance, currentPoint.dy);
        break;
      default:
        print('ì˜ëª»ëœ ë°©í–¥: $transformedDirection');
        isProcessingInput = false;
        return;
    }

    print('ìƒˆë¡œìš´ ì  ê³„ì‚°ë¨: $newPoint (ì‹œì‘ì : $currentPoint)');
    
    saveState();
    
    setState(() {
      lines.add(Line(
        start: currentPoint,
        end: newPoint,
        openingType: pendingOpeningType,
      ));
      currentPoint = newPoint;
      pendingOpeningType = null;
      lastDirection = direction; // ë§ˆì§€ë§‰ ë°©í–¥ ì €ì¥
      isProcessingInput = false;
      
      // ì„  ê·¸ë¦¬ê¸° í›„ ì„ íƒëœ ëì  í•´ì œ
      selectedEndpoint = null;
      selectedEndpointLineIndex = null;
      selectedEndpointType = null;
    });
    
    print('ì„  ì¶”ê°€ë¨ - ì´ ì„  ê°œìˆ˜: ${lines.length}');
    
    _updateFirebase();
    
    // ëª¨ë°”ì¼/íƒœë¸”ë¦¿ì—ì„œëŠ” ìƒˆ ì„ ì´ í™”ë©´ì— ë³´ì´ë„ë¡ ë·° ì¡°ì •
    if (isMobile || isTablet) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        Future.delayed(const Duration(milliseconds: 100), () {
          if (mounted) {
            // currentPointê°€ í™”ë©´ì— ë³´ì´ëŠ”ì§€ í™•ì¸í•˜ê³  í•„ìš”ì‹œ ì¡°ì •
            final currentScreen = _modelToScreen(currentPoint);
            final screenSize = MediaQuery.of(context).size;
            
            // í™”ë©´ ê²½ê³„ì—ì„œ 50px ì—¬ë°±
            const margin = 50.0;
            final needsAdjustment = currentScreen.dx < margin || 
                                   currentScreen.dx > screenSize.width - margin ||
                                   currentScreen.dy < margin || 
                                   currentScreen.dy > screenSize.height - 200 - margin;
            
            if (needsAdjustment) {
              print('ëª¨ë°”ì¼/íƒœë¸”ë¦¿: currentPointê°€ í™”ë©´ ë°– - ë·° ì¡°ì •');
              centerCurrentPoint();
            }
          }
        });
      });
    }
  }

  void moveCurrentPointWithDistance(String direction, double distance) {
    print('moveCurrentPointWithDistance í˜¸ì¶œë¨ - ë°©í–¥: $direction, ê±°ë¦¬: $distance');
    print('moveCurrentPointWithDistance - isProcessingInput: $isProcessingInput');
    
    // ì´ë¯¸ confirmInlineInputì—ì„œ isProcessingInputì´ trueë¡œ ì„¤ì •ë˜ì—ˆìœ¼ë¯€ë¡œ
    // ì—¬ê¸°ì„œëŠ” ì¶”ê°€ë¡œ ì„¤ì •í•˜ì§€ ì•ŠìŒ
    if (!isProcessingInput) {
      print('ì²˜ë¦¬ ì¤‘ ìƒíƒœê°€ ì•„ë‹˜ - ì˜ˆìƒì¹˜ ëª»í•œ í˜¸ì¶œ');
      isProcessingInput = true;
    }
    
    // í™”ë©´ íšŒì „ì„ ê³ ë ¤í•œ ë°©í–¥ ë³€í™˜
    String transformedDirection = _transformDirectionForRotation(direction);
    print('í™”ë©´ íšŒì „ ê³ ë ¤ - ì›ë˜ ë°©í–¥: $direction, ë³€í™˜ëœ ë°©í–¥: $transformedDirection');
    
    Offset newPoint;
    switch (transformedDirection) {
      case 'Up':
        newPoint = Offset(currentPoint.dx, currentPoint.dy + distance);
        break;
      case 'Down':
        newPoint = Offset(currentPoint.dx, currentPoint.dy - distance);
        break;
      case 'Left':
        newPoint = Offset(currentPoint.dx - distance, currentPoint.dy);
        break;
      case 'Right':
        newPoint = Offset(currentPoint.dx + distance, currentPoint.dy);
        break;
      default:
        print('ì˜ëª»ëœ ë°©í–¥: $transformedDirection');
        isProcessingInput = false;
        return;
    }

    print('ì  ì´ë™: $currentPoint -> $newPoint');
    
    saveState();
    
    setState(() {
      // ë°©í–¥í‚¤ ë‘ ë²ˆ ëˆ„ë¥¸ ìƒíƒœì—ì„œëŠ” ì„ ì„ ìˆ˜ì •í•˜ì§€ ì•Šê³  currentPointë§Œ ì´ë™
      currentPoint = newPoint;
      
      // ì„ íƒëœ ëì  í•´ì œ (ìƒˆë¡œìš´ ìœ„ì¹˜ë¡œ ì´ë™í–ˆìœ¼ë¯€ë¡œ)
      selectedEndpoint = null;
      selectedEndpointLineIndex = null;
      selectedEndpointType = null;
      
      lastDirection = direction; // ë§ˆì§€ë§‰ ë°©í–¥ ì €ì¥
      isProcessingInput = false;
      isDoubleDirectionPressed = false; // ì  ì´ë™ í›„ ë‘ ë²ˆ ëˆ„ë¦„ ìƒíƒœ í•´ì œ
    });
    
    print('ì  ì´ë™ ì™„ë£Œ - ìƒˆ ìœ„ì¹˜: $currentPoint');
    
    _updateFirebase();
    
    // ëª¨ë°”ì¼/íƒœë¸”ë¦¿ì—ì„œëŠ” ìƒˆ ì ì´ í™”ë©´ì— ë³´ì´ë„ë¡ ë·° ì¡°ì •
    if (isMobile || isTablet) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        Future.delayed(const Duration(milliseconds: 100), () {
          if (mounted) {
            // currentPointê°€ í™”ë©´ì— ë³´ì´ëŠ”ì§€ í™•ì¸í•˜ê³  í•„ìš”ì‹œ ì¡°ì •
            final currentScreen = _modelToScreen(currentPoint);
            final screenSize = MediaQuery.of(context).size;
            
            // í™”ë©´ ê²½ê³„ì—ì„œ 50px ì—¬ë°±
            const margin = 50.0;
            final needsAdjustment = currentScreen.dx < margin || 
                                   currentScreen.dx > screenSize.width - margin ||
                                   currentScreen.dy < margin || 
                                   currentScreen.dy > screenSize.height - 200 - margin;
            
            if (needsAdjustment) {
              print('ëª¨ë°”ì¼/íƒœë¸”ë¦¿: currentPointê°€ í™”ë©´ ë°– - ë·° ì¡°ì •');
              centerCurrentPoint();
            }
          }
        });
      });
    }
  }

  void confirmInlineInput() {
    print('confirmInlineInput í˜¸ì¶œë¨ - isProcessingInput: $isProcessingInput');
    
    if (isProcessingInput) {
      print('ì´ë¯¸ ì²˜ë¦¬ ì¤‘ - ì¤‘ë³µ í˜¸ì¶œ ë°©ì§€ë¡œ ì¢…ë£Œ');
      return;
    }
    
    // ì¦‰ì‹œ ì²˜ë¦¬ ì¤‘ ìƒíƒœë¡œ ì„¤ì •í•˜ì—¬ ì¤‘ë³µ í˜¸ì¶œ ë°©ì§€
    isProcessingInput = true;
    
    String inputText = inlineController.text.trim();
    print('ì…ë ¥ëœ í…ìŠ¤íŠ¸: "$inputText"');
    
    if (inputText.isEmpty) {
      print('ì…ë ¥ í…ìŠ¤íŠ¸ê°€ ë¹„ì–´ìˆìŒ');
      setState(() {
        showInlineInput = false;
        isProcessingInput = false;
        arrowDirection = null;
      });
      WidgetsBinding.instance.addPostFrameCallback((_) {
        _focusNode.requestFocus();
      });
      return;
    }
    
    // ê°„ë‹¨í•œ ìˆ˜ì‹ ê³„ì‚° ì²˜ë¦¬
    double? distance;
    if (inputText.contains('+')) {
      final parts = inputText.split('+');
      if (parts.length == 2) {
        final num1 = double.tryParse(parts[0].trim());
        final num2 = double.tryParse(parts[1].trim());
        if (num1 != null && num2 != null) {
          distance = num1 + num2;
        }
      }
    } else if (inputText.contains('-') && inputText.lastIndexOf('-') > 0) {
      final lastIndex = inputText.lastIndexOf('-');
      final num1 = double.tryParse(inputText.substring(0, lastIndex).trim());
      final num2 = double.tryParse(inputText.substring(lastIndex + 1).trim());
      if (num1 != null && num2 != null) {
        distance = num1 - num2;
      }
    } else {
      distance = double.tryParse(inputText);
    }
    
    print('ê³„ì‚°ëœ ê±°ë¦¬: $distance');
    
    if (distance == null || distance < 0) {
      print('ì˜ëª»ëœ ê±°ë¦¬ê°’: $inputText');
      setState(() {
        showInlineInput = false;
        isProcessingInput = false;
        arrowDirection = null;
      });
      WidgetsBinding.instance.addPostFrameCallback((_) {
        _focusNode.requestFocus();
      });
      return;
    }
    
    print('í˜„ì¬ ìƒíƒœ - selectedLineIndex: $selectedLineIndex, arrowDirection: $arrowDirection');
    print('inlineDirection: "$inlineDirection"');
    print('ì› ëª¨ë“œ ìƒíƒœ - circleMode: $circleMode, circleCenter: $circleCenter');
    
    // ì› ëª¨ë“œì—ì„œ ì§€ë¦„ ì…ë ¥
    if (circleMode && circleCenter != null) {
      print('âœ… ì› ìƒì„± ëª¨ë“œ ì§„ì…: ì¤‘ì‹¬ì  $circleCenter, ì§€ë¦„ $distance');
      
      // ì› ìƒì„± ì „ ìœ íš¨ì„± ê²€ì‚¬
      if (distance <= 0) {
        print('ì› ìƒì„± ì˜¤ë¥˜: ì§€ë¦„ì´ 0 ì´í•˜ì…ë‹ˆë‹¤ ($distance)');
        setState(() {
          showInlineInput = false;
          isProcessingInput = false;
          circleMode = false;
          circleCenter = null;
          arrowDirection = null;
        });
        print('ì› ìƒì„± ì‹¤íŒ¨ - circleMode í•´ì œ (ì§€ë¦„ ì˜¤ë¥˜)');
        WidgetsBinding.instance.addPostFrameCallback((_) {
          _focusNode.requestFocus();
        });
        return;
      }
      
      final radius = distance / 2; // ì§€ë¦„ì„ ë°˜ì§€ë¦„ìœ¼ë¡œ ë³€í™˜
      
      // ë°˜ì§€ë¦„ ìœ íš¨ì„± ê²€ì‚¬
      if (radius <= 0 || radius.isNaN || radius.isInfinite) {
        print('ì› ìƒì„± ì˜¤ë¥˜: ë°˜ì§€ë¦„ì´ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤ ($radius)');
        setState(() {
          showInlineInput = false;
          isProcessingInput = false;
          circleMode = false;
          circleCenter = null;
          arrowDirection = null;
        });
        print('ì› ìƒì„± ì‹¤íŒ¨ - circleMode í•´ì œ (ë°˜ì§€ë¦„ ì˜¤ë¥˜)');
        WidgetsBinding.instance.addPostFrameCallback((_) {
          _focusNode.requestFocus();
        });
        return;
      }
      
      saveState();
      
      try {
        circles.add(Circle(
          center: circleCenter!,
          radius: radius,
        ));
        print('ì› ìƒì„± ì„±ê³µ: ì¤‘ì‹¬ì  $circleCenter, ë°˜ì§€ë¦„ $radius');
        
        // ìƒì„±ëœ ì›ì„ ì„ íƒ ìƒíƒœë¡œ ì„¤ì •
        final newCircleIndex = circles.length - 1;
        
        setState(() {
          showInlineInput = false;
          isProcessingInput = false;
          circleMode = false;
          circleCenter = null;
          arrowDirection = null;
          inlineDirection = "";
          // ìƒˆë¡œ ìƒì„±ëœ ì›ì„ ì„ íƒ ìƒíƒœë¡œ ì„¤ì •
          selectedCircleIndex = newCircleIndex;
          selectedLineIndex = -1; // ì„  ì„ íƒ í•´ì œ
        });
        
        print('ì› ìƒì„± ì™„ë£Œ - circleMode í•´ì œ');
        _updateFirebase();
        
      } catch (e) {
        print('ì› ìƒì„± ì¤‘ ì˜¤ë¥˜ ë°œìƒ: $e');
        setState(() {
          showInlineInput = false;
          isProcessingInput = false;
          circleMode = false;
          circleCenter = null;
          arrowDirection = null;
          isDoubleDirectionPressed = false;
        });
        print('ì› ìƒì„± ì‹¤íŒ¨ - circleMode í•´ì œ');
      }
      
      WidgetsBinding.instance.addPostFrameCallback((_) {
        _focusNode.requestFocus();
      });
      return;
    }
    
    // íŒŒë€ì„  ê·¸ë£¹ ì´ë™ ì²˜ë¦¬ (selectedGroupLinesê°€ ìˆì„ ë•Œ)
    if (selectedGroupLines.isNotEmpty && arrowDirection != null) {
      print('íŒŒë€ì„  ê·¸ë£¹ ì´ë™ ëª¨ë“œ - ì„ íƒëœ ì„ : ${selectedGroupLines.length}ê°œ, ë°©í–¥: $arrowDirection, ê±°ë¦¬: $distance');
      saveState();
      
      // í™”ë©´ íšŒì „ì„ ê³ ë ¤í•œ ë°©í–¥ ë³€í™˜
      String transformedDirection = _transformDirectionForRotation(arrowDirection!);
      
      // ì´ë™ ì˜¤í”„ì…‹ ê³„ì‚°
      Offset moveOffset;
      switch (transformedDirection) {
        case 'Up':
          moveOffset = Offset(0, distance);  // ìœ„ë¡œ ì´ë™ = Y ì¦ê°€
          break;
        case 'Down':
          moveOffset = Offset(0, -distance); // ì•„ë˜ë¡œ ì´ë™ = Y ê°ì†Œ
          break;
        case 'Left':
          moveOffset = Offset(-distance, 0);
          break;
        case 'Right':
          moveOffset = Offset(distance, 0);
          break;
        default:
          print('ì˜ëª»ëœ ë°©í–¥: $transformedDirection');
          setState(() {
            showInlineInput = false;
            isProcessingInput = false;
            arrowDirection = null;
          });
          WidgetsBinding.instance.addPostFrameCallback((_) {
            _focusNode.requestFocus();
          });
          return;
      }
      
      setState(() {
        // ì„ íƒëœ ëª¨ë“  ì„ ë“¤ì„ ì´ë™
        for (int lineIndex in selectedGroupLines) {
          if (lineIndex >= 0 && lineIndex < lines.length) {
            lines[lineIndex].start = lines[lineIndex].start + moveOffset;
            lines[lineIndex].end = lines[lineIndex].end + moveOffset;
          }
        }
        
        showInlineInput = false;
        isProcessingInput = false;
        arrowDirection = null;
        inlineDirection = "";
        inlineController.clear();
      });
      
      _updateFirebase();
      WidgetsBinding.instance.addPostFrameCallback((_) {
        _focusNode.requestFocus();
      });
      return;
    }
    
    // ì› ì´ë™ ëª¨ë“œ (ì„ íƒëœ ì›ì´ ìˆê³  ë°©í–¥í‚¤ê°€ ì„¤ì •ëœ ê²½ìš°)
    if (selectedCircleIndex >= 0 && arrowDirection != null) {
      print('ì› ì´ë™ ëª¨ë“œ: ì› ì¸ë±ìŠ¤ $selectedCircleIndex, ë°©í–¥ $arrowDirection, ê±°ë¦¬ $distance');
      
      if (selectedCircleIndex >= 0 && selectedCircleIndex < circles.length) {
        saveState();
        
        final circle = circles[selectedCircleIndex];
        Offset newCenter;
        
        switch (arrowDirection) {
          case 'Up':
            newCenter = Offset(circle.center.dx, circle.center.dy + distance);
            break;
          case 'Down':
            newCenter = Offset(circle.center.dx, circle.center.dy - distance);
            break;
          case 'Left':
            newCenter = Offset(circle.center.dx - distance, circle.center.dy);
            break;
          case 'Right':
            newCenter = Offset(circle.center.dx + distance, circle.center.dy);
            break;
          default:
            print('ì˜ëª»ëœ ë°©í–¥: $arrowDirection');
            setState(() {
              showInlineInput = false;
              isProcessingInput = false;
              arrowDirection = null;
              isDoubleDirectionPressed = false;
            });
            WidgetsBinding.instance.addPostFrameCallback((_) {
              _focusNode.requestFocus();
            });
            return;
        }
        
        setState(() {
          circles[selectedCircleIndex] = Circle(
            center: newCenter,
            radius: circle.radius,
          );
          showInlineInput = false;
          isProcessingInput = false;
          arrowDirection = null;
          inlineDirection = "";
          isDoubleDirectionPressed = false;
          // ì› ì„ íƒ ìƒíƒœ ìœ ì§€
        });
        
        print('ì› ì´ë™ ì™„ë£Œ: ìƒˆ ì¤‘ì‹¬ì  $newCenter');
        _updateFirebase();
        
        WidgetsBinding.instance.addPostFrameCallback((_) {
          _focusNode.requestFocus();
        });
        return;
      }
    }

    if (selectedLineIndex >= 0 && arrowDirection == null) {
      print('ì„  ê¸¸ì´ ìˆ˜ì • ëª¨ë“œ: $selectedLineIndex to length $distance');
      saveState();
      modifyLineLength(selectedLineIndex, distance);
      setState(() {
        showInlineInput = false;
        isProcessingInput = false;
        arrowDirection = null;
        isDoubleDirectionPressed = false;
        selectedLineIndex = -1; // ìˆ˜ì • í›„ ì„ íƒ í•´ì œ
      });
      
      WidgetsBinding.instance.addPostFrameCallback((_) {
        _focusNode.requestFocus();
      });
      return;
    }
    
    // ë°©í–¥í‚¤ ë‘ ë²ˆ ëˆ„ë¦„ ìƒíƒœì—ì„œëŠ” ì  ì´ë™, ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ ì„  ê·¸ë¦¬ê¸°
    String direction = inlineDirection.isNotEmpty ? inlineDirection : (arrowDirection ?? 'Right');
    
    if (isDoubleDirectionPressed) {
      print('ì  ì´ë™ ì‹œì‘ - ë°©í–¥: $direction, ê±°ë¦¬: $distance');
      print('í˜„ì¬ ì : $currentPoint');
      
      // ì  ì´ë™ í•¨ìˆ˜ í˜¸ì¶œ
      moveCurrentPointWithDistance(direction, distance);
    } else {
      print('ì„  ê·¸ë¦¬ê¸° ì‹œì‘ - ë°©í–¥: $direction, ê±°ë¦¬: $distance');
      print('í˜„ì¬ ì : $currentPoint');
      
      // ì„  ê·¸ë¦¬ê¸° í•¨ìˆ˜ í˜¸ì¶œ
      drawLineWithDistance(direction, distance);
    }
    
    setState(() {
      showInlineInput = false;
      arrowDirection = null;
      inlineDirection = "";
      // ë‘ ë²ˆ ëˆ„ë¦„ ìƒíƒœëŠ” moveCurrentPointWithDistance í•¨ìˆ˜ ë‚´ë¶€ì—ì„œ ì´ˆê¸°í™”ë¨
    });
    
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _focusNode.requestFocus();
    });
  }

  void cancelInlineInput() {
    setState(() {
      showInlineInput = false;
      arrowDirection = null;
      inlineDirection = "";
      isProcessingInput = false;
      isDoubleDirectionPressed = false;
      inlineController.clear();
    });
    
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _focusNode.requestFocus();
    });
  }

  void onNumberPadKey(String key) {
    if (!showInlineInput && key != 'Del' && key != 'Ent') {
      
      // ì¸ë¼ì¸ ì…ë ¥ ëª¨ë“œë¡œ ì „í™˜
      setState(() {
        showInlineInput = true;
        inlineController.text = '';
        
        // ì› ëª¨ë“œì—ì„œ ì¤‘ì‹¬ì ì´ ì„¤ì •ë˜ì–´ ìˆìœ¼ë©´ ì§€ë¦„ ì…ë ¥ ëª¨ë“œ
        if (circleMode && circleCenter != null) {
          print('ì› ëª¨ë“œ - ì§€ë¦„ ì…ë ¥ ëª¨ë“œë¡œ ì „í™˜');
          arrowDirection = null;
          inlineDirection = "";
        } else if (selectedCircleIndex >= 0) {
          // ì„ íƒëœ ì›ì´ ìˆìœ¼ë©´ ì› ì´ë™ ëª¨ë“œ
          // ë°©í–¥í‚¤ ì„¤ì •ì€ ê·¸ëŒ€ë¡œ ìœ ì§€ (ì› ì´ë™ì„ ìœ„í•´)
          print('ì› ì„ íƒë¨ - ì› ì´ë™ ëª¨ë“œ: ë°©í–¥í‚¤ ìœ ì§€');
        } else if (selectedLineIndex >= 0) {
          // ì„ íƒëœ ì„ ì´ ìˆìœ¼ë©´ ê¸¸ì´ ìˆ˜ì • ëª¨ë“œ
          // ë°©í–¥í‚¤ ì„¤ì •ì€ ê·¸ëŒ€ë¡œ ìœ ì§€
        } else if (arrowDirection != null || inlineDirection.isNotEmpty) {
          // ë°©í–¥í‚¤ê°€ ì„¤ì •ë˜ì–´ ìˆìœ¼ë©´ í•´ë‹¹ ë°©í–¥ìœ¼ë¡œ ìƒˆ ì„  ê·¸ë¦¬ê¸° ëª¨ë“œ
          print('ë°©í–¥í‚¤ ì„¤ì •ë¨ - ìƒˆ ì„  ê·¸ë¦¬ê¸° ëª¨ë“œ: $arrowDirection / $inlineDirection');
        } else if (lines.isNotEmpty && !circleMode) {
          // ì› ëª¨ë“œê°€ ì•„ë‹ˆê³ , ë°©í–¥í‚¤ê°€ ì—†ê³  ì„ ì´ ì¡´ì¬í•˜ë©´ ë§ˆì§€ë§‰ ì„  ìˆ˜ì • ëª¨ë“œ
          selectedLineIndex = lines.length - 1; // ë§ˆì§€ë§‰ ì„  ì„ íƒ
          arrowDirection = null;
          inlineDirection = "";
        } else {
          // ìƒˆ ì„  ê·¸ë¦¬ê¸° ëª¨ë“œ - ê¸°ë³¸ ë°©í–¥ ì„¤ì •
          inlineDirection = 'Right';
          arrowDirection = 'Right';
        }
      });
    }
    
    if (key == 'Del') {
      if (showInlineInput && inlineController.text.isNotEmpty) {
        // ìˆ«ì ì…ë ¥ ì¤‘ì´ë©´ ë°±ìŠ¤í˜ì´ìŠ¤ ê¸°ëŠ¥ (ë§ˆì§€ë§‰ ë¬¸ì ì‚­ì œ)
        setState(() {
          final currentText = inlineController.text;
          if (currentText.isNotEmpty) {
            inlineController.text = currentText.substring(0, currentText.length - 1);
            inlineController.selection = TextSelection.fromPosition(
              TextPosition(offset: inlineController.text.length),
            );
          }
        });
      } else {
        // ìˆ«ì ì…ë ¥ ì¤‘ì´ ì•„ë‹ˆë©´ ì„ /ì› ì‚­ì œ
        print('Del í‚¤ ì²˜ë¦¬ - selectedLineIndex: $selectedLineIndex, selectedCircleIndex: $selectedCircleIndex');
        if (selectedLineIndex >= 0) {
          // ì„ íƒëœ ì„ ì´ ìˆìœ¼ë©´ í•´ë‹¹ ì„  ì‚­ì œ
          print('Del ë²„íŠ¼: ì„ íƒëœ ì„  ì‚­ì œ (ì¸ë±ìŠ¤: $selectedLineIndex)');
          deleteSelectedLine();
        } else if (selectedCircleIndex >= 0) {
          // ì„ íƒëœ ì›ì´ ìˆìœ¼ë©´ í•´ë‹¹ ì› ì‚­ì œ
          print('Del ë²„íŠ¼: ì„ íƒëœ ì› ì‚­ì œ (ì¸ë±ìŠ¤: $selectedCircleIndex)');
          deleteSelectedCircle();
        } else if (circles.isNotEmpty) {
          // ì„ íƒëœ ê²ƒì´ ì—†ê³  ì›ì´ ì¡´ì¬í•˜ë©´ ë§ˆì§€ë§‰ ì› ì‚­ì œ
          print('Del ë²„íŠ¼: ë§ˆì§€ë§‰ ì› ì‚­ì œ');
          deleteLastCircle();
        } else if (lines.isNotEmpty) {
          // ì„ íƒëœ ê²ƒì´ ì—†ê³  ì„ ì´ ì¡´ì¬í•˜ë©´ ë§ˆì§€ë§‰ ì„  ì‚­ì œ
          print('Del ë²„íŠ¼: ë§ˆì§€ë§‰ ì„  ì‚­ì œ');
          deleteLastLine();
        }
        // ì„ íƒëœ ê²ƒë„ ì—†ê³  ì„ ë„ ì—†ìœ¼ë©´ ì•„ë¬´ ë™ì‘ ì•ˆí•¨
      }
    } else if (key == 'Ent') {
      print('Enter í‚¤ ëˆŒë¦¼ - showInlineInput: $showInlineInput, circleMode: $circleMode, circleCenter: $circleCenter');
      if (showInlineInput) {
        print('ì¸ë¼ì¸ ì…ë ¥ í™•ì¸ í˜¸ì¶œ');
        confirmInlineInput();
      } else {
        print('ì¸ë¼ì¸ ì…ë ¥ ëª¨ë“œë¡œ ì „í™˜');
        // ì¸ë¼ì¸ ì…ë ¥ì´ ì—†ëŠ” ìƒíƒœì—ì„œ Enterë¥¼ ëˆ„ë¥´ë©´ ê¸°ë³¸ ë™ì‘
        setState(() {
          showInlineInput = true;
          inlineController.text = '';
          
          // ì› ëª¨ë“œì—ì„œ ì¤‘ì‹¬ì ì´ ì„¤ì •ë˜ì–´ ìˆìœ¼ë©´ ì§€ë¦„ ì…ë ¥ ëª¨ë“œ
          if (circleMode && circleCenter != null) {
            print('ì› ëª¨ë“œ - Enterë¡œ ì§€ë¦„ ì…ë ¥ ëª¨ë“œ ì „í™˜');
            arrowDirection = null;
            inlineDirection = "";
          } else if (selectedCircleIndex >= 0) {
            // ì„ íƒëœ ì›ì´ ìˆìœ¼ë©´ ì› ì´ë™ ëª¨ë“œ - ë°©í–¥í‚¤ ìœ ì§€
            print('ì› ì„ íƒë¨ - Enterë¡œ ì› ì´ë™ ëª¨ë“œ ì „í™˜');
          } else if (inlineDirection.isEmpty && arrowDirection == null) {
            inlineDirection = 'Right';
            arrowDirection = 'Right';
          }
        });
        WidgetsBinding.instance.addPostFrameCallback((_) {
          inlineFocus.requestFocus();
        });
      }
    } else if (key == '+' || key == '-' || key == '00' || RegExp(r'^[0-9]$').hasMatch(key)) {
      if (showInlineInput) {
        setState(() {
          inlineController.text += key;
        });
        inlineController.selection = TextSelection.fromPosition(
          TextPosition(offset: inlineController.text.length),
        );
      }
    }
    
    // í¬ì»¤ìŠ¤ ìœ ì§€
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (showInlineInput) {
        inlineFocus.requestFocus();
      } else {
        _focusNode.requestFocus();
      }
    });
  }

  void modifyLineLength(int index, double newLength) {
    if (index < 0 || index >= lines.length) return;
    
    final line = lines[index];
    final dx = line.end.dx - line.start.dx;
    final dy = line.end.dy - line.start.dy;
    final oldLen = math.sqrt(dx * dx + dy * dy);
    
    if (oldLen == 0) return;
    
    // ê¸¸ì´ê°€ 0ì´ ë˜ëŠ” ê²½ìš° íŠ¹ë³„ ì²˜ë¦¬
    if (newLength == 0) {
      print('ì„  ê¸¸ì´ë¥¼ 0ìœ¼ë¡œ ë³€ê²½ - ì—°ê²°ëœ ëª¨ë“  ì„ ë“¤ ì´ë™');
      
      // ì¼ë°˜ì ì¸ ê¸¸ì´ ìˆ˜ì •ì²˜ëŸ¼ ëì ì„ ì‹œì‘ì ìœ¼ë¡œ ì´ë™ì‹œí‚¤ë˜ ì„ ì€ ì‚­ì œ
      final oldEnd = line.end;
      final newEnd = line.start; // ê¸¸ì´ê°€ 0ì´ë¯€ë¡œ ëì ì„ ì‹œì‘ì ìœ¼ë¡œ
      
      setState(() {
        // ëŒ€ê°ì„ ì´ë“  ì•„ë‹ˆë“  ì—°ê²°ëœ ëª¨ë“  ìš”ì†Œë“¤ì„ ì´ë™ì‹œí‚´
        // ì—°ê²°ëœ ëª¨ë“  ìš”ì†Œë“¤ì„ ì´ë™ì‹œí‚¤ëŠ” í•¨ìˆ˜
        void moveConnectedElements(Offset oldPoint, Offset newPoint, Set<int> visitedLines) {
            final pointShift = Offset(
              newPoint.dx - oldPoint.dx,
              newPoint.dy - oldPoint.dy,
            );
            
            for (int i = 0; i < lines.length; i++) {
              if (visitedLines.contains(i) || i == index) continue; // í˜„ì¬ ì„ ì€ ì œì™¸
              
              final currentLine = lines[i];
              
              if (currentLine.isDiagonal) {
                if (currentLine.connectedPoints != null) {
                  final startInfo = currentLine.connectedPoints!['start'] as List<int>;
                  final endInfo = currentLine.connectedPoints!['end'] as List<int>;
                  
                  if ((currentLine.start.dx - oldPoint.dx).abs() < 0.01 &&
                      (currentLine.start.dy - oldPoint.dy).abs() < 0.01) {
                    currentLine.start = newPoint;
                  }
                  
                  if ((currentLine.end.dx - oldPoint.dx).abs() < 0.01 &&
                      (currentLine.end.dy - oldPoint.dy).abs() < 0.01) {
                    currentLine.end = newPoint;
                  }
                }
              } else {
                if ((currentLine.start.dx - oldPoint.dx).abs() < 0.01 &&
                    (currentLine.start.dy - oldPoint.dy).abs() < 0.01) {
                  visitedLines.add(i);
                  
                  currentLine.start = newPoint;
                  final newEndPoint = Offset(
                    currentLine.end.dx + pointShift.dx,
                    currentLine.end.dy + pointShift.dy,
                  );
                  final oldEndPoint = currentLine.end;
                  currentLine.end = newEndPoint;
                  
                  moveConnectedElements(oldEndPoint, newEndPoint, visitedLines);
                }
              }
            }
            
            if ((currentPoint.dx - oldPoint.dx).abs() < 0.01 &&
                (currentPoint.dy - oldPoint.dy).abs() < 0.01) {
              currentPoint = newPoint;
            }
          }
        
        final visitedLines = <int>{index};
        moveConnectedElements(oldEnd, newEnd, visitedLines);
        
        // ê¸¸ì´ê°€ 0ì¸ ì„  ì‚­ì œ
        lines.removeAt(index);
        
        // ì„ íƒ ìƒíƒœ ì´ˆê¸°í™”
        selectedLineIndex = -1;
        
        // ëŒ€ê°ì„  ì—°ê²° ì •ë³´ ì—…ë°ì´íŠ¸
        for (final line in lines) {
          if (line.isDiagonal && line.connectedPoints != null) {
            final startInfo = line.connectedPoints!['start'] as List<int>;
            final endInfo = line.connectedPoints!['end'] as List<int>;
            
            // ì‚­ì œëœ ì„ ì„ ì°¸ì¡°í•˜ëŠ” ê²½ìš° -1ë¡œ ì„¤ì •
            if (startInfo[0] == index) {
              startInfo[0] = -1;
            } else if (startInfo[0] > index) {
              startInfo[0]--;
            }
            
            if (endInfo[0] == index) {
              endInfo[0] = -1;
            } else if (endInfo[0] > index) {
              endInfo[0]--;
            }
          }
        }
      });
      
      _updateFirebase();
      return;
    }
    
    final unitX = dx / oldLen;
    final unitY = dy / oldLen;
    
    final newEnd = Offset(
      line.start.dx + newLength * unitX,
      line.start.dy + newLength * unitY,
    );
    
    setState(() {
      if (line.isDiagonal) {
        line.end = newEnd;
      } else {
        final oldEnd = line.end;
        final shift = Offset(
          newEnd.dx - line.end.dx,
          newEnd.dy - line.end.dy,
        );
        
        line.end = newEnd;
        
        void moveConnectedElements(Offset oldPoint, Offset newPoint, Set<int> visitedLines) {
          final pointShift = Offset(
            newPoint.dx - oldPoint.dx,
            newPoint.dy - oldPoint.dy,
          );
          
          for (int i = 0; i < lines.length; i++) {
            if (visitedLines.contains(i)) continue;
            
            final currentLine = lines[i];
            
            if (currentLine.isDiagonal) {
              if (currentLine.connectedPoints != null) {
                final startInfo = currentLine.connectedPoints!['start'] as List<int>;
                final endInfo = currentLine.connectedPoints!['end'] as List<int>;
                
                if ((currentLine.start.dx - oldPoint.dx).abs() < 0.01 &&
                    (currentLine.start.dy - oldPoint.dy).abs() < 0.01) {
                  currentLine.start = newPoint;
                }
                
                if ((currentLine.end.dx - oldPoint.dx).abs() < 0.01 &&
                    (currentLine.end.dy - oldPoint.dy).abs() < 0.01) {
                  currentLine.end = newPoint;
                }
              }
            } else {
              if ((currentLine.start.dx - oldPoint.dx).abs() < 0.01 &&
                  (currentLine.start.dy - oldPoint.dy).abs() < 0.01) {
                visitedLines.add(i);
                
                currentLine.start = newPoint;
                final newEndPoint = Offset(
                  currentLine.end.dx + pointShift.dx,
                  currentLine.end.dy + pointShift.dy,
                );
                final oldEndPoint = currentLine.end;
                currentLine.end = newEndPoint;
                
                moveConnectedElements(oldEndPoint, newEndPoint, visitedLines);
              }
            }
          }
          
          if ((currentPoint.dx - oldPoint.dx).abs() < 0.01 &&
              (currentPoint.dy - oldPoint.dy).abs() < 0.01) {
            currentPoint = newPoint;
          }
        }
        
        final visitedLines = <int>{index};
        moveConnectedElements(oldEnd, newEnd, visitedLines);
      }
    });
    
    _updateFirebase();
  }

  // ì£¼ì–´ì§„ ì ì— ì—°ê²°ëœ ëª¨ë“  ì„ ë“¤ì„ ì°¾ëŠ” í•¨ìˆ˜
  Set<int> findConnectedLines(Offset point) {
    Set<int> connectedLines = {};
    Set<Offset> visitedPoints = {};
    
    void findConnected(Offset currentPoint) {
      if (visitedPoints.contains(currentPoint)) return;
      visitedPoints.add(currentPoint);
      
      for (int i = 0; i < lines.length; i++) {
        final line = lines[i];
        bool isConnected = false;
        Offset? nextPoint;
        
        if ((line.start.dx - currentPoint.dx).abs() < 0.01 &&
            (line.start.dy - currentPoint.dy).abs() < 0.01) {
          isConnected = true;
          nextPoint = line.end;
        } else if ((line.end.dx - currentPoint.dx).abs() < 0.01 &&
                   (line.end.dy - currentPoint.dy).abs() < 0.01) {
          isConnected = true;
          nextPoint = line.start;
        }
        
        if (isConnected && !connectedLines.contains(i)) {
          connectedLines.add(i);
          if (nextPoint != null) {
            findConnected(nextPoint);
          }
        }
      }
    }
    
    findConnected(point);
    return connectedLines;
  }
  
  // ë“œë˜ê·¸ ì¤‘ì¸ ê·¸ë£¹ì˜ ìŠ¤ëƒ… ì •ë³´
  Map<String, Offset>? groupSnapInfo;
  
  // ë“œë˜ê·¸ ì¤‘ì¸ ê·¸ë£¹ê³¼ ë‹¤ë¥¸ ê·¸ë£¹ì˜ ëì  ì¤‘ ê°€ì¥ ê°€ê¹Œìš´ ì  ì°¾ê¸°
  Map<String, Offset>? findNearestSnapPoint() {
    Offset? nearestSnapPoint;
    Offset? correspondingGroupPoint;
    double minDistance = double.infinity;
    const double snapThreshold = 30.0; // ìŠ¤ëƒ… ê±°ë¦¬ ì„ê³„ê°’
    
    // ë“œë˜ê·¸ ì¤‘ì¸ ê·¸ë£¹ì˜ ëª¨ë“  ëì ì— ëŒ€í•´ ê²€ì‚¬
    for (int groupLineIdx in draggedGroupLines) {
      if (groupLineIdx >= lines.length) continue;
      final groupLine = lines[groupLineIdx];
      
      // ê·¸ë£¹ì˜ ê° ëì ì— ëŒ€í•´
      for (final groupPoint in [groupLine.start, groupLine.end]) {
        // ë‹¤ë¥¸ ëª¨ë“  ì„ ì˜ ëì ê³¼ ë¹„êµ
        for (int i = 0; i < lines.length; i++) {
          if (draggedGroupLines.contains(i)) continue; // ë“œë˜ê·¸ ì¤‘ì¸ ê·¸ë£¹ì€ ì œì™¸
          
          final line = lines[i];
          
          // ì‹œì‘ì  ê²€ì‚¬
          final startDist = (line.start - groupPoint).distance;
          if (startDist < minDistance && startDist < snapThreshold) {
            minDistance = startDist;
            nearestSnapPoint = line.start;
            correspondingGroupPoint = groupPoint;
          }
          
          // ëì  ê²€ì‚¬
          final endDist = (line.end - groupPoint).distance;
          if (endDist < minDistance && endDist < snapThreshold) {
            minDistance = endDist;
            nearestSnapPoint = line.end;
            correspondingGroupPoint = groupPoint;
          }
        }
        
        // ë¹¨ê°„ ì (ì„ íƒëœ ëì )ê³¼ë„ ë¹„êµ
        if (selectedEndpoint != null) {
          final redPointDist = (selectedEndpoint! - groupPoint).distance;
          if (redPointDist < minDistance && redPointDist < snapThreshold) {
            minDistance = redPointDist;
            nearestSnapPoint = selectedEndpoint;
            correspondingGroupPoint = groupPoint;
          }
        }
      }
    }
    
    // ìŠ¤ëƒ…í•  ì ì„ ì°¾ì•˜ìœ¼ë©´, ê·¸ë£¹ ì ê³¼ ìŠ¤ëƒ… ëŒ€ìƒ ì ì˜ ì •ë³´ ë°˜í™˜
    if (nearestSnapPoint != null && correspondingGroupPoint != null) {
      return {
        'snapTarget': nearestSnapPoint,
        'groupPoint': correspondingGroupPoint,
      };
    }
    
    return null;
  }

  void deleteLastLine() {
    if (lines.isEmpty) {
      print('deleteLastLine: ì‚­ì œí•  ì„ ì´ ì—†ìŒ');
      return;
    }
    
    final lastIndex = lines.length - 1;
    print('deleteLastLine: ë§ˆì§€ë§‰ ì„  ì‚­ì œ ì‹œì‘ - ì¸ë±ìŠ¤: $lastIndex');
    
    saveState();
    
    setState(() {
      try {
        final lastLine = lines[lastIndex];
        final isDiagonal = lastLine.isDiagonal;
        
        print('deleteLastLine: ì‚­ì œí•  ì„  - isDiagonal: $isDiagonal');
        
        // í˜„ì¬ ì  ì—…ë°ì´íŠ¸ (ëŒ€ê°ì„ ì´ ì•„ë‹Œ ê²½ìš°ì—ë§Œ)
        if (!isDiagonal && lastIndex > 0) {
          currentPoint = lastLine.start;
          print('deleteLastLine: í˜„ì¬ ì  ì—…ë°ì´íŠ¸ - $currentPoint');
        } else if (!isDiagonal && lastIndex == 0) {
          // ì²« ë²ˆì§¸ ì„ ì„ ì‚­ì œí•˜ëŠ” ê²½ìš° ì›ì ìœ¼ë¡œ ë³µê·€
          currentPoint = const Offset(0, 0);
          print('deleteLastLine: ì²« ë²ˆì§¸ ì„  ì‚­ì œ - ì›ì ìœ¼ë¡œ ë³µê·€');
        }
        
        // ì„  ì‚­ì œ
        lines.removeAt(lastIndex);
        print('deleteLastLine: ì„  ì‚­ì œ ì™„ë£Œ - ë‚¨ì€ ì„  ê°œìˆ˜: ${lines.length}');
        
        // ëŒ€ê°ì„  ì—°ê²° ì •ë³´ ì—…ë°ì´íŠ¸
        for (final line in lines) {
          if (line.isDiagonal && line.connectedPoints != null) {
            final startInfo = line.connectedPoints!['start'] as List<int>;
            final endInfo = line.connectedPoints!['end'] as List<int>;
            
            // ì‚­ì œëœ ì„ ì„ ì°¸ì¡°í•˜ëŠ” ê²½ìš° -1ë¡œ ì„¤ì •
            if (startInfo[0] == lastIndex) {
              startInfo[0] = -1;
            } else if (startInfo[0] > lastIndex) {
              startInfo[0]--;
            }
            
            if (endInfo[0] == lastIndex) {
              endInfo[0] = -1;
            } else if (endInfo[0] > lastIndex) {
              endInfo[0]--;
            }
          }
        }
        
        // ì„ íƒ ìƒíƒœ ì´ˆê¸°í™”
        selectedLineIndex = -1;
        selectedCircleIndex = -1;
        
      } catch (e) {
        print('deleteLastLine: ì˜¤ë¥˜ ë°œìƒ - $e');
        // ì˜¤ë¥˜ ë°œìƒ ì‹œ ì•ˆì „í•˜ê²Œ ìƒíƒœ ì´ˆê¸°í™”
        selectedLineIndex = -1;
        selectedCircleIndex = -1;
      }
    });
    
    _updateFirebase();
    print('deleteLastLine: ì™„ë£Œ');
  }

  void deleteSelectedLine() {
    if (selectedLineIndex < 0 || selectedLineIndex >= lines.length) {
      print('deleteSelectedLine: ì˜ëª»ëœ ì¸ë±ìŠ¤ - selectedLineIndex: $selectedLineIndex, lines.length: ${lines.length}');
      return;
    }
    
    print('deleteSelectedLine: ì„  ì‚­ì œ ì‹œì‘ - ì¸ë±ìŠ¤: $selectedLineIndex');
    
    saveState();
    
    setState(() {
      try {
        final selectedLine = lines[selectedLineIndex];
        final isDiagonal = selectedLine.isDiagonal;
        
        print('deleteSelectedLine: ì‚­ì œí•  ì„  - isDiagonal: $isDiagonal');
        
        // í˜„ì¬ ì  ì—…ë°ì´íŠ¸ (ëŒ€ê°ì„ ì´ ì•„ë‹Œ ê²½ìš°ì—ë§Œ)
        if (!isDiagonal && selectedLineIndex > 0) {
          currentPoint = selectedLine.start;
          print('deleteSelectedLine: í˜„ì¬ ì  ì—…ë°ì´íŠ¸ - $currentPoint');
        }
        
        // ì„  ì‚­ì œ
        lines.removeAt(selectedLineIndex);
        print('deleteSelectedLine: ì„  ì‚­ì œ ì™„ë£Œ - ë‚¨ì€ ì„  ê°œìˆ˜: ${lines.length}');
        
        // ëŒ€ê°ì„  ì—°ê²° ì •ë³´ ì—…ë°ì´íŠ¸
        for (final line in lines) {
          if (line.isDiagonal && line.connectedPoints != null) {
            final startInfo = line.connectedPoints!['start'] as List<int>;
            final endInfo = line.connectedPoints!['end'] as List<int>;
            
            // ì‚­ì œëœ ì„ ì„ ì°¸ì¡°í•˜ëŠ” ê²½ìš° -1ë¡œ ì„¤ì •
            if (startInfo[0] == selectedLineIndex) {
              startInfo[0] = -1;
            } else if (startInfo[0] > selectedLineIndex) {
              startInfo[0]--;
            }
            
            if (endInfo[0] == selectedLineIndex) {
              endInfo[0] = -1;
            } else if (endInfo[0] > selectedLineIndex) {
              endInfo[0]--;
            }
          }
        }
        
        // ëª¨ë“  ìƒíƒœ ì´ˆê¸°í™”
        selectedLineIndex = -1;
        selectedCircleIndex = -1;
        showLinePopup = false;
        selectedLineForPopup = null;
        linePopupPosition = null;
        showInlineInput = false;
        arrowDirection = null;
        inlineDirection = "";
        isProcessingInput = false;
        
        print('deleteSelectedLine: ìƒíƒœ ì´ˆê¸°í™” ì™„ë£Œ');
        
      } catch (e) {
        print('deleteSelectedLine: ì˜¤ë¥˜ ë°œìƒ - $e');
        // ì˜¤ë¥˜ ë°œìƒ ì‹œ ì•ˆì „í•œ ìƒíƒœë¡œ ë³µì›
        selectedLineIndex = -1;
        selectedCircleIndex = -1;
        showLinePopup = false;
        selectedLineForPopup = null;
        linePopupPosition = null;
        showInlineInput = false;
        arrowDirection = null;
        inlineDirection = "";
        isProcessingInput = false;
      }
    });
    
    // Firebase ì—…ë°ì´íŠ¸ëŠ” setState ì™„ë£Œ í›„ ì‹¤í–‰
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _updateFirebase();
      print('deleteSelectedLine: Firebase ì—…ë°ì´íŠ¸ ì™„ë£Œ');
    });
  }

  void deleteSelectedCircle() {
    if (selectedCircleIndex < 0 || selectedCircleIndex >= circles.length) {
      print('deleteSelectedCircle: ì˜ëª»ëœ ì¸ë±ìŠ¤ - selectedCircleIndex: $selectedCircleIndex, circles.length: ${circles.length}');
      return;
    }
    
    print('deleteSelectedCircle: ì› ì‚­ì œ ì‹œì‘ - ì¸ë±ìŠ¤: $selectedCircleIndex');
    
    saveState();
    
    setState(() {
      try {
        // ì› ì‚­ì œ
        circles.removeAt(selectedCircleIndex);
        print('deleteSelectedCircle: ì› ì‚­ì œ ì™„ë£Œ - ë‚¨ì€ ì› ê°œìˆ˜: ${circles.length}');
        
        // ëª¨ë“  ìƒíƒœ ì´ˆê¸°í™”
        selectedCircleIndex = -1;
        selectedLineIndex = -1;
        showLinePopup = false;
        selectedLineForPopup = null;
        linePopupPosition = null;
        showInlineInput = false;
        arrowDirection = null;
        inlineDirection = "";
        isProcessingInput = false;
        
        print('deleteSelectedCircle: ìƒíƒœ ì´ˆê¸°í™” ì™„ë£Œ');
        
      } catch (e) {
        print('deleteSelectedCircle: ì˜¤ë¥˜ ë°œìƒ - $e');
        // ì˜¤ë¥˜ ë°œìƒ ì‹œ ì•ˆì „í•œ ìƒíƒœë¡œ ë³µì›
        selectedCircleIndex = -1;
        selectedLineIndex = -1;
        showLinePopup = false;
        selectedLineForPopup = null;
        linePopupPosition = null;
        showInlineInput = false;
        arrowDirection = null;
        inlineDirection = "";
        isProcessingInput = false;
      }
    });
    
    // Firebase ì—…ë°ì´íŠ¸ëŠ” setState ì™„ë£Œ í›„ ì‹¤í–‰
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _updateFirebase();
      print('deleteSelectedCircle: Firebase ì—…ë°ì´íŠ¸ ì™„ë£Œ');
    });
  }

  void deleteLastCircle() {
    if (circles.isEmpty) {
      print('deleteLastCircle: ì‚­ì œí•  ì›ì´ ì—†ìŒ');
      return;
    }
    
    final lastIndex = circles.length - 1;
    print('deleteLastCircle: ë§ˆì§€ë§‰ ì› ì‚­ì œ ì‹œì‘ - ì¸ë±ìŠ¤: $lastIndex');
    
    saveState();
    
    setState(() {
      try {
        // ì› ì‚­ì œ
        circles.removeAt(lastIndex);
        print('deleteLastCircle: ì› ì‚­ì œ ì™„ë£Œ - ë‚¨ì€ ì› ê°œìˆ˜: ${circles.length}');
        
        // ì„ íƒ ìƒíƒœ ì´ˆê¸°í™”
        selectedCircleIndex = -1;
        selectedLineIndex = -1;
        
      } catch (e) {
        print('deleteLastCircle: ì˜¤ë¥˜ ë°œìƒ - $e');
        // ì˜¤ë¥˜ ë°œìƒ ì‹œ ì•ˆì „í•˜ê²Œ ìƒíƒœ ì´ˆê¸°í™”
        selectedCircleIndex = -1;
        selectedLineIndex = -1;
      }
    });
    
    _updateFirebase();
    print('deleteLastCircle: ì™„ë£Œ');
  }

  String _getStatusText() {
    if (_isVoiceProcessing) {
      return 'ìŒì„± ì²˜ë¦¬ ì¤‘...';
    }
    
    if (_isListening) {
      return 'ìŒì„± ì¸ì‹ ì¤‘... ìˆ«ìë¥¼ ë§í•´ì£¼ì„¸ìš”';
    }
    
    if (_recognizedText.isNotEmpty && !_isListening) {
      return 'ì¸ì‹ëœ ìŒì„±: "$_recognizedText"';
    }
    
    if (circleMode) {
      return circleCenter == null 
        ? 'ì› ëª¨ë“œ: ì¤‘ì‹¬ì ì„ í´ë¦­í•˜ì„¸ìš”'
        : 'ì› ëª¨ë“œ: ì§€ë¦„ì„ ì…ë ¥í•˜ì„¸ìš” (ìŒì„± ì…ë ¥ ê°€ëŠ¥)';
    }
    
    if (showInlineInput) {
      final directionText = inlineDirection.isEmpty ? "" : " ($inlineDirection)";
      final speechText = _isListening && _recognizedText.isNotEmpty ? '\nì¸ì‹ì¤‘: "$_recognizedText"' : '';
      return 'ìˆ«ì ì…ë ¥ í›„ Enter$directionText (ìŒì„± ì…ë ¥ ê°€ëŠ¥)$speechText';
    }
    
    if (isPointDragging) {
      return 'ì ì—ì„œ ì ìœ¼ë¡œ ì„  ê·¸ë¦¬ëŠ” ì¤‘... (ë‹¤ë¥¸ ì ì—ì„œ ë†“ìœ¼ë©´ ì™„ë£Œ)';
    }
    
    if (selectedLineIndex >= 0) {
      return 'ì„  ${selectedLineIndex + 1}/${lines.length} ì„ íƒë¨ (ìˆ«ì ì…ë ¥ìœ¼ë¡œ ê¸¸ì´ ìˆ˜ì •)';
    }
    
    if (pendingOpeningType == 'window') {
      return 'ì°½ë¬¸ ëª¨ë“œ: ë°©í–¥í‚¤ë¥¼ ëˆŒëŸ¬ì£¼ì„¸ìš”';
    }
    
    final speechText = _isListening && _recognizedText.isNotEmpty ? '\nì¸ì‹ì¤‘: "$_recognizedText"' : '';
    
    if (diagonalMode) {
      return 'ì ì—°ê²° ëª¨ë“œ: ì ì„ í„°ì¹˜í•œ ì±„ë¡œ ë“œë˜ê·¸í•´ì„œ ì„ ì„ ê·¸ë¦¬ì„¸ìš”$speechText';
    } else {
      return 'ì¼ë°˜ ëª¨ë“œ: ë°©í–¥í‚¤ë¥¼ ëˆŒëŸ¬ ì„ ì„ ê·¸ë¦¬ì„¸ìš”$speechText';
    }
  }

  void _handleTap(Offset position) {
    print('_handleTap í˜¸ì¶œë¨ - ìœ„ì¹˜: $position');
    print('í˜„ì¬ ëª¨ë“œ - circleMode: $circleMode, isPointDragging: $isPointDragging');
    
    // í˜ì´ì§€ ë“œë¡­ë‹¤ìš´ì´ ì—´ë ¤ìˆìœ¼ë©´ ë‹«ê¸°
    if (isPageDropdownOpen) {
      _hideDropdownOverlay();
    }
    
    // ì  ë“œë˜ê·¸ ì¤‘ì´ë©´ íƒ­ ë¬´ì‹œ
    if (isPointDragging) {
      print('ì  ë“œë˜ê·¸ ì¤‘ - íƒ­ ë¬´ì‹œ');
      return;
    }
    
    // ì› ëª¨ë“œ ì²˜ë¦¬
    if (circleMode) {
      print('ì› ëª¨ë“œë¡œ ì´ë™');
      // ì› ëª¨ë“œì—ì„œëŠ” ì¸ë¼ì¸ ì…ë ¥ì„ ì·¨ì†Œí•˜ì§€ ì•ŠìŒ (ë‹¤ë¥¸ ëì  í´ë¦­ ì‹œ ìœ„ì¹˜ ì´ë™ì„ ìœ„í•´)
      _handleCircleClick(position);
      return;  // ì› ëª¨ë“œì—ì„œëŠ” ë‹¤ë¥¸ ì²˜ë¦¬ ì—†ì´ ì¦‰ì‹œ ì¢…ë£Œ
    }
    
    // ì¼ë°˜ ëª¨ë“œ ì²˜ë¦¬
    // ë¹ˆ í™”ë©´ í´ë¦­ ì‹œ ì¸ë¼ì¸ ì…ë ¥ì„ ìœ ì§€ (ì‚­ì œë¨)
    // if (showInlineInput) {
    //   cancelInlineInput();
    // }
    
    // ì› ëª¨ë“œê°€ ì•„ë‹ ë•Œë§Œ ëì  ì´ë™ ì²˜ë¦¬
    if (!circleMode) {
      final endpointInfo = _findEndpointNear(position);
        
      if (endpointInfo != null) {
        final clickedPoint = endpointInfo['point'] as Offset;
        
        setState(() {
          // ì´ë¯¸ ì„ íƒëœ ëì ì„ ë‹¤ì‹œ í´ë¦­í•˜ë©´ ì„ íƒ í•´ì œ
          if (selectedEndpoint == clickedPoint) {
            selectedEndpoint = null;
            selectedEndpointLineIndex = null;
            selectedEndpointType = null;
          } else {
            // ìƒˆë¡œìš´ ëì  ì„ íƒí•˜ê³  currentPointë„ ë³€ê²½
            selectedEndpoint = clickedPoint;
            currentPoint = clickedPoint;
            selectedEndpointLineIndex = endpointInfo['index'] as int?;
            selectedEndpointType = endpointInfo['type'] as String?;
          }
          
          // ëì  í´ë¦­ ì‹œ ì„ /ì› ì„ íƒ ìƒíƒœ ì´ˆê¸°í™”
          selectedLineIndex = -1;
          selectedCircleIndex = -1;
          hoveredLineIndex = null;
          
          // í™”ì‚´í‘œ ìƒíƒœ ì´ˆê¸°í™” (ë‹¤ë¥¸ ì ì„ í´ë¦­í–ˆìœ¼ë¯€ë¡œ)
          arrowDirection = null;
          inlineDirection = "";
          isDoubleDirectionPressed = false;
        });
        _updateFirebase();
        return;
      }
    }
    
    // ì› ëª¨ë“œê°€ ì•„ë‹ ë•Œë§Œ ì„ /ì› ì„ íƒ ì²˜ë¦¬
    if (!circleMode) {
      final lineIndex = _findLineNear(position);
      final circleIndex = _findCircleNear(position);
      
      if (lineIndex != null) {
        // ë”ë¸”í´ë¦­ ê°ì§€
        final now = DateTime.now();
        final isDoubleClick = lastTapTime != null && 
            now.difference(lastTapTime!).inMilliseconds < 300 &&
            selectedLineIndex == lineIndex;
        
        if (isDoubleClick) {
          // ë”ë¸”í´ë¦­: ì—°ê²°ëœ ëª¨ë“  ì„  ì„ íƒ
          print('ì„  ë”ë¸”í´ë¦­ - ì—°ê²°ëœ ëª¨ë“  ì„  ì„ íƒ');
          final line = lines[lineIndex];
          
          // ì‹œì‘ì ê³¼ ëì ì—ì„œ ì—°ê²°ëœ ëª¨ë“  ì„  ì°¾ê¸°
          final connectedFromStart = findConnectedLines(line.start);
          final connectedFromEnd = findConnectedLines(line.end);
          
          setState(() {
            // í´ë¦­í•œ ì„  ìì²´ë„ í¬í•¨í•˜ì—¬ ê·¸ë£¹ ì„¤ì •
            selectedGroupLines = {lineIndex, ...connectedFromStart, ...connectedFromEnd};
            selectedLineIndex = lineIndex;
            selectedCircleIndex = -1;
            lastTapTime = null; // ë”ë¸”í´ë¦­ í›„ ë¦¬ì…‹
            print('ë”ë¸”í´ë¦­ - ì„ íƒëœ ê·¸ë£¹: $selectedGroupLines');
          });
          
          HapticFeedback.selectionClick();
        } else if (arrowDirection != null) {
          // í™”ì‚´í‘œê°€ í‘œì‹œëœ ìƒíƒœì—ì„œ ì„ ì„ í´ë¦­í•˜ë©´ ê¸¸ì´ ìˆ˜ì • ëª¨ë“œë¡œ ì „í™˜
          print('í™”ì‚´í‘œ ìƒíƒœì—ì„œ ì„  í´ë¦­ - ê¸¸ì´ ìˆ˜ì • ëª¨ë“œë¡œ ì „í™˜ (íŒì—…ì€ ìˆ«ì ì…ë ¥ ì‹œ í‘œì‹œ)');
          setState(() {
            selectedLineIndex = lineIndex;
            selectedCircleIndex = -1;
            selectedGroupLines.clear(); // ê·¸ë£¹ ì„ íƒ í•´ì œ
            // í™”ì‚´í‘œ ìƒíƒœ ì´ˆê¸°í™”í•˜ì§€ë§Œ ì¸ë¼ì¸ ì…ë ¥ ëª¨ë“œëŠ” ë°”ë¡œ í‘œì‹œí•˜ì§€ ì•ŠìŒ
            arrowDirection = null;
            inlineDirection = "";
            showInlineInput = false; // íŒì—…ì€ ìˆ«ì ì…ë ¥ ì‹œ í‘œì‹œ
            inlineController.clear();
            lastTapTime = now;
          });
          
          // í¬ì»¤ìŠ¤ëŠ” ë©”ì¸ìœ¼ë¡œ ìœ ì§€ (ìˆ«ì ì…ë ¥ì„ ìœ„í•´)
          WidgetsBinding.instance.addPostFrameCallback((_) {
            _focusNode.requestFocus();
          });
        } else {
          // ì¼ë°˜ ì„ íƒ ëª¨ë“œ
          setState(() {
            selectedLineIndex = lineIndex;
            selectedCircleIndex = -1; // ì› ì„ íƒ í•´ì œ
            selectedGroupLines.clear(); // ê·¸ë£¹ ì„ íƒ í•´ì œ
            lastTapTime = now;
          });
        }
      } else if (circleIndex != null) {
        // ì› ì„ íƒ
        setState(() {
          selectedCircleIndex = circleIndex;
          selectedLineIndex = -1; // ì„  ì„ íƒ í•´ì œ
        });
      } else {
        // ë¹ˆ í™”ë©´ í´ë¦­ - ë”ë¸”í´ë¦­ ê°ì§€
        final now = DateTime.now();
        final isDoubleClick = lastTapTime != null &&
            now.difference(lastTapTime!).inMilliseconds < 300;

        if (isDoubleClick) {
          // ë”ë¸”í´ë¦­: ë·° ë§ì¶¤ ì‹¤í–‰ (ëª¨ë“  ëª¨ë“œì—ì„œ ë™ì¼í•˜ê²Œ fitViewToDrawing ì‚¬ìš©)
          print('ë¹ˆ í™”ë©´ ë”ë¸”í´ë¦­ - ë·° ë§ì¶¤ ì‹¤í–‰');
          fitViewToDrawing();
          setState(() {
            lastTapTime = null; // ë”ë¸”í´ë¦­ í›„ ë¦¬ì…‹
          });
        } else {
          // ì¼ë°˜ í´ë¦­
          setState(() {
            selectedLineIndex = -1;
            selectedCircleIndex = -1;
            // íŒŒë€ì„  ê·¸ë£¹ì´ ì„ íƒë˜ì–´ ìˆëŠ” ê²½ìš°ì—ëŠ” selectedEndpointë¥¼ ìœ ì§€
            if (selectedGroupLines.isEmpty) {
              selectedEndpoint = null; // ë¹ˆ ê³³ í´ë¦­ ì‹œ ëì  ì„ íƒë„ í•´ì œ
              selectedEndpointLineIndex = null;
              selectedEndpointType = null;
            }
            selectedGroupLines.clear(); // ê·¸ë£¹ ì„ íƒ í•´ì œ
            lastTapTime = now;

            // ë¹ˆ ê³³ í´ë¦­ ì‹œì—ëŠ” í™”ì‚´í‘œ ìƒíƒœë¥¼ ìœ ì§€
          });
        }
      }
    }
  }

  void _handleCircleClick(Offset position) {
    print('ì› í´ë¦­: $position');
    
    // ê°€ì¥ ê°€ê¹Œìš´ ëì  ì°¾ê¸°
    final endpointInfo = _findEndpointNear(position);
    Offset? closestPoint = endpointInfo?['point'] as Offset?;
    
    print('ëì  ì°¾ê¸° ê²°ê³¼: $endpointInfo');
    
    // ëì ì„ ì°¾ì§€ ëª»í•˜ë©´ ì›ì„ ìƒì„±í•˜ì§€ ì•ŠìŒ
    if (closestPoint == null) {
      print('ëì ì„ ì°¾ì§€ ëª»í•¨ - ì› ìƒì„± ì·¨ì†Œ');
      return;
    }
    
    final centerPoint = closestPoint;
    
    print('ì› ì¤‘ì‹¬ì  í›„ë³´: $centerPoint (ëì  ë°œê²¬: true)');
    
    // ì¤‘ì‹¬ì  ìœ íš¨ì„± ê²€ì‚¬
    if (centerPoint.dx.isNaN || centerPoint.dy.isNaN || 
        centerPoint.dx.isInfinite || centerPoint.dy.isInfinite) {
      print('ì› ì¤‘ì‹¬ì  ì˜¤ë¥˜: ìœ íš¨í•˜ì§€ ì•Šì€ ì¢Œí‘œ ($centerPoint)');
      return;
    }
    
    // ì¸ë¼ì¸ ì…ë ¥ì´ í‘œì‹œë˜ì–´ ìˆê³  ì›ì´ ì•„ì§ ìƒì„±ë˜ì§€ ì•Šì€ ìƒíƒœì—ì„œ ë‹¤ë¥¸ ëì  í´ë¦­
    print('ì› ëª¨ë“œ ì²´í¬ - showInlineInput: $showInlineInput, circleCenter: $circleCenter, circleMode: $circleMode');
    if (showInlineInput && circleCenter != null && circleMode) {
      print('ì› ì¤‘ì‹¬ì  ë³€ê²½ ì¡°ê±´ ë§Œì¡±!');
      print('ì´ì „ ì¤‘ì‹¬ì : $circleCenter');
      print('ìƒˆë¡œìš´ ì¤‘ì‹¬ì : $centerPoint');
      
      setState(() {
        circleCenter = centerPoint;
        // ì…ë ¥ëœ í…ìŠ¤íŠ¸ëŠ” ìœ ì§€
      });
      
      print('setState í›„ circleCenter: $circleCenter');
      
      // í¬ì»¤ìŠ¤ ìœ ì§€
      WidgetsBinding.instance.addPostFrameCallback((_) {
        inlineFocus.requestFocus();
      });
      return;
    }
    
    // ì²« ë²ˆì§¸ í´ë¦­ ë˜ëŠ” ìƒˆë¡œìš´ ì› ìƒì„±
    if (circleCenter == null) {
      setState(() {
        circleCenter = centerPoint;
        // ì› ì¤‘ì‹¬ì  ì„¤ì • ì‹œ ëª¨ë“  ì„ íƒ ìƒíƒœ ì´ˆê¸°í™”
        selectedLineIndex = -1;
        selectedCircleIndex = -1;
        hoveredLineIndex = null;
      });
      print('ì› ì¤‘ì‹¬ì  ì„¤ì • ì™„ë£Œ: $circleCenter (ì„ íƒ ìƒíƒœ ì´ˆê¸°í™”)');
      
      // ì§€ë¦„ ì…ë ¥ ëª¨ë“œë¡œ ì „í™˜
      setState(() {
        showInlineInput = true;
        inlineController.clear();
        arrowDirection = null;
        inlineDirection = "";
      });
      
      print('ì§€ë¦„ ì…ë ¥ ëª¨ë“œë¡œ ì „í™˜ ì™„ë£Œ');
      
      WidgetsBinding.instance.addPostFrameCallback((_) {
        inlineFocus.requestFocus();
      });
    }
  }



  // ì  ê°„ ë“œë˜ê·¸ ì„  ê·¸ë¦¬ê¸° í•¨ìˆ˜ë“¤
  void _handleCirclePanStart(DragStartDetails details) {
    print('=== ì› ëª¨ë“œ í™”ë©´ ì´ë™ ì‹œì‘ ===');
    final position = details.localPosition;
    setState(() {
      _isPanning = true;
      _lastPanPosition = position;
      isPointDragging = false;
    });
    print('ì› ëª¨ë“œ í™”ë©´ ì´ë™ ì‹œì‘: $position');
  }

  void _handlePointDragStart(DragStartDetails details) {
    // ì› ëª¨ë“œ ì¤‘ì´ë©´ ë¬´ì‹œ (ì¸ë¼ì¸ ì…ë ¥ ì¤‘ì—ëŠ” í™”ë©´ ì´ë™ í—ˆìš©)
    if (circleMode) {
      print('ì› ëª¨ë“œ ì¤‘ - ì  ë“œë˜ê·¸ ë¬´ì‹œ');
      return;
    }
    
    final position = details.localPosition;
    print('\n=== ì ì—°ê²° ë“œë˜ê·¸ ì‹œì‘: í„°ì¹˜ìœ„ì¹˜=$position ===');
    
    // í„°ì¹˜/í´ë¦­ ìœ„ì¹˜ ì—…ë°ì´íŠ¸ (ë””ë²„ê¹…ìš©)
    setState(() {
      mousePosition = position;
    });
    
    final startPoint = _findNearestEndpoint(position);
    print('ëì  ì°¾ê¸° ê²°ê³¼: ${startPoint != null ? "ì°¾ìŒ $startPoint" : "ëª»ì°¾ìŒ"}');
    
    // ê·¸ë£¹ì´ ì„ íƒëœ ìƒíƒœì—ì„œëŠ” í™”ë©´ ì•„ë¬´ ê³³ì´ë‚˜ ë“œë˜ê·¸í•´ë„ ê·¸ë£¹ ì´ë™
    print('ê·¸ë£¹ ì„ íƒ í™•ì¸ - selectedGroupLines: ${selectedGroupLines.length}ê°œ');
    if (selectedGroupLines.isNotEmpty) {
      print('ê·¸ë£¹ì´ ì„ íƒë¨ - í™”ë©´ ì•„ë¬´ ê³³ ë“œë˜ê·¸ë¡œ ê·¸ë£¹ ì´ë™ ì‹œì‘');
      
      // ë“œë˜ê·¸ ì‹œì‘ ìœ„ì¹˜ë¥¼ ëª¨ë¸ ì¢Œí‘œë¡œ ë³€í™˜
      final dragStartModelPos = _screenToModel(position);
      
      setState(() {
        isGroupDragging = true;
        groupDragStartPoint = dragStartModelPos;
        groupDragCurrentPoint = dragStartModelPos;
        draggedGroupLines = Set.from(selectedGroupLines);
        
        // ì›ë˜ ìœ„ì¹˜ ì €ì¥
        originalLineStarts.clear();
        originalLineEnds.clear();
        for (int i in draggedGroupLines) {
          if (i < lines.length) {
            originalLineStarts[i] = lines[i].start;
            originalLineEnds[i] = lines[i].end;
          }
        }
        
        _isPanning = false;
        _isScaling = false;
        isPointDragging = false;
      });
      
      HapticFeedback.selectionClick();
      return;
    }
    
    // ëŒ€ê°ì„  ëª¨ë“œê°€ ì•„ë‹ˆê³  ê·¸ë£¹ë„ ì„ íƒë˜ì§€ ì•Šì•˜ê±°ë‚˜ ì¸ë¼ì¸ ì…ë ¥ ì¤‘ì´ë©´ í™”ë©´ ì´ë™ë§Œ í—ˆìš©
    if ((!diagonalMode && selectedGroupLines.isEmpty) || showInlineInput) {
      print('ëŒ€ê°ì„  ëª¨ë“œê°€ ì•„ë‹ˆê³  ê·¸ë£¹ë„ ì„ íƒë˜ì§€ ì•Šì•˜ê±°ë‚˜ ì¸ë¼ì¸ ì…ë ¥ ì¤‘ - ì  ë“œë˜ê·¸ ë¹„í™œì„±í™”, í™”ë©´ ì´ë™ë§Œ í—ˆìš©');
      // ëŒ€ê°ì„  ëª¨ë“œê°€ ì•„ë‹ˆê³  ê·¸ë£¹ë„ ì„ íƒë˜ì§€ ì•Šì•˜ê±°ë‚˜ ì¸ë¼ì¸ ì…ë ¥ ì¤‘ì¼ ë•ŒëŠ” í™”ë©´ ì´ë™ë§Œ í—ˆìš©
      setState(() {
        _isPanning = true;
        _lastPanPosition = position;
        isPointDragging = false;
      });
      print('í™”ë©´ ì´ë™ ì‹œì‘: $position (ëŒ€ê°ì„  ëª¨ë“œ: $diagonalMode, ê·¸ë£¹ ì„ íƒ: ${selectedGroupLines.length}ê°œ, ì¸ë¼ì¸ ì…ë ¥: $showInlineInput)');
      return;
    }
    
    // ì•„ì´íŒ¨ë“œ ì›¹ì—ì„œ ë©€í‹°í„°ì¹˜ ì¤‘ì´ë©´ ë¬´ì‹œ
    if (isTablet && _touchCount > 1) {
      print('ì•„ì´íŒ¨ë“œ ì›¹ - ë©€í‹°í„°ì¹˜ ì¤‘ì´ë¯€ë¡œ ì  ë“œë˜ê·¸ ë¬´ì‹œ');
      return;
    }
    
    // Shift í‚¤ê°€ ëˆŒë ¤ìˆê±°ë‚˜ ê·¸ë£¹ì´ ì„ íƒëœ ìƒíƒœì—ì„œ ëì  ê·¼ì²˜ì—ì„œ ì‹œì‘í•œ ê²½ìš° ê·¸ë£¹ ë“œë˜ê·¸ ì‹œì‘
    final isShiftPressed = HardwareKeyboard.instance.logicalKeysPressed.contains(LogicalKeyboardKey.shiftLeft) ||
                          HardwareKeyboard.instance.logicalKeysPressed.contains(LogicalKeyboardKey.shiftRight);
    
    // Shift í‚¤ë¥¼ ëˆ„ë¥¸ ìƒíƒœì—ì„œ ëì  ë“œë˜ê·¸ (ê¸°ì¡´ ê¸°ëŠ¥)
    if (isShiftPressed && startPoint != null) {
      print('Shift + ë“œë˜ê·¸ë¡œ ê·¸ë£¹ ì´ë™ ì‹œì‘: $startPoint');
      setState(() {
        isGroupDragging = true;
        groupDragStartPoint = startPoint;
        groupDragCurrentPoint = startPoint;
        draggedGroupLines = findConnectedLines(startPoint);
        
        // ì›ë˜ ìœ„ì¹˜ ì €ì¥
        originalLineStarts.clear();
        originalLineEnds.clear();
        for (int i in draggedGroupLines) {
          originalLineStarts[i] = lines[i].start;
          originalLineEnds[i] = lines[i].end;
        }
        
        _isPanning = false;
        _isScaling = false;
        isPointDragging = false;
      });
      
      HapticFeedback.selectionClick();
      return;
    }
    
    // ì  ê·¼ì²˜ì—ì„œ ì‹œì‘í•œ ê²½ìš°ì—ë§Œ ì  ë“œë˜ê·¸ ì‹œì‘ (ê·¸ë£¹ì´ ì„ íƒë˜ì§€ ì•Šì€ ê²½ìš°ì—ë§Œ)
    if (startPoint != null && selectedGroupLines.isEmpty && diagonalMode) {
      setState(() {
        isPointDragging = true;
        pointDragStart = startPoint;
        pointDragEnd = startPoint;
        _isPanning = false; // ì  ë“œë˜ê·¸ ì¤‘ì—ëŠ” í™”ë©´ ì´ë™ ë¹„í™œì„±í™”
        _isScaling = false; // ì  ë“œë˜ê·¸ ì¤‘ì—ëŠ” ìŠ¤ì¼€ì¼ ì œìŠ¤ì²˜ ë¹„í™œì„±í™”
        
        // ë‹¤ë¥¸ ì„ íƒ ìƒíƒœ ì´ˆê¸°í™”
        selectedLineIndex = -1;
        selectedCircleIndex = -1;
        hoveredLineIndex = null;
        // ì  ë“œë˜ê·¸ ì‹œì—ë§Œ selectedEndpoint ì´ˆê¸°í™” (ê·¸ë£¹ ë“œë˜ê·¸ì™€ ë¬´ê´€)
        selectedEndpoint = null;
        selectedEndpointLineIndex = null;
        selectedEndpointType = null;
      });
      
      // í–…í‹± í”¼ë“œë°±
      HapticFeedback.selectionClick();
      print('ì  ë“œë˜ê·¸ ì‹œì‘: $startPoint');
    } else {
      // ëì ì´ ì•„ë‹Œ ê³³ì„ í„°ì¹˜í•˜ë©´ í™”ë©´ ì´ë™ ì‹œì‘ (ëª¨ë“  í”Œë«í¼)
      setState(() {
        _isPanning = true;
        _lastPanPosition = position;
        isPointDragging = false;
      });
      print('í™”ë©´ ì´ë™ ì‹œì‘: $position (ì•„ì´íŒ¨ë“œ ì›¹: $isTablet)');
    }
  }
  
  void _handlePointDragUpdate(DragUpdateDetails details) {
    final position = details.localPosition;
    
    print('ë“œë˜ê·¸ ì—…ë°ì´íŠ¸ - isGroupDragging: $isGroupDragging, isPointDragging: $isPointDragging');
    
    if (isGroupDragging && groupDragStartPoint != null) {
      // ê·¸ë£¹ ë“œë˜ê·¸ ì²˜ë¦¬
      final currentModelPos = _screenToModel(position);
      final offset = currentModelPos - groupDragStartPoint!;
      
      print('ê·¸ë£¹ ë“œë˜ê·¸ ì¤‘ - offset: $offset');
      
      setState(() {
        groupDragCurrentPoint = currentModelPos;
        
        // ë“œë˜ê·¸ ì¤‘ì¸ ê·¸ë£¹ì˜ ëª¨ë“  ì„ ë“¤ì„ ì´ë™
        for (int i in draggedGroupLines) {
          if (originalLineStarts.containsKey(i) && originalLineEnds.containsKey(i)) {
            lines[i].start = originalLineStarts[i]! + offset;
            lines[i].end = originalLineEnds[i]! + offset;
          }
        }
        
        // ìŠ¤ëƒ… ëŒ€ìƒ ì°¾ê¸°
        groupSnapInfo = findNearestSnapPoint();
        if (groupSnapInfo != null) {
          print('ìŠ¤ëƒ… ëŒ€ìƒ ë°œê²¬: ${groupSnapInfo!['snapTarget']}');
          snapTargetPoint = groupSnapInfo!['snapTarget'];
        } else {
          snapTargetPoint = null;
        }
      });
    } else if (isPointDragging && pointDragStart != null) {
      // ì  ë“œë˜ê·¸ ì²˜ë¦¬
      final nearestPoint = _findNearestEndpoint(position);
      
      setState(() {
        if (nearestPoint != null) {
          // ê°€ê¹Œìš´ ì ì´ ìˆìœ¼ë©´ ìŠ¤ëƒ…
          pointDragEnd = nearestPoint;
        } else {
          // ì—†ìœ¼ë©´ í˜„ì¬ ìœ„ì¹˜
          pointDragEnd = _screenToModel(position);
        }
      });
    } else if (_isPanning && _lastPanPosition != null) {
      // í™”ë©´ ì´ë™ ì²˜ë¦¬
      final delta = position - _lastPanPosition!;
      setState(() {
        viewOffset = viewOffset + delta;
        _lastPanPosition = position;
      });
      print('í™”ë©´ ì´ë™: $delta, ìƒˆ viewOffset: $viewOffset');
    }
  }
  
  void _handlePointDragEnd(DragEndDetails details) {
    print('=== ë“œë˜ê·¸ ì¢…ë£Œ ===');
    
    if (isGroupDragging && groupDragStartPoint != null) {
      print('ê·¸ë£¹ ë“œë˜ê·¸ ì¢…ë£Œ ì²˜ë¦¬');
      
      // ìŠ¤ëƒ… ëŒ€ìƒì´ ìˆìœ¼ë©´ ê·¸ ìœ„ì¹˜ë¡œ ì •í™•íˆ ì´ë™
      if (groupSnapInfo != null) {
        final snapTarget = groupSnapInfo!['snapTarget'] as Offset;
        final groupPoint = groupSnapInfo!['groupPoint'] as Offset;
        
        // ìŠ¤ëƒ…ì„ ìœ„í•œ ì˜¤í”„ì…‹ ê³„ì‚°
        final snapOffset = snapTarget - groupPoint;
        
        setState(() {
          // ìµœì¢… ìœ„ì¹˜ë¡œ ì´ë™
          for (int i in draggedGroupLines) {
            lines[i].start = lines[i].start + snapOffset;
            lines[i].end = lines[i].end + snapOffset;
          }
        });
        
        // í–…í‹± í”¼ë“œë°±
        HapticFeedback.mediumImpact();
      }
      
      // ìƒíƒœ ì´ˆê¸°í™”
      setState(() {
        isGroupDragging = false;
        groupDragStartPoint = null;
        groupDragCurrentPoint = null;
        draggedGroupLines.clear();
        originalLineStarts.clear();
        originalLineEnds.clear();
        snapTargetPoint = null;
        groupSnapInfo = null;
      });
      
      _updateFirebase();
      saveState();
      return;
    }
    
    if (isPointDragging && pointDragStart != null && pointDragEnd != null) {
      print('ì  ë“œë˜ê·¸ ì¢…ë£Œ ì²˜ë¦¬');
    
      // ì‹œì‘ì ê³¼ ëì ì´ ê°™ìœ¼ë©´ ì·¨ì†Œ
      if (pointDragStart == pointDragEnd) {
        print('ì‹œì‘ì ê³¼ ëì ì´ ê°™ìŒ - ì  ë“œë˜ê·¸ ì·¨ì†Œ');
        _cancelPointDrag();
        return;
      }
      
      // ìµœì†Œ ê±°ë¦¬ ì²´í¬
      final distance = (pointDragEnd! - pointDragStart!).distance;
      if (distance < 10.0) {
        print('ê±°ë¦¬ê°€ ë„ˆë¬´ ì§§ìŒ ($distance) - ì  ë“œë˜ê·¸ ì·¨ì†Œ');
        _cancelPointDrag();
        return;
      }
      
      // ëì ì´ ìŠ¤ëƒ…ëœ ìœ„ì¹˜ì¸ì§€ í™•ì¸ (í—ˆê³µì— ë†“ìœ¼ë©´ ì·¨ì†Œ)
      final screenEndPoint = _modelToScreen(pointDragEnd!);
      final snapPoint = _findNearestEndpoint(screenEndPoint);
      
      if (snapPoint == null) {
        print('ëì ì´ ìŠ¤ëƒ… ìœ„ì¹˜ê°€ ì•„ë‹˜ - í—ˆê³µì— ë†“ìŒ, ì„  ìƒì„± ì·¨ì†Œ');
        _cancelPointDrag();
        return;
      }
      
      // ëì ì„ ìŠ¤ëƒ…ëœ ìœ„ì¹˜ë¡œ ë³´ì •
      pointDragEnd = snapPoint;
      
      // ì¼ë°˜ ì„  ìƒì„± (ëŒ€ê°ì„ ë„ ê°€ëŠ¥)
      saveState();
      setState(() {
        lines.add(Line(
          start: pointDragStart!,
          end: pointDragEnd!,
          openingType: pendingOpeningType,
          isDiagonal: true, // ì  ì—°ê²° ëª¨ë“œë¡œ ìƒì„±ëœ ì„ ì€ ëŒ€ê°ì„ ìœ¼ë¡œ í‘œì‹œ
        ));
        
        // í˜„ì¬ ì ì„ ëì ìœ¼ë¡œ ì´ë™
        currentPoint = pointDragEnd!;
        pendingOpeningType = null;
      });
      
      // ì„±ê³µ í–…í‹± í”¼ë“œë°±
      HapticFeedback.lightImpact();
      print('ì  ë“œë˜ê·¸ ì„  ìƒì„± ì™„ë£Œ - ê¸¸ì´: $distance');
      
      // ì  ì—°ê²° ì™„ë£Œ í›„ diagonalMode í•´ì œ
      setState(() {
        diagonalMode = false;
      });
      print('ì  ì—°ê²° ì™„ë£Œ - diagonalMode í•´ì œ');
      
      _updateFirebase();
      _resetPointDrag();
    } else if (_isPanning) {
      // í™”ë©´ ì´ë™ ì¢…ë£Œ ì²˜ë¦¬
      print('í™”ë©´ ì´ë™ ì¢…ë£Œ');
      setState(() {
        _isPanning = false;
        _lastPanPosition = null;
      });
    } else {
      // ì•„ë¬´ê²ƒë„ í•˜ì§€ ì•Šê³  ìˆì—ˆë‹¤ë©´ ìƒíƒœ ì´ˆê¸°í™”
      _cancelPointDrag();
    }
  }
  
  void _cancelPointDrag() {
    print('ì  ë“œë˜ê·¸ ì·¨ì†Œ');
    _resetPointDrag();
  }
  
  // ë„ë©´ì˜ ì¤‘ì‹¬ì„ ëª¨ë¸ ì¢Œí‘œë¡œ ê³„ì‚°
  Offset _getDrawingCenterModel() {
    if (lines.isEmpty && circles.isEmpty) {
      return Offset.zero;
    }

    // ëª¨ë“  ì„ ê³¼ ì›ì˜ ê²½ê³„ ê³„ì‚°
    double minX = double.infinity;
    double maxX = double.negativeInfinity;
    double minY = double.infinity;
    double maxY = double.negativeInfinity;

    // ì„ ë“¤ì˜ ê²½ê³„
    for (final line in lines) {
      minX = math.min(minX, math.min(line.start.dx, line.end.dx));
      maxX = math.max(maxX, math.max(line.start.dx, line.end.dx));
      minY = math.min(minY, math.min(line.start.dy, line.end.dy));
      maxY = math.max(maxY, math.max(line.start.dy, line.end.dy));
    }

    // ì›ë“¤ì˜ ê²½ê³„
    for (final circle in circles) {
      minX = math.min(minX, circle.center.dx - circle.radius);
      maxX = math.max(maxX, circle.center.dx + circle.radius);
      minY = math.min(minY, circle.center.dy - circle.radius);
      maxY = math.max(maxY, circle.center.dy + circle.radius);
    }

    // ë„ë©´ ì¤‘ì‹¬ ê³„ì‚° (ëª¨ë¸ ì¢Œí‘œ)
    return Offset((minX + maxX) / 2, (minY + maxY) / 2);
  }

  // 90ë„ ë‹¨ìœ„ë¡œ ìŠ¤ëƒ…í•˜ëŠ” í•¨ìˆ˜
  double _snapTo90Degrees(double angle) {
    // ë¼ë””ì•ˆì„ ë„ë¡œ ë³€í™˜
    double degrees = angle * 180 / math.pi;

    // ê°€ì¥ ê°€ê¹Œìš´ 90ë„ ë°°ìˆ˜ë¡œ ìŠ¤ëƒ…
    double snappedDegrees = (degrees / 90).round() * 90;

    // 360ë„ë¡œ ì •ê·œí™”
    snappedDegrees = snappedDegrees % 360;
    if (snappedDegrees < 0) snappedDegrees += 360;

    // ë‹¤ì‹œ ë¼ë””ì•ˆìœ¼ë¡œ ë³€í™˜
    return snappedDegrees * math.pi / 180;
  }
  
  // í™”ë©´ íšŒì „ì„ ê³ ë ¤í•œ ë°©í–¥ ë³€í™˜
  String _transformDirectionForRotation(String direction) {
    // í˜„ì¬ íšŒì „ ê°ë„ë¥¼ ë„ ë‹¨ìœ„ë¡œ ë³€í™˜
    double rotationDegrees = (viewRotation * 180 / math.pi) % 360;
    if (rotationDegrees < 0) rotationDegrees += 360;
    
    // 90ë„ ë‹¨ìœ„ë¡œ ë°˜ì˜¬ë¦¼
    int rotationSteps = ((rotationDegrees + 45) ~/ 90) % 4;
    
    // ë°©í–¥ ë³€í™˜ ë§¤í•‘
    const directions = ['Up', 'Right', 'Down', 'Left'];
    int directionIndex = directions.indexOf(direction);
    if (directionIndex == -1) return direction;
    
    // íšŒì „ì— ë”°ë¼ ë°©í–¥ ì¡°ì •
    int newIndex = (directionIndex + rotationSteps) % 4;
    return directions[newIndex];
  }
  
  void _resetPointDrag() {
    setState(() {
      isPointDragging = false;
      pointDragStart = null;
      pointDragEnd = null;
      _isScaling = false; // ì  ë“œë˜ê·¸ ì¢…ë£Œ ì‹œ ìŠ¤ì¼€ì¼ ì œìŠ¤ì²˜ ë‹¤ì‹œ í™œì„±í™”
    });
  }

  // ì„ íƒëœ ì„ ì˜ ê¸¸ì´ë¥¼ ë³€ê²½í•˜ëŠ” í•¨ìˆ˜ (ì—°ê²°ëœ ì„ ë“¤ë„ í•¨ê»˜ ì´ë™)
  void _resizeSelectedLine(double newLength) {
    if (selectedLineIndex < 0 || selectedLineIndex >= lines.length) {
      print('ìœ íš¨í•˜ì§€ ì•Šì€ ì„ íƒëœ ì„  ì¸ë±ìŠ¤: $selectedLineIndex');
      return;
    }
    
    final selectedLine = lines[selectedLineIndex];
    final currentLength = (selectedLine.end - selectedLine.start).distance;
    
    print('ì„ íƒëœ ì„  ê¸¸ì´ ë³€ê²½: $currentLength -> $newLength');
    
    // í˜„ì¬ ë°©í–¥ ë²¡í„° ê³„ì‚°
    final direction = selectedLine.end - selectedLine.start;
    final normalizedDirection = direction / currentLength;
    
    // ìƒˆë¡œìš´ ëì  ê³„ì‚°
    final newEnd = selectedLine.start + (normalizedDirection * newLength);
    
    // ëì  ì´ë™ëŸ‰ ê³„ì‚°
    final endPointOffset = newEnd - selectedLine.end;
    
    print('ëì  ì´ë™ëŸ‰: $endPointOffset');
    
    saveState();
    
    setState(() {
      // ì„ íƒëœ ì„  ì—…ë°ì´íŠ¸
      lines[selectedLineIndex] = Line(
        start: selectedLine.start,
        end: newEnd,
        openingType: selectedLine.openingType,
        isDiagonal: selectedLine.isDiagonal,
        connectedPoints: selectedLine.connectedPoints,
      );
      
      // ì—°ê²°ëœ ì„ ë“¤ ì°¾ê¸° ë° ì´ë™ (ëì  ê¸°ì¤€)
      _moveConnectedLines(selectedLineIndex, selectedLine.end, newEnd, {selectedLineIndex});
      
      // ì‹œì‘ì ê³¼ ì—°ê²°ëœ ì„ ë“¤ë„ í™•ì¸ (ì‹œì‘ì ì´ ì´ë™í•œ ê²½ìš°)
      if (selectedLine.start != lines[selectedLineIndex].start) {
        _moveConnectedLines(selectedLineIndex, selectedLine.start, lines[selectedLineIndex].start, {selectedLineIndex});
      }
      
      // í˜„ì¬ ì ì„ ìƒˆë¡œìš´ ëì ìœ¼ë¡œ ì´ë™
      currentPoint = newEnd;
    });
    
    _updateFirebase();
    
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text('ì„ íƒëœ ì„ ì˜ ê¸¸ì´ë¥¼ ${newLength.toInt()}í”½ì…€ë¡œ ë³€ê²½í–ˆìŠµë‹ˆë‹¤!'),
        duration: const Duration(seconds: 2),
        backgroundColor: const Color(0xFF238636),
      ),
    );
    
    print('ì„ íƒëœ ì„  ê¸¸ì´ ë³€ê²½ ì™„ë£Œ: ${selectedLine.start} -> $newEnd');
  }
  
  // ì—°ê²°ëœ ì„ ë“¤ì„ í•¨ê»˜ ì´ë™ì‹œí‚¤ëŠ” í•¨ìˆ˜ (ë¬´í•œ ë£¨í”„ ë°©ì§€)
  void _moveConnectedLines(int modifiedLineIndex, Offset oldPoint, Offset newPoint, Set<int> processedLines) {
    final offset = newPoint - oldPoint;
    
    print('ì—°ê²°ëœ ì„ ë“¤ ì´ë™ ì‹œì‘ - ê¸°ì¤€ ì„ : $modifiedLineIndex, ì´ë™ëŸ‰: $offset');
    
    // ì´ë™ëŸ‰ì´ ë„ˆë¬´ ì‘ìœ¼ë©´ ì²˜ë¦¬í•˜ì§€ ì•ŠìŒ
    if (offset.distance < 0.1) {
      print('ì´ë™ëŸ‰ì´ ë„ˆë¬´ ì‘ìŒ - ì²˜ë¦¬ ìƒëµ');
      return;
    }
    
    // ìˆ˜ì •ëœ ì„ ì˜ ì ê³¼ ì—°ê²°ëœ ì„ ë“¤ ì°¾ê¸°
    for (int i = 0; i < lines.length; i++) {
      if (i == modifiedLineIndex || processedLines.contains(i)) continue; // ìˆ˜ì •ëœ ì„ ê³¼ ì´ë¯¸ ì²˜ë¦¬ëœ ì„ ì€ ì œì™¸
      
      final line = lines[i];
      bool needsUpdate = false;
      Offset? newStart;
      Offset? newEnd;
      
      // ëŒ€ê°ì„ ì´ ì•„ë‹Œ ì—°ê²°ëœ ì„ ë“¤ ì²˜ë¦¬
      if (!line.isDiagonal) {
        // ì—°ê²° ì¡°ê±´ í™•ì¸ (ê±°ë¦¬ ê¸°ë°˜, 5í”½ì…€ ì´ë‚´)
        const connectionThreshold = 5.0;
        
        // í˜„ì¬ ì„ ì˜ ì‹œì‘ì ì´ ìˆ˜ì •ëœ ì ê³¼ ì—°ê²°ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸
        if ((line.start - oldPoint).distance < connectionThreshold) {
          newStart = line.start + offset;
          newEnd = line.end + offset;
          needsUpdate = true;
          print('ì—°ê²°ëœ ì„  ë°œê²¬ (ì‹œì‘ì  ì—°ê²°): ì¸ë±ìŠ¤ $i, ì „ì²´ ì´ë™');
        }
        // í˜„ì¬ ì„ ì˜ ëì ì´ ìˆ˜ì •ëœ ì ê³¼ ì—°ê²°ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸
        else if ((line.end - oldPoint).distance < connectionThreshold) {
          newStart = line.start;
          newEnd = line.end + offset;
          needsUpdate = true;
          print('ì—°ê²°ëœ ì„  ë°œê²¬ (ëì  ì—°ê²°): ì¸ë±ìŠ¤ $i, ëì ë§Œ ì´ë™');
        }
      }
      
      // ëŒ€ê°ì„  ì—°ê²° ì²˜ë¦¬
      if (line.isDiagonal && line.connectedPoints != null) {
        final startInfo = line.connectedPoints!['start'] as List<int>;
        final endInfo = line.connectedPoints!['end'] as List<int>;
        
        // ìˆ˜ì •ëœ ì„ ê³¼ ì—°ê²°ëœ ëŒ€ê°ì„ ì¸ì§€ í™•ì¸
        if (startInfo[0] == modifiedLineIndex || endInfo[0] == modifiedLineIndex) {
          // ëŒ€ê°ì„ ì˜ ì—°ê²°ì  ì—…ë°ì´íŠ¸
          if (startInfo[0] == modifiedLineIndex) {
            // ì‹œì‘ì ì´ ìˆ˜ì •ëœ ì„ ê³¼ ì—°ê²°ë¨
            if (startInfo[1] == 0) { // ì‹œì‘ì ê³¼ ì—°ê²°
              newStart = newPoint;
              newEnd = line.end;
              needsUpdate = true;
              print('ëŒ€ê°ì„  ì—°ê²° ì—…ë°ì´íŠ¸ (ì‹œì‘ì -ì‹œì‘ì ): ì¸ë±ìŠ¤ $i');
            } else if (startInfo[1] == 1) { // ëì ê³¼ ì—°ê²°
              newStart = newPoint;
              newEnd = line.end;
              needsUpdate = true;
              print('ëŒ€ê°ì„  ì—°ê²° ì—…ë°ì´íŠ¸ (ì‹œì‘ì -ëì ): ì¸ë±ìŠ¤ $i');
            }
          }
          
          if (endInfo[0] == modifiedLineIndex) {
            // ëì ì´ ìˆ˜ì •ëœ ì„ ê³¼ ì—°ê²°ë¨
            if (endInfo[1] == 0) { // ì‹œì‘ì ê³¼ ì—°ê²°
              newStart = line.start;
              newEnd = newPoint;
              needsUpdate = true;
              print('ëŒ€ê°ì„  ì—°ê²° ì—…ë°ì´íŠ¸ (ëì -ì‹œì‘ì ): ì¸ë±ìŠ¤ $i');
            } else if (endInfo[1] == 1) { // ëì ê³¼ ì—°ê²°
              newStart = line.start;
              newEnd = newPoint;
              needsUpdate = true;
              print('ëŒ€ê°ì„  ì—°ê²° ì—…ë°ì´íŠ¸ (ëì -ëì ): ì¸ë±ìŠ¤ $i');
            }
          }
        }
      }
      
      // ì„  ì—…ë°ì´íŠ¸
      if (needsUpdate && newStart != null && newEnd != null) {
        final oldLineStart = line.start;
        final oldLineEnd = line.end;
        
        lines[i] = Line(
          start: newStart,
          end: newEnd,
          openingType: line.openingType,
          isDiagonal: line.isDiagonal,
          connectedPoints: line.connectedPoints,
        );
        print('ì„  $i ì—…ë°ì´íŠ¸ ì™„ë£Œ: $newStart -> $newEnd');
        
        // ì²˜ë¦¬ëœ ì„  ëª©ë¡ì— ì¶”ê°€
        processedLines.add(i);
        
        // ì¬ê·€ì ìœ¼ë¡œ ì—°ê²°ëœ ì„ ë“¤ ì²˜ë¦¬ (ì‹œì‘ì ê³¼ ëì  ëª¨ë‘ í™•ì¸)
        if (oldLineStart != newStart) {
          _moveConnectedLines(i, oldLineStart, newStart, processedLines);
        }
        if (oldLineEnd != newEnd) {
          _moveConnectedLines(i, oldLineEnd, newEnd, processedLines);
        }
      }
    }
    
    print('ì—°ê²°ëœ ì„ ë“¤ ì´ë™ ì™„ë£Œ');
  }

  // ê°€ì¥ ê°€ê¹Œìš´ ëì  ì°¾ê¸°
  Offset? _findNearestEndpoint(Offset screenPosition) {
    // ëª¨ë°”ì¼/íƒœë¸”ë¦¿ì—ì„œëŠ” í„°ì¹˜ ì˜ì—­ì´ ë„“ìœ¼ë¯€ë¡œ toleranceë¥¼ í¬ê²Œ ì„¤ì •
    final tolerance = (isMobile || isTablet) ? 50.0 : 30.0;
    double minDist = double.infinity;
    Offset? closestPoint;
    
    print('\n=== ëì  ì°¾ê¸°: í„°ì¹˜ìœ„ì¹˜=$screenPosition, ì„ =${lines.length}ê°œ, tolerance=$tolerance ===');
    
    // ëì  ì¤‘ë³µ í™•ì¸ì„ ìœ„í•œ Set
    final Set<String> processedPoints = {};
    
    // ê¸°ì¡´ ì„ ì˜ ëì ë“¤ í™•ì¸
    for (int i = 0; i < lines.length; i++) {
      final line = lines[i];
      
      // ì‹œì‘ì  í™•ì¸
      final startKey = '${line.start.dx.toStringAsFixed(2)},${line.start.dy.toStringAsFixed(2)}';
      final startScreen = _modelToScreen(line.start);
      final dist1 = (screenPosition - startScreen).distance;
      if (!processedPoints.contains(startKey)) {
        processedPoints.add(startKey);
        if (dist1 < tolerance) {
          print('  ì„ [$i] ì‹œì‘ì : ê±°ë¦¬=$dist1 ${dist1 < minDist ? "âœ“ ì„ íƒë¨" : ""}');
          if (dist1 < minDist) {
            minDist = dist1;
            closestPoint = line.start;
          }
        }
      }
      
      // ëì  í™•ì¸
      final endKey = '${line.end.dx.toStringAsFixed(2)},${line.end.dy.toStringAsFixed(2)}';
      final endScreen = _modelToScreen(line.end);
      final dist2 = (screenPosition - endScreen).distance;
      if (!processedPoints.contains(endKey)) {
        processedPoints.add(endKey);
        if (dist2 < tolerance) {
          print('  ì„ [$i] ëì : ê±°ë¦¬=$dist2 ${dist2 < minDist ? "âœ“ ì„ íƒë¨" : ""}');
          if (dist2 < minDist) {
            minDist = dist2;
            closestPoint = line.end;
          }
        }
      }
    }
    
    // diagonalModeì¼ ë•Œë§Œ ì§êµì ë„ í™•ì¸
    if (diagonalMode && pointDragStart != null) {
      // ì§êµì ì€ ì ì‹œ ë¹„í™œì„±í™” (ë””ë²„ê¹…ì„ ìœ„í•´)
      // ì§êµì  ë¡œì§ì´ ì¼ë°˜ ëì  ì„ íƒì„ ë°©í•´í•  ìˆ˜ ìˆìŒ
    }
    
    print('ê²°ê³¼: ${closestPoint != null ? "ì  ì°¾ìŒ (ê±°ë¦¬=$minDist)" : "ì  ì—†ìŒ"}\n');
    
    return closestPoint;
  }
  
  // ì ì—ì„œ ì„ ìœ¼ë¡œì˜ ì§êµì  ì°¾ê¸°
  Offset? _findPerpendicularPoint(Offset point, Line line) {
    // ì„ ì˜ ë°©í–¥ ë²¡í„°
    final lineVec = line.end - line.start;
    final lineLength = lineVec.distance;
    
    if (lineLength == 0) return null;
    
    // ì •ê·œí™”ëœ ë°©í–¥ ë²¡í„°
    final lineDir = lineVec / lineLength;
    
    // ì ì—ì„œ ì„ ì˜ ì‹œì‘ì ê¹Œì§€ì˜ ë²¡í„°
    final pointVec = point - line.start;
    
    // ë‚´ì ì„ í†µí•´ íˆ¬ì˜ ê¸¸ì´ ê³„ì‚°
    final projLength = pointVec.dx * lineDir.dx + pointVec.dy * lineDir.dy;
    
    // íˆ¬ì˜ ê¸¸ì´ê°€ ì„ ì˜ ë²”ìœ„ ë‚´ì— ìˆëŠ”ì§€ í™•ì¸
    if (projLength < 0 || projLength > lineLength) return null;
    
    // ì§êµì  ê³„ì‚°
    final perpPoint = line.start + lineDir * projLength;
    
    // ì›ë˜ ì ê³¼ ì§êµì  ì‚¬ì´ì˜ ê±°ë¦¬ê°€ í•©ë¦¬ì ì¸ì§€ í™•ì¸
    final dist = (point - perpPoint).distance;
    if (dist > 500) return null; // ë„ˆë¬´ ë¨¼ ì§êµì ì€ ë¬´ì‹œ
    
    return perpPoint;
  }

  Map<String, dynamic>? _findEndpointNear(Offset position) {
    const tolerance = 20.0;
    double closestDist = double.infinity;
    Map<String, dynamic>? closestInfo;
    
    for (int i = 0; i < lines.length; i++) {
      final line = lines[i];
      
      final startScreen = _modelToScreen(line.start);
      final dist1 = (position - startScreen).distance;
      if (dist1 <= tolerance && dist1 < closestDist) {
        closestDist = dist1;
        closestInfo = {
          'index': i,
          'type': 'start',
          'point': line.start,
        };
      }
      
      final endScreen = _modelToScreen(line.end);
      final dist2 = (position - endScreen).distance;
      if (dist2 <= tolerance && dist2 < closestDist) {
        closestDist = dist2;
        closestInfo = {
          'index': i,
          'type': 'end',
          'point': line.end,
        };
      }
    }
    
    return closestInfo;
  }

  int? _findLineNear(Offset position) {
    const tolerance = 12.0;
    
    for (int i = 0; i < lines.length; i++) {
      final line = lines[i];
      final startScreen = _modelToScreen(line.start);
      final endScreen = _modelToScreen(line.end);
      
      final dist = _pointToLineDistance(position, startScreen, endScreen);
      if (dist <= tolerance) {
        return i;
      }
    }
    
    return null;
  }

  int? _findCircleNear(Offset position) {
    const tolerance = 15.0;
    
    for (int i = 0; i < circles.length; i++) {
      final circle = circles[i];
      final centerScreen = _modelToScreen(circle.center);
      final radiusScreen = circle.radius * viewScale;
      
      // ì›ì˜ ë‘˜ë ˆì™€ì˜ ê±°ë¦¬ ê³„ì‚°
      final distToCenter = (position - centerScreen).distance;
      final distToCircle = (distToCenter - radiusScreen).abs();
      
      if (distToCircle <= tolerance) {
        return i;
      }
    }
    
    return null;
  }

  double _pointToLineDistance(Offset p, Offset a, Offset b) {
    final lineLen = (b - a).distance;
    if (lineLen == 0) return (p - a).distance;
    
    final t = ((p - a).dx * (b - a).dx + (p - a).dy * (b - a).dy) / (lineLen * lineLen);
    final clampedT = t.clamp(0.0, 1.0);
    
    final projection = Offset(
      a.dx + clampedT * (b.dx - a.dx),
      a.dy + clampedT * (b.dy - a.dy),
    );
    
    return (p - projection).distance;
  }

  Offset _modelToScreen(Offset model) {
    // íšŒì „ ë³€í™˜ ì ìš©
    final cos = math.cos(viewRotation);
    final sin = math.sin(viewRotation);
    
    // íšŒì „ëœ ì¢Œí‘œ
    final rotatedX = model.dx * cos - model.dy * sin;
    final rotatedY = model.dx * sin + model.dy * cos;
    
    return Offset(
      viewOffset.dx + rotatedX * viewScale,
      viewOffset.dy - rotatedY * viewScale,
    );
  }

  Offset _screenToModel(Offset screen) {
    // í™”ë©´ ì¢Œí‘œë¥¼ ì¤‘ì‹¬ ê¸°ì¤€ìœ¼ë¡œ ë³€í™˜
    final translatedX = (screen.dx - viewOffset.dx) / viewScale;
    final translatedY = -(screen.dy - viewOffset.dy) / viewScale;
    
    // ì—­íšŒì „ ë³€í™˜ ì ìš©
    final cos = math.cos(-viewRotation);
    final sin = math.sin(-viewRotation);
    
    return Offset(
      translatedX * cos - translatedY * sin,
      translatedX * sin + translatedY * cos,
    );
  }

  Offset _getInlineInputPosition() {
    // ì› ëª¨ë“œì—ì„œ ì¤‘ì‹¬ì ì´ ì„¤ì •ëœ ê²½ìš°
    if (circleMode && circleCenter != null) {
      final centerScreen = _modelToScreen(circleCenter!);
      return Offset(
        centerScreen.dx + 20,  // ì¤‘ì‹¬ì  ìš°ì¸¡ìœ¼ë¡œ ì´ë™
        centerScreen.dy - 40,  // ìƒë‹¨ìœ¼ë¡œ ì´ë™
      );
    }
    
    // ì›ì´ ì„ íƒëœ ìƒíƒœì—ì„œ ë°©í–¥í‚¤ê°€ ì„¤ì •ëœ ê²½ìš° (ì› ì´ë™ ëª¨ë“œ)
    if (selectedCircleIndex >= 0 && selectedCircleIndex < circles.length && arrowDirection != null) {
      final circle = circles[selectedCircleIndex];
      final centerScreen = _modelToScreen(circle.center);
      return Offset(
        centerScreen.dx + 30,  // ì› ì¤‘ì‹¬ ìš°ì¸¡ìœ¼ë¡œ ì´ë™
        centerScreen.dy - 40,  // ìƒë‹¨ìœ¼ë¡œ ì´ë™
      );
    }
    
    if (selectedLineIndex >= 0 && selectedLineIndex < lines.length && arrowDirection == null) {
      final line = lines[selectedLineIndex];
      final startScreen = _modelToScreen(line.start);
      final endScreen = _modelToScreen(line.end);
      final midX = (startScreen.dx + endScreen.dx) / 2;
      final midY = (startScreen.dy + endScreen.dy) / 2;
      return Offset(midX - 30, midY - 60);
    }
    
    // í™”ì‚´í‘œê°€ í‘œì‹œë˜ëŠ” ê²½ìš° í™”ì‚´í‘œ ìš°ì¸¡ ìƒë‹¨ì— ìœ„ì¹˜
    final currentScreen = _modelToScreen(currentPoint);
    if (arrowDirection != null) {
      return Offset(
        currentScreen.dx + 30,  // í™”ì‚´í‘œ ìš°ì¸¡ìœ¼ë¡œ ì´ë™
        currentScreen.dy - 30,   // ìƒë‹¨ìœ¼ë¡œ ì´ë™
      );
    }
    
    // ê¸°ë³¸ ìœ„ì¹˜ (í˜„ì¬ ì  ìš°ì¸¡ ìƒë‹¨)
    return Offset(
      currentScreen.dx + 10,
      currentScreen.dy - 40,
    );
  }

  Offset _getNumberPadPopupPosition() {
    // í™”ë©´ í¬ê¸° ê°€ì ¸ì˜¤ê¸°
    final screenSize = MediaQuery.of(context).size;
    
    // ìˆ«ìí‚¤íŒ¨ë“œëŠ” ìš°í•˜ë‹¨ì— ìœ„ì¹˜ (margin 20px, íŒ¨ë“œ í¬ê¸° ì•½ 220px)
    // ìˆ«ìí‚¤íŒ¨ë“œ ìœ„ìª½ ì¤‘ì•™ì— íŒì—… ìœ„ì¹˜
    final numberPadCenterX = screenSize.width - 20 - 110; // ìš°ì¸¡ì—ì„œ 20px margin + íŒ¨ë“œ ì ˆë°˜ í¬ê¸°
    final numberPadTopY = screenSize.height - 120 - 200; // í•˜ë‹¨ì—ì„œ 120px margin + íŒ¨ë“œ ë†’ì´
    
    return Offset(numberPadCenterX, numberPadTopY - 20); // íŒ¨ë“œ ìœ„ìª½ 20px
  }

  Future<void> saveToDXF() async {
    if (lines.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('ì €ì¥í•  ì„ ì´ ì—†ìŠµë‹ˆë‹¤.'),
          backgroundColor: Color(0xFFD32F2F),
        ),
      );
      return;
    }

    try {
      final dxfContent = generateDXF();
      
      // í˜„ì¬ ë‚ ì§œë¡œ íŒŒì¼ëª… ìƒì„± (ë‚ ì§œ_HV LINE í˜•ì‹)
      final now = DateTime.now();
      final fileName = '${now.year}${now.month.toString().padLeft(2, '0')}${now.day.toString().padLeft(2, '0')}_HV LINE.dxf';
      
      // Blob ìƒì„± ë° ë‹¤ìš´ë¡œë“œ (DXF íŒŒì¼ìš© MIME íƒ€ì… ì‚¬ìš©)
      final bytes = Uint8List.fromList(dxfContent.codeUnits);
      final blob = html.Blob([bytes], 'application/dxf');
      final url = html.Url.createObjectUrlFromBlob(blob);
      
      final anchor = html.AnchorElement()
        ..href = url
        ..download = fileName
        ..style.display = 'none';
      
      html.document.body?.append(anchor);
      anchor.click();
      anchor.remove();
      
      html.Url.revokeObjectUrl(url);
      
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('DXF íŒŒì¼ì´ ë‹¤ìš´ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤: $fileName'),
          backgroundColor: const Color(0xFF0097A7),
          duration: const Duration(seconds: 3),
        ),
      );
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('íŒŒì¼ ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: $e'),
          backgroundColor: const Color(0xFFD32F2F),
        ),
      );
    }
  }

  String generateDXF() {
    final buffer = StringBuffer();
    
    if (lines.isEmpty) {
      return '';
    }
    
    // ì²« ë²ˆì§¸ ì„ ì˜ ì‹œì‘ì ì„ ì›ì ìœ¼ë¡œ ì„¤ì •
    final firstLine = lines.first;
    final originX = firstLine.start.dx;
    final originY = firstLine.start.dy;
    
    print('DXF ìƒì„± - ì²« ë²ˆì§¸ ì„ ì˜ ì‹œì‘ì ì„ ì›ì ìœ¼ë¡œ ì„¤ì •: ($originX, $originY)');
    
    // ìµœì†Œí•œì˜ DXF í—¤ë”
    buffer.writeln('0');
    buffer.writeln('SECTION');
    buffer.writeln('2');
    buffer.writeln('HEADER');
    buffer.writeln('9');
    buffer.writeln('\$ACADVER');
    buffer.writeln('1');
    buffer.writeln('AC1009');  // AutoCAD R12 - ê°€ì¥ í˜¸í™˜ì„± ë†’ì€ ë²„ì „
    buffer.writeln('0');
    buffer.writeln('ENDSEC');
    
    // ìµœì†Œí•œì˜ TABLES ì„¹ì…˜
    buffer.writeln('0');
    buffer.writeln('SECTION');
    buffer.writeln('2');
    buffer.writeln('TABLES');
    buffer.writeln('0');
    buffer.writeln('TABLE');
    buffer.writeln('2');
    buffer.writeln('LTYPE');
    buffer.writeln('70');
    buffer.writeln('1');
    buffer.writeln('0');
    buffer.writeln('LTYPE');
    buffer.writeln('2');
    buffer.writeln('CONTINUOUS');
    buffer.writeln('70');
    buffer.writeln('64');
    buffer.writeln('3');
    buffer.writeln('Solid line');
    buffer.writeln('72');
    buffer.writeln('65');
    buffer.writeln('73');
    buffer.writeln('0');
    buffer.writeln('40');
    buffer.writeln('0.0');
    buffer.writeln('0');
    buffer.writeln('ENDTAB');
    buffer.writeln('0');
    buffer.writeln('TABLE');
    buffer.writeln('2');
    buffer.writeln('LAYER');
    buffer.writeln('70');
    buffer.writeln('2'); // 2ê°œì˜ ë ˆì´ì–´
    // ê¸°ë³¸ ë ˆì´ì–´ (0)
    buffer.writeln('0');
    buffer.writeln('LAYER');
    buffer.writeln('2');
    buffer.writeln('0');
    buffer.writeln('70');
    buffer.writeln('0');
    buffer.writeln('62');
    buffer.writeln('7');
    buffer.writeln('6');
    buffer.writeln('CONTINUOUS');
    // WIN ë ˆì´ì–´ (ì°½ë¬¸ìš©)
    buffer.writeln('0');
    buffer.writeln('LAYER');
    buffer.writeln('2');
    buffer.writeln('WIN');
    buffer.writeln('70');
    buffer.writeln('0');
    buffer.writeln('62');
    buffer.writeln('4'); // cyan ìƒ‰ìƒ (ìƒ‰ìƒ ì½”ë“œ 4)
    buffer.writeln('6');
    buffer.writeln('CONTINUOUS');
    buffer.writeln('0');
    buffer.writeln('ENDTAB');
    buffer.writeln('0');
    buffer.writeln('ENDSEC');
    
    // ENTITIES ì„¹ì…˜
    buffer.writeln('0');
    buffer.writeln('SECTION');
    buffer.writeln('2');
    buffer.writeln('ENTITIES');
    
    // ì¢Œí‘œ ë³€í™˜: ì²« ë²ˆì§¸ ì„ ì˜ ì‹œì‘ì ì„ ì›ì ìœ¼ë¡œ ì´ë™ (ì‹¤ì œ í¬ê¸° ìœ ì§€)
    const double scale = 1.0; // 1:1 ìŠ¤ì¼€ì¼ (HV Lineì—ì„œ ê·¸ë¦° ê²ƒê³¼ ë™ì¼í•œ í¬ê¸°)
    
    for (final line in lines) {
      // ì²« ë²ˆì§¸ ì„ ì˜ ì‹œì‘ì ì„ ì›ì ìœ¼ë¡œ ì´ë™ í›„ ìŠ¤ì¼€ì¼ ì ìš©
      final startX = (line.start.dx - originX) * scale;
      final startY = (line.start.dy - originY) * scale;
      final endX = (line.end.dx - originX) * scale;
      final endY = (line.end.dy - originY) * scale;
      
      // ì°½ë¬¸ì¸ì§€ ì¼ë°˜ ì„ ì¸ì§€ì— ë”°ë¼ ë ˆì´ì–´ ê²°ì •
      final layerName = line.openingType == 'window' ? 'WIN' : '0';
      
      // ì„  ê·¸ë¦¬ê¸°
      buffer.writeln('0');
      buffer.writeln('LINE');
      buffer.writeln('8');
      buffer.writeln(layerName);  // ì°½ë¬¸ì€ WIN ë ˆì´ì–´, ì¼ë°˜ ì„ ì€ ê¸°ë³¸ ë ˆì´ì–´
      buffer.writeln('10');
      buffer.writeln(startX.toStringAsFixed(2));
      buffer.writeln('20');
      buffer.writeln(startY.toStringAsFixed(2));
      buffer.writeln('30');
      buffer.writeln('0.0');
      buffer.writeln('11');
      buffer.writeln(endX.toStringAsFixed(2));
      buffer.writeln('21');
      buffer.writeln(endY.toStringAsFixed(2));
      buffer.writeln('31');
      buffer.writeln('0.0');
      
      // ì°½ë¬¸ì¸ ê²½ìš° í‰í–‰ì„  ì¶”ê°€ ì œê±° - ë‹¨ì¼ ì„ ìœ¼ë¡œë§Œ ì €ì¥
    }
    
    // ì›ë“¤ ì¶œë ¥
    for (final circle in circles) {
      final centerX = (circle.center.dx - originX) * scale;
      final centerY = (circle.center.dy - originY) * scale;
      final radius = circle.radius * scale;
      
      buffer.writeln('0');
      buffer.writeln('CIRCLE');
      buffer.writeln('8');
      buffer.writeln('0');  // ê¸°ë³¸ ë ˆì´ì–´ ì‚¬ìš©
      buffer.writeln('10');
      buffer.writeln(centerX.toStringAsFixed(2));
      buffer.writeln('20');
      buffer.writeln(centerY.toStringAsFixed(2));
      buffer.writeln('30');
      buffer.writeln('0.0');
      buffer.writeln('40');
      buffer.writeln(radius.toStringAsFixed(2));
    }
    
    buffer.writeln('0');
    buffer.writeln('ENDSEC');
    buffer.writeln('0');
    buffer.writeln('EOF');
    
    return buffer.toString();
  }



  void toggleFullscreen() {
    try {
      if (isFullscreen) {
        // ì‚¬ìš©ìê°€ ì§ì ‘ ì „ì²´í™”ë©´ í•´ì œë¥¼ ìš”ì²­
        print('ì‚¬ìš©ì ìš”ì²­: ì „ì²´í™”ë©´ í•´ì œ');
        _userRequestedFullscreen = false;
        _exitFullscreen();
        
        // ì „ì²´í™”ë©´ í•´ì œ í”¼ë“œë°±
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: const Row(
              children: [
                Icon(Icons.fullscreen_exit, color: Color(0xFF9CDCFE), size: 16),
                SizedBox(width: 8),
                Text('ì „ì²´í™”ë©´ ëª¨ë“œê°€ í•´ì œë˜ì—ˆìŠµë‹ˆë‹¤.', style: TextStyle(color: Color(0xFFE6EDF3), fontSize: 13)),
              ],
            ),
            backgroundColor: const Color(0xFF161B22),
            behavior: SnackBarBehavior.floating,
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(8),
              side: const BorderSide(color: Color(0xFF30363D)),
            ),
            duration: const Duration(seconds: 2),
          ),
        );
      } else {
        // ì‚¬ìš©ìê°€ ì§ì ‘ ì „ì²´í™”ë©´ ì§„ì…ì„ ìš”ì²­
        print('ì‚¬ìš©ì ìš”ì²­: ì „ì²´í™”ë©´ ì§„ì…');
        _userRequestedFullscreen = true;
        _requestFullscreen();
        
        // ì „ì²´í™”ë©´ ì§„ì… í”¼ë“œë°±
        Future.delayed(const Duration(milliseconds: 500), () {
          if (mounted && isFullscreen) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: const Row(
                  children: [
                    Icon(Icons.fullscreen, color: Color(0xFF9CDCFE), size: 16),
                    SizedBox(width: 8),
                    Expanded(
                      child: Text(
                        'ì „ì²´í™”ë©´ ëª¨ë“œê°€ í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤. ESC í‚¤ë¡œ í•´ì œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.',
                        style: TextStyle(color: Color(0xFFE6EDF3), fontSize: 13),
                      ),
                    ),
                  ],
                ),
                backgroundColor: const Color(0xFF161B22),
                behavior: SnackBarBehavior.floating,
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(8),
                  side: const BorderSide(color: Color(0xFF30363D)),
                ),
                duration: const Duration(seconds: 3),
              ),
            );
          }
        });
      }
    } catch (e) {
      print('ì „ì²´í™”ë©´ í† ê¸€ ì˜¤ë¥˜: $e');
      
      // ì˜¤ë¥˜ í”¼ë“œë°±
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Row(
            children: [
              const Icon(Icons.error_outline, color: Color(0xFFCE9178), size: 16),
              const SizedBox(width: 8),
              Expanded(
                child: Text(
                  'ì „ì²´í™”ë©´ ëª¨ë“œ ì „í™˜ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: $e',
                  style: const TextStyle(color: Color(0xFFE6EDF3), fontSize: 13),
                ),
              ),
            ],
          ),
          backgroundColor: const Color(0xFF161B22),
          behavior: SnackBarBehavior.floating,
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(8),
            side: const BorderSide(color: Color(0xFF30363D)),
          ),
          duration: const Duration(seconds: 3),
        ),
      );
    }
  }

  void _requestFullscreen() {
    try {
      // ë‹¤ì–‘í•œ ì „ì²´í™”ë©´ API ì‹œë„ (ì•„ì´íŒ¨ë“œ í˜¸í™˜ì„±)
      final element = html.document.documentElement!;
      
      // í‘œì¤€ Fullscreen API
      if (element.requestFullscreen != null) {
        element.requestFullscreen();
        return;
      }
      
      // ì›¹í‚· (Safari/ì•„ì´íŒ¨ë“œ)
      final webkitElement = element as dynamic;
      if (webkitElement.webkitRequestFullscreen != null) {
        webkitElement.webkitRequestFullscreen();
        return;
      }
      
      // ëª¨ì§ˆë¼
      if (webkitElement.mozRequestFullScreen != null) {
        webkitElement.mozRequestFullScreen();
        return;
      }
      
      // MS Edge
      if (webkitElement.msRequestFullscreen != null) {
        webkitElement.msRequestFullscreen();
        return;
      }
      
      print('ì „ì²´í™”ë©´ APIë¥¼ ì§€ì›í•˜ì§€ ì•ŠëŠ” ë¸Œë¼ìš°ì €ì…ë‹ˆë‹¤.');
      
      // ì•„ì´íŒ¨ë“œì—ì„œ ì „ì²´í™”ë©´ì´ ì§€ì›ë˜ì§€ ì•ŠëŠ” ê²½ìš° ì‹œë®¬ë ˆì´ì…˜
      if (isMobile) {
        setState(() {
          isFullscreen = true;
        });
        _showFullscreenMessage();
      }
    } catch (e) {
      print('ì „ì²´í™”ë©´ ìš”ì²­ ì‹¤íŒ¨: $e');
      
      // í´ë°±: ëª¨ë°”ì¼ì—ì„œëŠ” ì‹œë®¬ë ˆì´ì…˜
      if (isMobile) {
        setState(() {
          isFullscreen = true;
        });
        _showFullscreenMessage();
      }
    }
  }

  void _exitFullscreen() {
    try {
      // í‘œì¤€ Fullscreen API
      if (html.document.exitFullscreen != null) {
        html.document.exitFullscreen();
        return;
      }
      
      // ì›¹í‚· (Safari/ì•„ì´íŒ¨ë“œ)
      final doc = html.document as dynamic;
      if (doc.webkitExitFullscreen != null) {
        doc.webkitExitFullscreen();
        return;
      }
      
      // ëª¨ì§ˆë¼
      if (doc.mozCancelFullScreen != null) {
        doc.mozCancelFullScreen();
        return;
      }
      
      // MS Edge
      if (doc.msExitFullscreen != null) {
        doc.msExitFullscreen();
        return;
      }
      
      // ì‹œë®¬ë ˆì´ì…˜ ëª¨ë“œ í•´ì œ
      if (isMobile) {
        setState(() {
          isFullscreen = false;
        });
      }
    } catch (e) {
      print('ì „ì²´í™”ë©´ í•´ì œ ì‹¤íŒ¨: $e');
      
      // í´ë°±
      if (isMobile) {
        setState(() {
          isFullscreen = false;
        });
      }
    }
  }

  void _showFullscreenMessage() {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Row(
          children: const [
            Icon(Icons.info_outline, color: Color(0xFF1F6FEB), size: 16),
            SizedBox(width: 8),
            Expanded(
              child: Text(
                'ì•„ì´íŒ¨ë“œì—ì„œëŠ” Safari ì„¤ì •ì—ì„œ "ì „ì²´í™”ë©´ ëª¨ë“œ"ë¥¼ í™œì„±í™”í•´ì£¼ì„¸ìš”.',
                style: TextStyle(color: Color(0xFFE6EDF3), fontSize: 13),
              ),
            ),
          ],
        ),
        backgroundColor: const Color(0xFF161B22),
        behavior: SnackBarBehavior.floating,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(8),
          side: const BorderSide(color: Color(0xFF30363D)),
        ),
        duration: const Duration(seconds: 4),
      ),
    );
  }

  void _setupFullscreenListener() {
    // í‘œì¤€ fullscreenchange ì´ë²¤íŠ¸
    html.document.onFullscreenChange.listen((_) {
      _handleFullscreenChange();
    });
    
    // ì›¹í‚· fullscreenchange ì´ë²¤íŠ¸ (Safari/ì•„ì´íŒ¨ë“œ)
    html.document.addEventListener('webkitfullscreenchange', (event) {
      _handleFullscreenChange();
    });
    
    // ëª¨ì§ˆë¼ fullscreenchange ì´ë²¤íŠ¸
    html.document.addEventListener('mozfullscreenchange', (event) {
      _handleFullscreenChange();
    });
    
    // MS Edge fullscreenchange ì´ë²¤íŠ¸
    html.document.addEventListener('msfullscreenchange', (event) {
      _handleFullscreenChange();
    });
  }

  void _handleFullscreenChange() {
    final newFullscreenState = _isCurrentlyFullscreen();
    
    // ë¸Œë¼ìš°ì €ì—ì„œ ì§ì ‘ ì „ì²´í™”ë©´ ì§„ì… ì‹œ ìë™ ì¸ì‹
    if (!_userRequestedFullscreen && newFullscreenState) {
      print('ë¸Œë¼ìš°ì €ì—ì„œ ì „ì²´í™”ë©´ ì§„ì… ê°ì§€ - ìë™ ë™ê¸°í™”');
      _userRequestedFullscreen = true;
    }
    
    // ì‚¬ìš©ìê°€ ìš”ì²­í•œ ì „ì²´í™”ë©´ ëª¨ë“œì—ì„œ ì˜ë„í•˜ì§€ ì•Šì€ í•´ì œ ë°©ì§€
    if (_userRequestedFullscreen && !newFullscreenState && !_isRecovering) {
      print('ì „ì²´í™”ë©´ ëª¨ë“œì—ì„œ ì˜ë„í•˜ì§€ ì•Šì€ í•´ì œ ê°ì§€ - ë³µêµ¬ ì‹œë„');
      _isRecovering = true;
      
      // ì•½ê°„ì˜ ì§€ì—° í›„ ë‹¤ì‹œ ì „ì²´í™”ë©´ ìš”ì²­ (ëª¨ë“  í”Œë«í¼)
      Future.delayed(const Duration(milliseconds: 150), () {
        if (_userRequestedFullscreen && !_isCurrentlyFullscreen()) {
          try {
            _requestFullscreen();
          } catch (e) {
            print('ì „ì²´í™”ë©´ ë³µêµ¬ ì‹¤íŒ¨: $e');
            // ë³µêµ¬ ì‹¤íŒ¨ ì‹œ ì‚¬ìš©ì ìš”ì²­ ìƒíƒœ ì´ˆê¸°í™”
            _userRequestedFullscreen = false;
          }
        }
        // ë³µêµ¬ ì‹œë„ ì™„ë£Œ
        _isRecovering = false;
      });
    }
    
    // ì‚¬ìš©ìê°€ ë¸Œë¼ìš°ì €ì—ì„œ ì§ì ‘ ì „ì²´í™”ë©´ í•´ì œ ì‹œ (ESC í‚¤ ë“±)
    // ë³µêµ¬ ì‹œë„ ì¤‘ì´ ì•„ë‹ ë•Œë§Œ ì‚¬ìš©ì ì˜ë„ë¡œ íŒë‹¨
    if (_userRequestedFullscreen && !newFullscreenState && isFullscreen && !_isRecovering) {
      print('ì‚¬ìš©ìê°€ ë¸Œë¼ìš°ì €ì—ì„œ ì „ì²´í™”ë©´ í•´ì œ');
      _userRequestedFullscreen = false;
    }
    
    setState(() {
      isFullscreen = newFullscreenState;
    });
  }

  bool _isCurrentlyFullscreen() {
    // ë‹¤ì–‘í•œ fullscreen API ì²´í¬
    final doc = html.document as dynamic;
    
    return html.document.fullscreenElement != null ||
           doc.webkitFullscreenElement != null ||
           doc.mozFullScreenElement != null ||
           doc.msFullscreenElement != null;
  }

  void toggleLineToWindow(int lineIndex) {
    if (lineIndex < 0 || lineIndex >= lines.length) return;
    
    saveState();
    
    setState(() {
      final line = lines[lineIndex];
      if (line.openingType == 'window') {
        // ì°½ë¬¸ì—ì„œ ì¼ë°˜ ë²½ìœ¼ë¡œ ë³€ê²½
        line.openingType = null;
      } else {
        // ì¼ë°˜ ë²½ì—ì„œ ì°½ë¬¸ìœ¼ë¡œ ë³€ê²½
        line.openingType = 'window';
      }
      
      // íŒì—… ë‹«ê¸°
      showLinePopup = false;
      selectedLineForPopup = null;
      linePopupPosition = null;
    });
    
    _updateFirebase();
  }

  void closeLinePopup() {
    setState(() {
      showLinePopup = false;
      selectedLineForPopup = null;
      linePopupPosition = null;
    });
  }

  void centerCurrentPoint() {
    print('centerCurrentPoint í˜¸ì¶œë¨ - currentPoint: $currentPoint');
    
    // í™”ë©´ í¬ê¸° ê°€ì ¸ì˜¤ê¸°
    final context = this.context;
    final screenSize = MediaQuery.of(context).size;
    
    // ìº”ë²„ìŠ¤ ì˜ì—­ ê³„ì‚° (UI ì œì™¸)
    final canvasWidth = screenSize.width;
    final canvasHeight = screenSize.height - 200; // ìƒë‹¨/í•˜ë‹¨ UI ê³ ë ¤
    
    // í™”ë©´ ì¤‘ì‹¬ ê³„ì‚°
    final screenCenterX = canvasWidth / 2;
    final screenCenterY = canvasHeight / 2;
    
    // currentPointê°€ í™”ë©´ ì¤‘ì‹¬ì— ì˜¤ë„ë¡ viewOffset ê³„ì‚°
    final newOffsetX = screenCenterX - (currentPoint.dx * viewScale);
    final newOffsetY = screenCenterY + (currentPoint.dy * viewScale); // Yì¶• ë°˜ì „ ê³ ë ¤
    
    setState(() {
      viewOffset = Offset(newOffsetX, newOffsetY);
    });
    
    print('í˜„ì¬ ì ì„ í™”ë©´ ì¤‘ì‹¬ìœ¼ë¡œ ì´ë™ - ìƒˆë¡œìš´ offset: ($newOffsetX, $newOffsetY)');
  }

  void fitViewToDrawing() {
    print('fitViewToDrawing ì‹œì‘ - ì„ : ${lines.length}ê°œ, ì›: ${circles.length}ê°œ');
    
    if (lines.isEmpty && circles.isEmpty) {
      // ì„ ê³¼ ì›ì´ ëª¨ë‘ ì—†ìœ¼ë©´ ê¸°ë³¸ ë·°ë¡œ ì„¤ì •
      print('ì„ /ì›ì´ ì—†ìŒ - ê¸°ë³¸ ë·° ì„¤ì •');
      setState(() {
        viewScale = 0.3;
        viewOffset = const Offset(500, 500);
      });
      print('ê¸°ë³¸ ë·° ì„¤ì • ì™„ë£Œ - ìŠ¤ì¼€ì¼: $viewScale, ì˜¤í”„ì…‹: $viewOffset');
      return;
    }

    // ëª¨ë“  ì„ ê³¼ ì›ì˜ ê²½ê³„ ê³„ì‚°
    double minX = double.infinity;
    double maxX = double.negativeInfinity;
    double minY = double.infinity;
    double maxY = double.negativeInfinity;

    // ì„ ë“¤ì˜ ê²½ê³„
    for (final line in lines) {
      // ì‹œì‘ì  í™•ì¸
      minX = math.min(minX, line.start.dx);
      maxX = math.max(maxX, line.start.dx);
      minY = math.min(minY, line.start.dy);
      maxY = math.max(maxY, line.start.dy);

      // ëì  í™•ì¸
      minX = math.min(minX, line.end.dx);
      maxX = math.max(maxX, line.end.dx);
      minY = math.min(minY, line.end.dy);
      maxY = math.max(maxY, line.end.dy);
    }
    
    // ì›ë“¤ì˜ ê²½ê³„
    for (final circle in circles) {
      minX = math.min(minX, circle.center.dx - circle.radius);
      maxX = math.max(maxX, circle.center.dx + circle.radius);
      minY = math.min(minY, circle.center.dy - circle.radius);
      maxY = math.max(maxY, circle.center.dy + circle.radius);
    }

    // ê²½ê³„ ë°•ìŠ¤ í¬ê¸° ê³„ì‚°
    final drawingWidth = maxX - minX;
    final drawingHeight = maxY - minY;
    final drawingCenterX = (minX + maxX) / 2;
    final drawingCenterY = (minY + maxY) / 2;

    print('Drawing bounds: ($minX, $minY) to ($maxX, $maxY)');
    print('Drawing size: ${drawingWidth} x ${drawingHeight}');
    print('Drawing center: ($drawingCenterX, $drawingCenterY)');

    // í™”ë©´ í¬ê¸° ê°€ì ¸ì˜¤ê¸°
    final context = this.context;
    final screenSize = MediaQuery.of(context).size;

    // ìŠ¤ì¼€ì¼ ê³„ì‚°ìš© ìº”ë²„ìŠ¤ í¬ê¸° (ì—¬ë°± ê³ ë ¤)
    final canvasWidth = screenSize.width - 100;
    final canvasHeight = screenSize.height - 300;

    // ì ì ˆí•œ ìŠ¤ì¼€ì¼ ê³„ì‚° (ë§¤ìš° ê¸´ ì„ ì´ ìˆì„ ë•Œë¥¼ ìœ„í•´ ì—¬ë°±ì„ ë™ì ìœ¼ë¡œ ì¡°ì •)
    final maxDimension = math.max(drawingWidth, drawingHeight);
    final marginFactor = maxDimension > 10000 ? 1.1 : 1.4; // í° ë„ë©´ì¼ ë•Œ ì—¬ë°± ì¤„ì„

    double scaleX = canvasWidth / (drawingWidth * marginFactor);
    double scaleY = canvasHeight / (drawingHeight * marginFactor);
    double optimalScale = math.min(scaleX, scaleY);

    // ìŠ¤ì¼€ì¼ ë²”ìœ„ ì œí•œ (ì ì • ë²”ìœ„ë¡œ ì¡°ì •)
    optimalScale = optimalScale.clamp(0.02, 2.0);

    // í™”ë©´ ì¤‘ì‹¬ ê³„ì‚° (ì‹¤ì œ í™”ë©´ í¬ê¸° ê¸°ì¤€)
    final screenCenterX = screenSize.width / 2;
    final screenCenterY = (screenSize.height - 350) / 2; // í•˜ë‹¨ UI ê³ ë ¤ (350px ìœ„ë¡œ)

    // ìƒˆë¡œìš´ ë·° ì˜¤í”„ì…‹ ê³„ì‚°
    final newOffsetX = screenCenterX - (drawingCenterX * optimalScale);
    final newOffsetY = screenCenterY + (drawingCenterY * optimalScale); // Yì¶• ë°˜ì „ ê³ ë ¤

    setState(() {
      viewScale = optimalScale;
      viewOffset = Offset(newOffsetX, newOffsetY);
    });

    print('Drawing size: ${drawingWidth.toStringAsFixed(1)} x ${drawingHeight.toStringAsFixed(1)}');
    print('Max dimension: ${maxDimension.toStringAsFixed(1)}, margin factor: ${marginFactor.toStringAsFixed(1)}');
    print('New scale: ${optimalScale.toStringAsFixed(4)} (${(optimalScale * 100).toStringAsFixed(1)}%)');
    print('New offset: (${newOffsetX.toStringAsFixed(1)}, ${newOffsetY.toStringAsFixed(1)})');
  }

  @override
  Widget build(BuildContext context) {
    // ì›¹ì—ì„œ ì¶”ê°€ ë·° ë§ì¶¤ ì²´í¬ (ë¹Œë“œ ì™„ë£Œ í›„)
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (_linesLoaded && _circlesLoaded && _currentPointLoaded && !_initialViewFitExecuted) {
        _checkInitialDataLoaded();
      }
    });
    
    return Scaffold(
      body: RawKeyboardListener(
        focusNode: _focusNode,
        autofocus: true,
        includeSemantics: false,
        onKey: (RawKeyEvent event) {
          if (event is RawKeyDownEvent) {
            if (showInlineInput) {
              if (event.logicalKey == LogicalKeyboardKey.escape) {
                cancelInlineInput();
                return;
              } else if (event.logicalKey == LogicalKeyboardKey.enter || 
                         event.logicalKey == LogicalKeyboardKey.numpadEnter) {
                confirmInlineInput();
                return;
              } else if (event.logicalKey == LogicalKeyboardKey.keyW) {
                final currentText = inlineController.text;
                setState(() {
                  pendingOpeningType = pendingOpeningType == 'window' ? null : 'window';
                });
                WidgetsBinding.instance.addPostFrameCallback((_) {
                  inlineController.text = currentText;
                  inlineController.selection = TextSelection.fromPosition(
                    TextPosition(offset: currentText.length),
                  );
                });
                return;
              } else if (event.logicalKey == LogicalKeyboardKey.arrowUp ||
                         event.logicalKey == LogicalKeyboardKey.arrowDown ||
                         event.logicalKey == LogicalKeyboardKey.arrowLeft ||
                         event.logicalKey == LogicalKeyboardKey.arrowRight) {
                if (selectedLineIndex < 0 || arrowDirection != null) {
                  String newDirection = '';
                  if (event.logicalKey == LogicalKeyboardKey.arrowUp) newDirection = 'Up';
                  else if (event.logicalKey == LogicalKeyboardKey.arrowDown) newDirection = 'Down';
                  else if (event.logicalKey == LogicalKeyboardKey.arrowLeft) newDirection = 'Left';
                  else if (event.logicalKey == LogicalKeyboardKey.arrowRight) newDirection = 'Right';
                  
                  setState(() {
                    inlineDirection = newDirection;
                    arrowDirection = newDirection;
                  });
                  
                  WidgetsBinding.instance.addPostFrameCallback((_) {
                    inlineFocus.requestFocus();
                    inlineController.selection = TextSelection.fromPosition(
                      TextPosition(offset: inlineController.text.length),
                    );
                  });
                }
                return;
              }
              return;
            }
            
            if (event.isControlPressed && event.logicalKey == LogicalKeyboardKey.keyZ) {
              undo();
                        } else if (event.logicalKey == LogicalKeyboardKey.delete || 
                       event.logicalKey == LogicalKeyboardKey.backspace) {
              if (showInlineInput && inlineController.text.isNotEmpty) {
                // ìˆ«ì ì…ë ¥ ì¤‘ì´ë©´ ë°±ìŠ¤í˜ì´ìŠ¤ ê¸°ëŠ¥ (ë§ˆì§€ë§‰ ë¬¸ì ì‚­ì œ)
                setState(() {
                  final currentText = inlineController.text;
                  if (currentText.isNotEmpty) {
                    inlineController.text = currentText.substring(0, currentText.length - 1);
                    inlineController.selection = TextSelection.fromPosition(
                      TextPosition(offset: inlineController.text.length),
                    );
                  }
                });
              } else {
                // ìˆ«ì ì…ë ¥ ì¤‘ì´ ì•„ë‹ˆë©´ ì„ /ì› ì‚­ì œ
                print('Delete í‚¤ ì²˜ë¦¬ - selectedLineIndex: $selectedLineIndex, selectedCircleIndex: $selectedCircleIndex');
                if (selectedCircleIndex >= 0) {
                  // ì„ íƒëœ ì›ì´ ìˆìœ¼ë©´ í•´ë‹¹ ì› ì‚­ì œ
                  print('Delete í‚¤: ì„ íƒëœ ì› ì‚­ì œ (ì¸ë±ìŠ¤: $selectedCircleIndex)');
                  deleteSelectedCircle();
                } else if (selectedLineIndex >= 0 && selectedLineIndex < lines.length) {
                  // ì„ íƒëœ ì„ ì´ ìˆìœ¼ë©´ í•´ë‹¹ ì„  ì‚­ì œ
                  print('Delete í‚¤: ì„ íƒëœ ì„  ì‚­ì œ (ì¸ë±ìŠ¤: $selectedLineIndex)');
                  deleteSelectedLine();
                } else if (circles.isNotEmpty) {
                  // ì„ íƒëœ ê²ƒì´ ì—†ê³  ì›ì´ ì¡´ì¬í•˜ë©´ ë§ˆì§€ë§‰ ì› ì‚­ì œ
                  print('Delete í‚¤: ë§ˆì§€ë§‰ ì› ì‚­ì œ');
                  deleteLastCircle();
                } else if (lines.isNotEmpty) {
                  // ì„ íƒëœ ê²ƒì´ ì—†ê³  ì„ ì´ ì¡´ì¬í•˜ë©´ ë§ˆì§€ë§‰ ì„  ì‚­ì œ
                  print('Delete í‚¤: ë§ˆì§€ë§‰ ì„  ì‚­ì œ');
                  deleteLastLine();
                }
              }
              // ë˜ëŒë¦¬ê¸° ê¸°ëŠ¥ ì œê±°
            } else if (event.logicalKey == LogicalKeyboardKey.arrowUp) {
              onDirectionKey('Up');
            } else if (event.logicalKey == LogicalKeyboardKey.arrowDown) {
              onDirectionKey('Down');
            } else if (event.logicalKey == LogicalKeyboardKey.arrowLeft) {
              onDirectionKey('Left');
            } else if (event.logicalKey == LogicalKeyboardKey.arrowRight) {
              onDirectionKey('Right');
            } else if (event.logicalKey == LogicalKeyboardKey.keyW) {
              setState(() {
                pendingOpeningType = pendingOpeningType == 'window' ? null : 'window';
              });
            } else if (event.logicalKey == LogicalKeyboardKey.escape) {
              if (showInlineInput) {
                cancelInlineInput();
              } else if (isFullscreen && _userRequestedFullscreen) {
                // ì „ì²´í™”ë©´ ëª¨ë“œì—ì„œ ESC í‚¤ë¡œ ì „ì²´í™”ë©´ í•´ì œ
                print('ESC í‚¤ë¡œ ì „ì²´í™”ë©´ í•´ì œ');
                toggleFullscreen();
              } else {
                setState(() {
                  pendingOpeningType = null;
                  selectedLineIndex = -1;
                  isPointDragging = false;
                  pointDragStart = null;
                  pointDragEnd = null;
                  circleMode = false;
                  circleCenter = null;
                  hoveredLineIndex = null;
                });
              }
            } else if (event.logicalKey == LogicalKeyboardKey.equal && 
                       (event.isControlPressed || event.isMetaPressed)) {
              setState(() {
                viewScale = (viewScale * 1.2).clamp(0.02, 2.0);
              });
            } else if (event.logicalKey == LogicalKeyboardKey.minus && 
                       (event.isControlPressed || event.isMetaPressed)) {
              setState(() {
                viewScale = (viewScale * 0.8).clamp(0.02, 2.0);
              });
            } else if (event.logicalKey == LogicalKeyboardKey.digit0 && 
                       (event.isControlPressed || event.isMetaPressed)) {
              fitViewToDrawing();
            } else if (event.logicalKey == LogicalKeyboardKey.tab) {
              if (lines.isEmpty) return;
              
              if (showInlineInput) {
                cancelInlineInput();
              }
              
              setState(() {
                selectedLineIndex = (selectedLineIndex + 1) % lines.length;
              });
            } else if (event.character != null && 
                      int.tryParse(event.character!) != null &&
                      !showInlineInput) {
              print('Number pressed: ${event.character}');
              
              // ë°©í–¥í‚¤ê°€ ì„¤ì •ë˜ì–´ ìˆìœ¼ë©´ ìƒˆ ì„  ê·¸ë¦¬ê¸° ëª¨ë“œ
              if (arrowDirection != null || inlineDirection.isNotEmpty) {
                print('ë°©í–¥í‚¤ ì„¤ì •ë¨ - ìƒˆ ì„  ê·¸ë¦¬ê¸° ëª¨ë“œ');
                setState(() {
                  showInlineInput = true;
                  inlineController.text = event.character!;
                });
                
                WidgetsBinding.instance.addPostFrameCallback((_) {
                  inlineFocus.requestFocus();
                  inlineController.selection = TextSelection.fromPosition(
                    TextPosition(offset: inlineController.text.length),
                  );
                });
              }
              // ì„ íƒëœ ì„ ì´ ìˆìœ¼ë©´ í•´ë‹¹ ì„  ê¸¸ì´ ìˆ˜ì • ëª¨ë“œ
              else if (selectedLineIndex >= 0) {
                print('ì„ íƒëœ ì„  ê¸¸ì´ ìˆ˜ì • ëª¨ë“œ');
                setState(() {
                  showInlineInput = true;
                  inlineController.text = event.character!;
                  final line = lines[selectedLineIndex];
                  final dx = line.end.dx - line.start.dx;
                  final dy = line.end.dy - line.start.dy;
                  
                  if (dx.abs() > dy.abs()) {
                    inlineDirection = dx > 0 ? 'Right' : 'Left';
                  } else {
                    inlineDirection = dy > 0 ? 'Up' : 'Down';
                  }
                  arrowDirection = null;
                });
                
                WidgetsBinding.instance.addPostFrameCallback((_) {
                  inlineFocus.requestFocus();
                  inlineController.selection = TextSelection.fromPosition(
                    TextPosition(offset: inlineController.text.length),
                  );
                });
              }
              // ì„ íƒëœ ì„ ì´ ì—†ê³  ì„ ì´ ì¡´ì¬í•˜ë©´ ë§ˆì§€ë§‰ ì„  ì„ íƒ
              else if (lines.isNotEmpty) {
                selectedLineIndex = lines.length - 1;
                print('ë§ˆì§€ë§‰ ì„  ìë™ ì„ íƒ: $selectedLineIndex');
                setState(() {
                  showInlineInput = true;
                  inlineController.text = event.character!;
                  final line = lines[selectedLineIndex];
                  final dx = line.end.dx - line.start.dx;
                  final dy = line.end.dy - line.start.dy;
                  
                  if (dx.abs() > dy.abs()) {
                    inlineDirection = dx > 0 ? 'Right' : 'Left';
                  } else {
                    inlineDirection = dy > 0 ? 'Up' : 'Down';
                  }
                  arrowDirection = null;
                });
                
                WidgetsBinding.instance.addPostFrameCallback((_) {
                  inlineFocus.requestFocus();
                  inlineController.selection = TextSelection.fromPosition(
                    TextPosition(offset: inlineController.text.length),
                  );
                });
              }
            }
          }
        },
        child: Column(
          children: [
            // ìƒë‹¨ ë©”ë‰´ë°” - Cursor ìŠ¤íƒ€ì¼
            Container(
              margin: const EdgeInsets.all(8),
              padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
              decoration: BoxDecoration(
                color: const Color(0xFF161B22),
                borderRadius: BorderRadius.circular(8),
                border: Border.all(
                  color: const Color(0xFF30363D),
                  width: 1,
                ),
                boxShadow: [
                  BoxShadow(
                    color: Colors.black.withOpacity(0.2),
                    blurRadius: 8,
                    offset: const Offset(0, 2),
                  ),
                ],
              ),
              child: Row(
                children: [
                  // ë¡œê³ /íƒ€ì´í‹€ (ëª¨ë°”ì¼ì—ì„œëŠ” ì™„ì „íˆ ìˆ¨ê¹€)
                  if (!isMobile) ...[
                    Container(
                      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                      decoration: BoxDecoration(
                        color: const Color(0xFF569CD6).withOpacity(0.1),
                        borderRadius: BorderRadius.circular(6),
                        border: Border.all(
                          color: const Color(0xFF569CD6).withOpacity(0.3),
                          width: 1,
                        ),
                      ),
                      child: Row(
                        children: [
                          const Icon(
                            Icons.architecture,
                            color: Color(0xFF569CD6), // Cursor íŒŒë€ìƒ‰
                            size: 18,
                          ),
                          const SizedBox(width: 8),
                          const Text(
                            'HV LINE',
                            style: TextStyle(
                              color: Color(0xFF569CD6), // Cursor íŒŒë€ìƒ‰
                              fontSize: 12,
                              fontWeight: FontWeight.w600,
                            ),
                          ),
                        ],
                      ),
                    ),
                    const SizedBox(width: 8),
                  ],
                  
                  // ë ˆì´ì•„ì›ƒ ì „í™˜ ë²„íŠ¼
                  _buildLayoutSwitchButton(),
                  
                  const SizedBox(width: 8),
                  
                  // í˜ì´ì§€ ì„ íƒ ë“œë¡­ë‹¤ìš´
                  _buildPageDropdown(),
                  
                  const Spacer(),
                  
                  const SizedBox(width: 8),
                  
                  // ëª¨ë“œ ë²„íŠ¼ë“¤
                  _buildCursorButtonWithWidget(
                    iconWidget: WindowIcon(
                      color: pendingOpeningType == 'window' ? Colors.white : const Color(0xFF569CD6),
                      size: 14,
                    ),
                    label: 'ì°½ë¬¸',
                    onPressed: () {
                      setState(() {
                        pendingOpeningType = pendingOpeningType == 'window' ? null : 'window';
                      });
                    },
                    color: const Color(0xFF569CD6), // Cursor íŒŒë€ìƒ‰
                    isPrimary: pendingOpeningType == 'window',
                  ),
                  
                  const SizedBox(width: 4),
                  
                  // ëŒ€ê°ì„ (ì ê³¼ ì  ì—°ê²°) ë²„íŠ¼
                  _buildCursorButtonWithWidget(
                    iconWidget: DiagonalDotsIcon(
                      color: diagonalMode ? Colors.white : const Color(0xFFDCDCAA),
                      size: 14,
                    ),
                    label: 'ì ì—°ê²°',
                    onPressed: () {
                      setState(() {
                        diagonalMode = !diagonalMode;
                        // ëŒ€ê°ì„  ëª¨ë“œ ì „í™˜ ì‹œ ë‹¤ë¥¸ ëª¨ë“œë“¤ ë¹„í™œì„±í™”
                        if (diagonalMode) {
                          circleMode = false;
                          circleCenter = null;
                        }
                        // ì  ë“œë˜ê·¸ ìƒíƒœ ì´ˆê¸°í™”
                        isPointDragging = false;
                        pointDragStart = null;
                        pointDragEnd = null;
                        hoveredLineIndex = null;
                      });
                    },
                    color: const Color(0xFFDCDCAA), // ì—°í•œ ë…¸ë€ìƒ‰
                    isPrimary: diagonalMode,
                  ),
                  
                  const SizedBox(width: 4),
                  
                  _buildCursorButton(
                    icon: Icons.circle_outlined,
                    label: 'ì›',
                    onPressed: () {
                            setState(() {
        circleMode = !circleMode;
        circleCenter = null;
        isPointDragging = false;
        pointDragStart = null;
        pointDragEnd = null;
        hoveredPoint = null;
        hoveredLineIndex = null;
      });
                    },
                    color: const Color(0xFFFF7043), // ì£¼í™©ìƒ‰
                    isPrimary: circleMode,
                  ),
                  
                  const SizedBox(width: 8),
                  
                  // ë©”ì¸ ì•¡ì…˜ ë²„íŠ¼ë“¤
                  
                  _buildCursorButton(
                    icon: Icons.center_focus_strong_rounded,
                    label: 'ë·° ë§ì¶¤',
                    onPressed: fitViewToDrawing,
                    color: const Color(0xFF569CD6), // Cursor íŒŒë€ìƒ‰
                  ),
                  
                  const SizedBox(width: 6),
                  
                  _buildCursorButton(
                    icon: Icons.undo_rounded,
                    label: 'ë˜ëŒë¦¬ê¸°',
                    onPressed: undo,
                    color: const Color(0xFFCE9178), // Cursor ì£¼í™©ìƒ‰
                  ),
                  
                  const SizedBox(width: 6),
                  
                  // ì´ˆê¸°í™” ë²„íŠ¼
                  _buildCursorButton(
                    icon: Icons.refresh_rounded,
                    label: 'ì´ˆê¸°í™”',
                    onPressed: reset,
                    color: const Color(0xFF9CDCFE), // Cursor ì—°í•œ íŒŒë€ìƒ‰
                  ),
                  
                  const SizedBox(width: 6),
                  
                  // ìŒì„± ì¸ì‹ ë²„íŠ¼ (ë¡œë”© ìƒíƒœ í¬í•¨)
                  _buildVoiceButton(),
                  
                  const SizedBox(width: 8),
                  
                  // DXF ì €ì¥ ë²„íŠ¼
                  _buildCursorButton(
                    icon: Icons.save_alt_rounded,
                    label: 'DXF ì €ì¥',
                    onPressed: saveToDXF,
                    color: const Color(0xFF6A9955), // Cursor ì´ˆë¡ìƒ‰
                    isPrimary: true,
                  ),
                ],
              ),
            ),
            
            
            // ìº”ë²„ìŠ¤ (ì „ì²´ í™”ë©´)
            Expanded(
              child: Stack(
                children: [
                  Listener(
                    onPointerSignal: (pointerSignal) {
                      if (pointerSignal is PointerScrollEvent) {
                        setState(() {
                          final delta = pointerSignal.scrollDelta.dy;
                          final scaleFactor = delta > 0 ? 0.9 : 1.1;
                          
                          final pointerPos = pointerSignal.localPosition;
                                    final beforeScale = viewScale;
          viewScale = (viewScale * scaleFactor).clamp(0.02, 2.0);
          
          final scaleChange = viewScale / beforeScale;
                          viewOffset = Offset(
                            pointerPos.dx - (pointerPos.dx - viewOffset.dx) * scaleChange,
                            pointerPos.dy - (pointerPos.dy - viewOffset.dy) * scaleChange,
                          );
                        });
                      }
                    },
                    child: GestureDetector(
                      // ëª¨ë“  ë“œë˜ê·¸/ìŠ¤ì¼€ì¼ ì œìŠ¤ì²˜ë¥¼ scaleë¡œ í†µí•© ì²˜ë¦¬
                      onScaleStart: (details) {
                        print('Scale start - í„°ì¹˜ í¬ì¸íŠ¸ ìˆ˜: ${details.pointerCount}');
                        
                        // í•œ ì†ê°€ë½ ì œìŠ¤ì²˜ì¸ ê²½ìš°
                        if (details.pointerCount == 1) {
                          // ê·¸ë£¹ ì„ íƒ ì‹œ ë“œë˜ê·¸ ì²˜ë¦¬
                          if (selectedGroupLines.isNotEmpty) {
                            _handlePointDragStart(DragStartDetails(
                              localPosition: details.localFocalPoint,
                              globalPosition: details.focalPoint,
                            ));
                            return;
                          }
                          // ëŒ€ê°ì„  ëª¨ë“œ ë“œë˜ê·¸ ì²˜ë¦¬
                          else if (diagonalMode && !circleMode) {
                            print('ëŒ€ê°ì„  ëª¨ë“œ - onScaleStartì—ì„œ _handlePointDragStart í˜¸ì¶œ');
                            print('details.focalPoint: ${details.focalPoint}');
                            print('details.localFocalPoint: ${details.localFocalPoint}');
                            _handlePointDragStart(DragStartDetails(
                              localPosition: details.localFocalPoint,
                              globalPosition: details.focalPoint,
                            ));
                            return;
                          }
                          // ì› ëª¨ë“œ ì²˜ë¦¬
                          else if (circleMode) {
                            _handleCirclePanStart(DragStartDetails(
                              localPosition: details.localFocalPoint,
                              globalPosition: details.focalPoint,
                            ));
                            return;
                          }
                        }
                        
                        // ê¸°ë³¸ ìŠ¤ì¼€ì¼ ì²˜ë¦¬
                        setState(() {
                          _isScaling = true;
                          _isPanning = false;
                          _touchCount = details.pointerCount;
                          
                          // ì•„ì´íŒ¨ë“œ ì›¹ì—ì„œ í•œ ì†ê°€ë½ ì œìŠ¤ì²˜ì¸ ê²½ìš°
                          if (details.pointerCount == 1 && isTablet) {
                            print('ì•„ì´íŒ¨ë“œ ì›¹ - í•œ ì†ê°€ë½ ì œìŠ¤ì²˜ ì‹œì‘');
                            _isScaling = false;
                          }
                        });
                        panStartOffset = viewOffset;
                        zoomStartScale = viewScale;
                        _initialScale = viewScale;
                        _initialRotation = viewRotation;
                        dragStartPos = details.focalPoint;

                        // ë„ë©´ì˜ ì¤‘ì‹¬(ëª¨ë¸ ì¢Œí‘œ)ì„ ì €ì¥
                        _rotationCenterModel = _getDrawingCenterModel();
                        // í˜„ì¬ í™”ë©´ì—ì„œì˜ ìœ„ì¹˜ ê³„ì‚°
                        _rotationCenterScreen = _modelToScreen(_rotationCenterModel!);

                        print('ì•„ì´íŒ¨ë“œ ì œìŠ¤ì²˜ ì‹œì‘ - ì´ˆê¸° ìŠ¤ì¼€ì¼: ${_initialScale.toStringAsFixed(2)}, ì´ˆê¸° íšŒì „: ${(_initialRotation * 180 / math.pi).toStringAsFixed(1)}Â°, íšŒì „ ì¤‘ì‹¬(ëª¨ë¸): $_rotationCenterModel, íšŒì „ ì¤‘ì‹¬(í™”ë©´): $_rotationCenterScreen, í„°ì¹˜ ìˆ˜: ${details.pointerCount}');
                      },
                      onScaleUpdate: (details) {
                        // ë“œë˜ê·¸ ì¤‘ì¸ ê²½ìš° ì²˜ë¦¬
                        if (isPointDragging || isGroupDragging || _isPanning) {
                          _handlePointDragUpdate(DragUpdateDetails(
                            localPosition: details.localFocalPoint,
                            globalPosition: details.focalPoint,
                            delta: details.focalPointDelta,
                          ));
                          return;
                        }
                        setState(() {
                          // ì•„ì´íŒ¨ë“œ ì›¹ ì œìŠ¤ì²˜ ê°œì„  - ë” ëª…í™•í•œ ë¶„ë¦¬
                          final scaleThreshold = isTablet ? 0.03 : 0.05; // ì•„ì´íŒ¨ë“œì—ì„œ ë” ë¯¼ê°í•˜ê²Œ
                          final scaleDelta = (details.scale - 1.0).abs();
                          final pointerCount = details.pointerCount;
                          
                          print('ì œìŠ¤ì²˜ ì—…ë°ì´íŠ¸: scale=${details.scale.toStringAsFixed(3)}, delta=${scaleDelta.toStringAsFixed(3)}, pointers=$pointerCount, isTablet=$isTablet');
                          
                          if (pointerCount >= 2 && scaleDelta > scaleThreshold) {
                                        // ë‘ ì†ê°€ë½ í•€ì¹˜ ì¤Œ (ëª…í™•í•œ ë‘ ì†ê°€ë½ ì œìŠ¤ì²˜)
            final newScale = (_initialScale * details.scale).clamp(0.02, 2.0);
                            final scaleChange = newScale / viewScale;
                            
                            // ì¤Œ ì¤‘ì‹¬ì ì„ ê¸°ì¤€ìœ¼ë¡œ ìŠ¤ì¼€ì¼ ì¡°ì •
                            final focalPoint = details.focalPoint;
                            viewOffset = Offset(
                              focalPoint.dx - (focalPoint.dx - viewOffset.dx) * scaleChange,
                              focalPoint.dy - (focalPoint.dy - viewOffset.dy) * scaleChange,
                            );
                            
                            viewScale = newScale;

                            // íšŒì „ ì²˜ë¦¬ - ë„ë©´ ì¤‘ì‹¬ì„ í™”ë©´ì— ê³ ì •
                            viewRotation = _initialRotation - details.rotation;

                            // ëª¨ë¸ ì¢Œí‘œì˜ ì¤‘ì‹¬ì ì´ í™”ë©´ì˜ ê°™ì€ ìœ„ì¹˜ì— ìœ ì§€ë˜ë„ë¡ viewOffset ì¡°ì •
                            if (_rotationCenterModel != null && _rotationCenterScreen != null) {
                              // íšŒì „ í›„ ëª¨ë¸ ì¤‘ì‹¬ì ì˜ ìƒˆë¡œìš´ í™”ë©´ ì¢Œí‘œ ê³„ì‚°
                              final cos = math.cos(viewRotation);
                              final sin = math.sin(viewRotation);
                              final rotatedX = _rotationCenterModel!.dx * cos - _rotationCenterModel!.dy * sin;
                              final rotatedY = _rotationCenterModel!.dx * sin + _rotationCenterModel!.dy * cos;

                              // viewOffsetì„ ì¡°ì •í•˜ì—¬ ì¤‘ì‹¬ì ì´ ì›ë˜ í™”ë©´ ìœ„ì¹˜ì— ìœ ì§€ë˜ë„ë¡
                              viewOffset = Offset(
                                _rotationCenterScreen!.dx - rotatedX * viewScale,
                                _rotationCenterScreen!.dy + rotatedY * viewScale,
                              );
                            }

                            print('ì•„ì´íŒ¨ë“œ í•€ì¹˜ ì¤Œ: ${viewScale.toStringAsFixed(2)}x, ìŠ¤ì¼€ì¼: ${details.scale.toStringAsFixed(2)}, íšŒì „: ${(viewRotation * 180 / math.pi).toStringAsFixed(0)}Â°');
                          } else if (pointerCount == 1 && scaleDelta <= scaleThreshold) {
                            // í•œ ì†ê°€ë½ íŒ¬ (í™”ë©´ ì´ë™)
                            final deltaX = details.focalPoint.dx - dragStartPos!.dx;
                            final deltaY = details.focalPoint.dy - dragStartPos!.dy;
                            
                            // ìµœì†Œ ì´ë™ ê±°ë¦¬ ì²´í¬ (ë„ˆë¬´ ì‘ì€ ì›€ì§ì„ì€ ë¬´ì‹œ)
                            final minMovement = isTablet ? 3.0 : 2.0;
                            if (deltaX.abs() > minMovement || deltaY.abs() > minMovement) {
                              viewOffset = Offset(
                                panStartOffset!.dx + deltaX,
                                panStartOffset!.dy + deltaY,
                              );
                              print('ì•„ì´íŒ¨ë“œ í™”ë©´ ì´ë™: ${viewOffset.dx.toStringAsFixed(1)}, ${viewOffset.dy.toStringAsFixed(1)}');
                            }
                          } else if (pointerCount >= 2 && scaleDelta <= scaleThreshold) {
                            // ë‘ ì†ê°€ë½ì´ì§€ë§Œ ìŠ¤ì¼€ì¼ ë³€í™”ê°€ ì—†ëŠ” ê²½ìš° - íšŒì „ ë˜ëŠ” ë‘ ì†ê°€ë½ íŒ¬
                            final deltaX = details.focalPoint.dx - dragStartPos!.dx;
                            final deltaY = details.focalPoint.dy - dragStartPos!.dy;
                            
                            viewOffset = Offset(
                              panStartOffset!.dx + deltaX,
                              panStartOffset!.dy + deltaY,
                            );
                            
                            // íšŒì „ ì²˜ë¦¬ - ë„ë©´ ì¤‘ì‹¬ì„ í™”ë©´ì— ê³ ì •
                            viewRotation = _initialRotation - details.rotation;

                            // ëª¨ë¸ ì¢Œí‘œì˜ ì¤‘ì‹¬ì ì´ í™”ë©´ì˜ ê°™ì€ ìœ„ì¹˜ì— ìœ ì§€ë˜ë„ë¡ viewOffset ì¡°ì •
                            if (_rotationCenterModel != null && _rotationCenterScreen != null) {
                              // íšŒì „ í›„ ëª¨ë¸ ì¤‘ì‹¬ì ì˜ ìƒˆë¡œìš´ í™”ë©´ ì¢Œí‘œ ê³„ì‚°
                              final cos = math.cos(viewRotation);
                              final sin = math.sin(viewRotation);
                              final rotatedX = _rotationCenterModel!.dx * cos - _rotationCenterModel!.dy * sin;
                              final rotatedY = _rotationCenterModel!.dx * sin + _rotationCenterModel!.dy * cos;

                              // viewOffsetì„ ì¡°ì •í•˜ì—¬ ì¤‘ì‹¬ì ì´ ì›ë˜ í™”ë©´ ìœ„ì¹˜ì— ìœ ì§€ë˜ë„ë¡
                              viewOffset = Offset(
                                _rotationCenterScreen!.dx - rotatedX * viewScale,
                                _rotationCenterScreen!.dy + rotatedY * viewScale,
                              );
                            }

                            print('ì•„ì´íŒ¨ë“œ ë‘ ì†ê°€ë½ íŒ¬/íšŒì „: ìœ„ì¹˜(${viewOffset.dx.toStringAsFixed(1)}, ${viewOffset.dy.toStringAsFixed(1)}), íšŒì „: ${(viewRotation * 180 / math.pi).toStringAsFixed(0)}Â°');
                          }
                        });
                      },
                      onScaleEnd: (details) {
                        // ë“œë˜ê·¸ ì¢…ë£Œ ì²˜ë¦¬
                        if (isPointDragging || isGroupDragging || _isPanning) {
                          _handlePointDragEnd(DragEndDetails());
                          return;
                        }
                        print('Scale end - ìµœì¢… ìŠ¤ì¼€ì¼: ${viewScale.toStringAsFixed(2)}, í„°ì¹˜ ìˆ˜: $_touchCount');

                        // ì œìŠ¤ì²˜ ì¢…ë£Œ ì‹œ íšŒì „ ê°ë„ë¥¼ 90ë„ ë‹¨ìœ„ë¡œ ìŠ¤ëƒ…
                        setState(() {
                          viewRotation = _snapTo90Degrees(viewRotation);
                          print('íšŒì „ ì¢…ë£Œ - 90ë„ë¡œ ìŠ¤ëƒ…: ${(viewRotation * 180 / math.pi).toStringAsFixed(0)}Â°');
                        });

                        // ì•„ì´íŒ¨ë“œ ì›¹ì—ì„œ ì œìŠ¤ì²˜ ì¢…ë£Œ ì²˜ë¦¬ ê°œì„ 
                        if (isTablet) {
                          // ì•„ì´íŒ¨ë“œì—ì„œëŠ” ì¦‰ì‹œ ìƒíƒœ ë¦¬ì…‹
                          setState(() {
                            _isScaling = false;
                            _touchCount = 0;
                            _isPanning = false;
                          });
                        } else {
                          // ë‹¤ë¥¸ í”Œë«í¼ì—ì„œëŠ” ê¸°ì¡´ ë”œë ˆì´ ìœ ì§€
                          Future.delayed(const Duration(milliseconds: 150), () {
                            if (mounted) {
                              setState(() {
                                _isScaling = false;
                                _touchCount = 0;
                                _isPanning = false;
                              });
                            }
                          });
                        }
                      },
                      
                      onTap: () {
                        print('onTap í˜¸ì¶œë¨ - _lastTapPosition: $_lastTapPosition');
                        print('í˜„ì¬ ëª¨ë“œ - isPointDragging: $isPointDragging, circle: $circleMode, scaling: $_isScaling');
                        
                        // ìŠ¤ì¼€ì¼ ì œìŠ¤ì²˜ ì¤‘ì´ê±°ë‚˜ ì  ë“œë˜ê·¸ ì¤‘ì´ë©´ íƒ­ ì´ë²¤íŠ¸ ë¬´ì‹œ
                        if (_isScaling || isPointDragging) {
                          print('ìŠ¤ì¼€ì¼ ì œìŠ¤ì²˜ ì¤‘ ë˜ëŠ” ì  ë“œë˜ê·¸ ì¤‘ - onTap ë¬´ì‹œ');
                          return;
                        }
                        
                        // ë°ìŠ¤í¬í†±ì—ì„œë§Œ onTap ì‚¬ìš© (ëª¨ë°”ì¼/íƒœë¸”ë¦¿ì€ onTapDownì—ì„œ ì²˜ë¦¬)
                        if (!isMobile && !isTablet) {
                          if (_lastTapPosition == null) {
                            print('ë°ìŠ¤í¬í†±: _lastTapPositionì´ null - onTapDownì´ ë¨¼ì € í˜¸ì¶œë˜ì§€ ì•ŠìŒ');
                            return;
                          }
                          
                          // ì¤‘ë³µ í„°ì¹˜ ë°©ì§€ (100ms ì´ë‚´ ì¤‘ë³µ í„°ì¹˜ ë¬´ì‹œ)
                          final now = DateTime.now();
                          if (_lastTapTime != null && 
                              now.difference(_lastTapTime!).inMilliseconds < 100) {
                            print('ì¤‘ë³µ í„°ì¹˜ ê°ì§€ - ë¬´ì‹œ');
                            return;
                          }
                          
                          print('ë°ìŠ¤í¬í†±ì—ì„œ onTap ì²˜ë¦¬ - circleMode: $circleMode, ìœ„ì¹˜: $_lastTapPosition');
                          _handleTap(_lastTapPosition!);
                          _focusNode.requestFocus();
                        }
                      },
                      onTapDown: (details) {
                        print('onTapDown í˜¸ì¶œë¨ - ìœ„ì¹˜: ${details.localPosition}');
                        
                        // ì  ë“œë˜ê·¸ ì¤‘ì´ë©´ ë¬´ì‹œ
                        if (isPointDragging) {
                          print('ì  ë“œë˜ê·¸ ì¤‘ - onTapDown ë¬´ì‹œ');
                          return;
                        }
                        
                        // ëª¨ë°”ì¼/íƒœë¸”ë¦¿ì—ì„œ ì› ëª¨ë“œì¼ ë•ŒëŠ” ì¦‰ì‹œ ì²˜ë¦¬
                        if ((isMobile || isTablet) && circleMode) {
                          print('ëª¨ë°”ì¼/íƒœë¸”ë¦¿ ì› ëª¨ë“œì—ì„œ onTapDown ì¦‰ì‹œ ì²˜ë¦¬');
                          // ìŠ¤ì¼€ì¼ ì œìŠ¤ì²˜ ì¤‘ì´ë©´ ë¬´ì‹œ
                          if (_isScaling) {
                            print('ìŠ¤ì¼€ì¼ ì œìŠ¤ì²˜ ì¤‘ - onTapDown ë¬´ì‹œ');
                            return;
                          }
                          
                          // ì¤‘ë³µ í„°ì¹˜ ë°©ì§€ (ì´ì „ í„°ì¹˜ì™€ í˜„ì¬ í„°ì¹˜ ë¹„êµ)
                          final now = DateTime.now();
                          if (_lastTapTime != null && 
                              now.difference(_lastTapTime!).inMilliseconds < 300) {
                            print('ì¤‘ë³µ í„°ì¹˜ ê°ì§€ (300ms ì´ë‚´) - ë¬´ì‹œ');
                            return;
                          }
                          
                          // í„°ì¹˜ ìœ„ì¹˜ì™€ ì‹œê°„ ì €ì¥ (ì²˜ë¦¬ ì§ì „ì—)
                          setState(() {
                            _lastTapPosition = details.localPosition;
                            _lastTapTime = now;
                          });
                          
                          print('ëª¨ë°”ì¼/íƒœë¸”ë¦¿ ì› ëª¨ë“œ í„°ì¹˜ ì²˜ë¦¬ ì‹¤í–‰');
                          _handleTap(details.localPosition);
                          _focusNode.requestFocus();
                        } else {
                          // ì¼ë°˜ ëª¨ë“œ ë° ë°ìŠ¤í¬í†± ì› ëª¨ë“œì—ì„œëŠ” í„°ì¹˜ ìœ„ì¹˜ì™€ ì‹œê°„ë§Œ ì €ì¥
                          final now = DateTime.now();
                          setState(() {
                            _lastTapPosition = details.localPosition;
                            _lastTapTime = now;
                          });
                          
                          // ë°ìŠ¤í¬í†± ì› ëª¨ë“œì¼ ë•Œ ë””ë²„ê¹… ë¡œê·¸ ì¶”ê°€
                          if (!isMobile && !isTablet && circleMode) {
                            print('ë°ìŠ¤í¬í†± ì› ëª¨ë“œ - onTapDownì—ì„œ ìœ„ì¹˜ ì €ì¥: ${details.localPosition}');
                          }
                        }
                      },
                      onTapUp: (details) {
                        print('onTapUp í˜¸ì¶œë¨ - ìœ„ì¹˜: ${details.localPosition}');
                        print('í˜„ì¬ ëª¨ë“œ - isPointDragging: $isPointDragging, circle: $circleMode, scaling: $_isScaling');
                        
                        // ìŠ¤ì¼€ì¼ ì œìŠ¤ì²˜ ì¤‘ì´ê±°ë‚˜ ì  ë“œë˜ê·¸ ì¤‘ì´ë©´ íƒ­ ì´ë²¤íŠ¸ ë¬´ì‹œ
                        if (_isScaling || isPointDragging) {
                          print('ìŠ¤ì¼€ì¼ ì œìŠ¤ì²˜ ì¤‘ ë˜ëŠ” ì  ë“œë˜ê·¸ ì¤‘ - onTapUp ë¬´ì‹œ');
                          return;
                        }
                        
                        // ì €ì¥ëœ ìœ„ì¹˜ ì‚¬ìš© (ë” ì •í™•í•¨)
                        final position = _lastTapPosition ?? details.localPosition;
                        
                        // ëª¨ë°”ì¼/íƒœë¸”ë¦¿ì—ì„œ ì› ëª¨ë“œëŠ” onTapDownì—ì„œë§Œ ì²˜ë¦¬ (ì¤‘ë³µ ë°©ì§€)
                        if ((isMobile || isTablet) && circleMode) {
                          print('ëª¨ë°”ì¼/íƒœë¸”ë¦¿ ì› ëª¨ë“œëŠ” onTapDownì—ì„œ ì²˜ë¦¬ë¨ - onTapUp ë¬´ì‹œ');
                          return;
                        } else if (!circleMode) {
                          // ì¼ë°˜ ëª¨ë“œì—ì„œë§Œ onTapUp ì‚¬ìš©
                          print('ì¼ë°˜ ëª¨ë“œì—ì„œ onTapUp ì²˜ë¦¬');
                          _handleTap(position);
                          _focusNode.requestFocus();
                        } else if (!isMobile && !isTablet && circleMode) {
                          // ë°ìŠ¤í¬í†± ì› ëª¨ë“œì—ì„œëŠ” onTapUpì—ì„œ ì§ì ‘ ì²˜ë¦¬
                          print('ë°ìŠ¤í¬í†± ì› ëª¨ë“œì—ì„œ onTapUp ì§ì ‘ ì²˜ë¦¬');
                          _handleTap(position);
                          _focusNode.requestFocus();
                        } else {
                          print('ê¸°íƒ€ ìƒí™© - onTapUp ë¬´ì‹œ');
                        }
                      },
                      child: MouseRegion(
                        cursor: SystemMouseCursors.basic,
                        onHover: (event) {
                          // ëì  í˜¸ë²„ íš¨ê³¼ ì œê±° - ì„ ë§Œ í˜¸ë²„ í‘œì‹œ
                          final newHoveredLineIndex = _findLineNear(event.localPosition);
                          
                          if (newHoveredLineIndex != hoveredLineIndex) {
                            setState(() {
                              mousePosition = event.localPosition;
                              hoveredLineIndex = newHoveredLineIndex;
                            });
                          }
                        },
                        onExit: (_) {
                          setState(() {
                            mousePosition = null;
                            hoveredLineIndex = null;
                          });
                        },
                        child: CustomPaint(
                          painter: LinesPainter(
                            lines: lines,
                            circles: circles,
                            currentPoint: currentPoint,
                            viewScale: viewScale,
                            viewOffset: viewOffset,
                            viewRotation: viewRotation,
                            selectedLineIndex: selectedLineIndex,
                            selectedCircleIndex: selectedCircleIndex,
                            arrowDirection: arrowDirection,
                            isDoubleDirectionPressed: isDoubleDirectionPressed,
                            isPointDragging: isPointDragging,
                            circleMode: circleMode,
                            pointDragStart: pointDragStart,
                            pointDragEnd: pointDragEnd,
                            circleCenter: circleCenter,
                            pendingOpeningType: pendingOpeningType,
                            hoveredLineIndex: hoveredLineIndex,
                            selectedEndpoint: selectedEndpoint,
                            isGroupDragging: isGroupDragging,
                            draggedGroupLines: draggedGroupLines,
                            snapTargetPoint: snapTargetPoint,
                            selectedGroupLines: selectedGroupLines,
                            diagonalMode: diagonalMode,
                            mousePosition: mousePosition,
                          ),
                          size: Size.infinite,
                        ),
                      ),
                    ),
                  ),
                  // ì¸ë¼ì¸ ì…ë ¥ - Cursor ìŠ¤íƒ€ì¼
                  if (showInlineInput)
                    Positioned(
                      left: _getInlineInputPosition().dx,
                      top: _getInlineInputPosition().dy,
                      child: Container(
                        padding: const EdgeInsets.all(8),
                        decoration: BoxDecoration(
                          color: const Color(0xFF161B22),
                          borderRadius: BorderRadius.circular(8),
                          border: Border.all(
                            color: pendingOpeningType == 'window' 
                              ? const Color(0xFF569CD6) // Cursor íŒŒë€ìƒ‰
                              : circleMode && circleCenter != null
                                ? const Color(0xFFFF7043) // ì› ëª¨ë“œ ì£¼í™©ìƒ‰
                                : selectedCircleIndex >= 0 && arrowDirection != null
                                  ? const Color(0xFF4CAF50) // ì› ì´ë™ ëª¨ë“œ ë…¹ìƒ‰
                                  : selectedLineIndex >= 0
                                    ? const Color(0xFF6A9955) // Cursor ì´ˆë¡ìƒ‰
                                    : const Color(0xFFCE9178), // Cursor ì£¼í™©ìƒ‰
                            width: 2,
                          ),
                          boxShadow: [
                            BoxShadow(
                              color: Colors.black.withOpacity(0.4),
                              blurRadius: 12,
                              offset: const Offset(0, 4),
                            ),
                          ],
                        ),
                        child: Column(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            if (pendingOpeningType != null)
                              Container(
                                padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 2),
                                decoration: BoxDecoration(
                                  color: const Color(0xFF569CD6).withOpacity(0.1),
                                  borderRadius: BorderRadius.circular(4),
                                ),
                                child: Text(
                                  'ì°½ë¬¸',
                                  style: TextStyle(
                                    color: const Color(0xFF569CD6),
                                    fontSize: 11,
                                    fontWeight: FontWeight.w500,
                                  ),
                                ),
                              ),
                            if (circleMode && circleCenter != null)
                              Container(
                                padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 2),
                                decoration: BoxDecoration(
                                  color: const Color(0xFFFF7043).withOpacity(0.1),
                                  borderRadius: BorderRadius.circular(4),
                                ),
                                child: Text(
                                  'ì› ì§€ë¦„',
                                  style: TextStyle(
                                    color: const Color(0xFFFF7043),
                                    fontSize: 11,
                                    fontWeight: FontWeight.w500,
                                  ),
                                ),
                              )
                            else if (selectedCircleIndex >= 0 && arrowDirection != null)
                              Container(
                                padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 2),
                                decoration: BoxDecoration(
                                  color: const Color(0xFF4CAF50).withOpacity(0.1),
                                  borderRadius: BorderRadius.circular(4),
                                ),
                                child: Text(
                                  'ì› ì´ë™',
                                  style: TextStyle(
                                    color: const Color(0xFF4CAF50),
                                    fontSize: 11,
                                    fontWeight: FontWeight.w500,
                                  ),
                                ),
                              )
                            else if (selectedLineIndex >= 0 && arrowDirection == null)
                              Container(
                                padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 2),
                                decoration: BoxDecoration(
                                  color: const Color(0xFF6A9955).withOpacity(0.1),
                                  borderRadius: BorderRadius.circular(4),
                                ),
                                child: Text(
                                  'ê¸¸ì´ ìˆ˜ì •',
                                  style: TextStyle(
                                    color: const Color(0xFF6A9955),
                                    fontSize: 11,
                                    fontWeight: FontWeight.w500,
                                  ),
                                ),
                              ),
                            const SizedBox(height: 4),
                            Container(
                              width: 45, // ë„ˆë¹„ 45px
                              height: 14, // ë†’ì´ 14px
                              decoration: BoxDecoration(
                                color: Colors.black.withOpacity(0.3), // ë°˜íˆ¬ëª… ë°°ê²½
                                borderRadius: BorderRadius.circular(4),
                              ),
                              child: TextField(
                                controller: inlineController,
                                focusNode: inlineFocus,
                                autofocus: true,
                                keyboardType: (isMobile || isTablet)
                                  ? TextInputType.none
                                  : TextInputType.number,
                                readOnly: (isMobile || isTablet),
                                textAlign: TextAlign.center,
                                style: const TextStyle(
                                  color: Color(0xFFE6EDF3),
                                  fontSize: 14, // í°íŠ¸ í¬ê¸° 14px
                                  fontWeight: FontWeight.w500,
                                ),
                                textAlignVertical: TextAlignVertical.center,
                                cursorColor: Colors.transparent, // ì»¤ì„œ ìƒ‰ìƒ íˆ¬ëª…
                                cursorWidth: 0, // ì»¤ì„œ ë„ˆë¹„ 0
                                cursorHeight: 0, // ì»¤ì„œ ë†’ì´ 0
                                showCursor: false, // ì»¤ì„œ í‘œì‹œ ì™„ì „ ë¹„í™œì„±í™”
                                enableInteractiveSelection: false, // í…ìŠ¤íŠ¸ ì„ íƒ ë¹„í™œì„±í™”
                                decoration: const InputDecoration(
                                  border: InputBorder.none,
                                  contentPadding: EdgeInsets.symmetric(horizontal: 4, vertical: 4),
                                  isDense: true,
                                ),
                                inputFormatters: [
                                  FilteringTextInputFormatter.allow(RegExp(r'[0-9+\-.]')),
                                ],
                              ),
                            ),
                          ],
                        ),
                      ),
                    ),
                  

                  
                  // í•˜ë‹¨ ì»¨íŠ¸ë¡¤ íŒ¨ë„ - ë ˆì´ì•„ì›ƒë³„ ë¶„ê¸°
                  if (isMobile)
                    _buildMobileControls()
                  else if (isDesktop)
                    _buildDesktopControls()
                  else
                    _buildTabletControls(),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }



  Widget _buildVoiceButton() {
    IconData icon;
    String label;
    Color color;
    bool isPrimary;
    
    if (_isVoiceProcessing) {
      icon = Icons.hourglass_empty_rounded;
      label = 'ì²˜ë¦¬ ì¤‘';
      color = const Color(0xFFFFB300); // ë…¸ë€ìƒ‰
      isPrimary = true;
    } else if (_isListening) {
      icon = Icons.mic_off_rounded;
      label = 'ìŒì„± ì¤‘ì§€';
      color = const Color(0xFFCE9178); // ì£¼í™©ìƒ‰
      isPrimary = true;
    } else {
      icon = Icons.mic_rounded;
      label = 'ìŒì„± ì¸ì‹';
      color = const Color(0xFF9CDCFE); // ì—°í•œ íŒŒë€ìƒ‰
      isPrimary = false;
    }
    
    return Material(
      color: Colors.transparent,
      child: InkWell(
        onTap: _isVoiceProcessing ? null : () {
          print('ìŒì„± ì¸ì‹ ë²„íŠ¼ í´ë¦­ë¨ - _speechAvailable: $_speechAvailable, _isListening: $_isListening');
          if (_speechAvailable && !_isVoiceProcessing) {
            if (_isListening) {
              // í˜„ì¬ ìŒì„± ì¸ì‹ ì¤‘ì´ë©´ ì¤‘ì§€
              print('ìŒì„± ì¸ì‹ ì¤‘ì§€');
              _stopListening();
            } else {
              // ìŒì„± ì¸ì‹ ì‹œì‘
              print('ìŒì„± ì¸ì‹ ì‹œì‘');
              _startListening();
            }
          } else if (!_speechAvailable) {
            print('ìŒì„± ì¸ì‹ ì‚¬ìš© ë¶ˆê°€ - ì´ˆê¸°í™” ì¬ì‹œë„');
            _initSpeech();
          }
        },
        borderRadius: BorderRadius.circular(6),
        child: Container(
          padding: EdgeInsets.symmetric(
            horizontal: isMobile ? 6 : 8, // ëª¨ë°”ì¼ì—ì„œ íŒ¨ë”© ì¶•ì†Œ
            vertical: 6,
          ),
          decoration: BoxDecoration(
            color: isPrimary ? color : color.withOpacity(0.1),
            borderRadius: BorderRadius.circular(4),
            border: Border.all(
              color: isPrimary ? color : color.withOpacity(0.3),
              width: 1,
            ),
          ),
          child: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              if (_isVoiceProcessing)
                SizedBox(
                  width: 14,
                  height: 14,
                  child: CircularProgressIndicator(
                    strokeWidth: 2,
                    valueColor: AlwaysStoppedAnimation<Color>(
                      isPrimary ? Colors.white : color,
                    ),
                  ),
                )
              else
                Icon(
                  icon,
                  color: isPrimary ? Colors.white : color,
                  size: 14,
                ),
              // ëª¨ë°”ì¼ ëª¨ë“œì—ì„œëŠ” í…ìŠ¤íŠ¸ ìˆ¨ê¹€
              if (!isMobile) ...[
                const SizedBox(width: 4),
                Text(
                  label,
                  style: TextStyle(
                    color: isPrimary ? Colors.white : color,
                    fontSize: 11,
                    fontWeight: FontWeight.w500,
                  ),
                ),
              ],
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildCursorButton({
    required IconData icon,
    required String label,
    required VoidCallback onPressed,
    required Color color,
    bool isPrimary = false,
  }) {
    return Material(
      color: Colors.transparent,
      child: InkWell(
        onTap: onPressed,
        borderRadius: BorderRadius.circular(6),
        child: Container(
          padding: EdgeInsets.symmetric(
            horizontal: isMobile ? 6 : 8, // ëª¨ë°”ì¼ì—ì„œ íŒ¨ë”© ì¶•ì†Œ
            vertical: 6,
          ),
          decoration: BoxDecoration(
            color: isPrimary ? color : color.withOpacity(0.1),
            borderRadius: BorderRadius.circular(4),
            border: Border.all(
              color: isPrimary ? color : color.withOpacity(0.3),
              width: 1,
            ),
          ),
          child: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              Icon(
                icon,
                color: isPrimary ? Colors.white : color,
                size: 14,
              ),
              // ëª¨ë°”ì¼ ëª¨ë“œì—ì„œëŠ” í…ìŠ¤íŠ¸ ìˆ¨ê¹€
              if (!isMobile) ...[
                const SizedBox(width: 4),
                Text(
                  label,
                  style: TextStyle(
                    color: isPrimary ? Colors.white : color,
                    fontSize: 11,
                    fontWeight: FontWeight.w500,
                  ),
                ),
              ],
            ],
          ),
        ),
      ),
    );
  }
  
  Widget _buildCursorButtonWithWidget({
    required Widget iconWidget,
    required String label,
    required VoidCallback onPressed,
    required Color color,
    bool isPrimary = false,
  }) {
    return Material(
      color: Colors.transparent,
      child: InkWell(
        onTap: onPressed,
        borderRadius: BorderRadius.circular(6),
        child: Container(
          padding: EdgeInsets.symmetric(
            horizontal: isMobile ? 6 : 8, // ëª¨ë°”ì¼ì—ì„œ íŒ¨ë”© ì¶•ì†Œ
            vertical: 6,
          ),
          decoration: BoxDecoration(
            color: isPrimary ? color : color.withOpacity(0.1),
            borderRadius: BorderRadius.circular(4),
            border: Border.all(
              color: isPrimary ? color : color.withOpacity(0.3),
              width: 1,
            ),
          ),
          child: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              iconWidget,
              // ëª¨ë°”ì¼ ëª¨ë“œì—ì„œëŠ” í…ìŠ¤íŠ¸ ìˆ¨ê¹€
              if (!isMobile) ...[
                const SizedBox(width: 4),
                Text(
                  label,
                  style: TextStyle(
                    color: isPrimary ? Colors.white : color,
                    fontSize: 11,
                    fontWeight: FontWeight.w500,
                  ),
                ),
              ],
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildIconButton({
    required IconData icon,
    required VoidCallback onPressed,
    required Color color,
    String? tooltip,
  }) {
    return Tooltip(
      message: tooltip ?? '',
      child: Material(
        color: Colors.transparent,
        child: InkWell(
          onTap: onPressed,
          borderRadius: BorderRadius.circular(6),
          child: Container(
            padding: const EdgeInsets.all(6),
            decoration: BoxDecoration(
              color: color.withOpacity(0.1),
              borderRadius: BorderRadius.circular(4),
              border: Border.all(
                color: color.withOpacity(0.3),
                width: 1,
              ),
            ),
            child: Icon(
              icon,
              color: color,
              size: 16,
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildDirectionButton({
    required IconData icon,
    required VoidCallback onPressed,
    bool isTabletSize = false, // íƒœë¸”ë¦¿ ëª¨ë“œìš© í¬ê¸° ì˜µì…˜
  }) {
    Color buttonColor = const Color(0xFF6A9955); // Cursor ì´ˆë¡ìƒ‰
    if (pendingOpeningType == 'window') {
      buttonColor = const Color(0xFF569CD6); // Cursor íŒŒë€ìƒ‰
    }
    
    // ì•„ì´ì½˜ì„ ìœ ë‹ˆì½”ë“œ í™”ì‚´í‘œë¡œ ë³€í™˜
    String arrowText = '';
    if (icon == Icons.keyboard_arrow_up_rounded) {
      arrowText = 'â†‘';
    } else if (icon == Icons.keyboard_arrow_down_rounded) {
      arrowText = 'â†“';
    } else if (icon == Icons.keyboard_arrow_left_rounded) {
      arrowText = 'â†';
    } else if (icon == Icons.keyboard_arrow_right_rounded) {
      arrowText = 'â†’';
    }
    
    // íƒœë¸”ë¦¿ ëª¨ë“œì—ì„œëŠ” 40% í¬ê²Œ
    final double buttonSize = isTabletSize ? 67.2 : 48.0; // 48 * 1.4 = 67.2
    final double fontSize = isTabletSize ? 33.6 : 24.0; // 24 * 1.4 = 33.6
    
    return Material(
      color: Colors.transparent,
      child: InkWell(
        onTap: onPressed,
        borderRadius: BorderRadius.circular(8),
        child: Container(
          width: buttonSize,
          height: buttonSize,
          decoration: BoxDecoration(
            color: buttonColor.withOpacity(0.1),
            borderRadius: BorderRadius.circular(8),
            border: Border.all(
              color: buttonColor.withOpacity(0.3),
              width: 1,
            ),
          ),
          child: Center(
            child: Text(
              arrowText,
              style: TextStyle(
                color: buttonColor,
                fontSize: fontSize,
                fontWeight: FontWeight.bold,
                height: 1.0,
              ),
            ),
          ),
        ),
      ),
    );
  }

  // ëª¨ë°”ì¼ ë ˆì´ì•„ì›ƒ (ë°ìŠ¤í¬í†±ê³¼ ë™ì¼í•œ êµ¬ì¡°, ì—¬ë°± ì¡°ì •)
  Widget _buildMobileControls() {
    return Positioned(
      left: 0,
      right: 0,
      bottom: 0,
      child: Container(
        margin: const EdgeInsets.all(16),
        child: Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            // ì™¼ìª½: ê°„ë‹¨í•œ ë°©í–¥í‚¤ (ë°•ìŠ¤ ì œê±°)
            Container(
              margin: const EdgeInsets.only(left: 15, bottom: 80),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  _buildDirectionButton(
                    icon: Icons.keyboard_arrow_up_rounded,
                    onPressed: () => onDirectionKey('Up'),
                  ),
                  const SizedBox(height: 6),
                  Row(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      _buildDirectionButton(
                        icon: Icons.keyboard_arrow_left_rounded,
                        onPressed: () => onDirectionKey('Left'),
                      ),
                      const SizedBox(width: 6),
                      _buildDirectionButton(
                        icon: Icons.keyboard_arrow_down_rounded,
                        onPressed: () => onDirectionKey('Down'),
                      ),
                      const SizedBox(width: 6),
                      _buildDirectionButton(
                        icon: Icons.keyboard_arrow_right_rounded,
                        onPressed: () => onDirectionKey('Right'),
                      ),
                    ],
                  ),
                ],
              ),
            ),
            
            // ì˜¤ë¥¸ìª½: ë¯¸ë‹ˆ ìˆ«ìíŒ¨ë“œ (ë°•ìŠ¤ ì œê±°)
            Container(
              margin: const EdgeInsets.only(right: 15, bottom: 80),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Row(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      _buildCursorNumberButton('7'),
                      const SizedBox(width: 4),
                      _buildCursorNumberButton('8'),
                      const SizedBox(width: 4),
                      _buildCursorNumberButton('9'),
                    ],
                  ),
                  const SizedBox(height: 4),
                  Row(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      _buildCursorNumberButton('4'),
                      const SizedBox(width: 4),
                      _buildCursorNumberButton('5'),
                      const SizedBox(width: 4),
                      _buildCursorNumberButton('6'),
                    ],
                  ),
                  const SizedBox(height: 4),
                  Row(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      _buildCursorNumberButton('1'),
                      const SizedBox(width: 4),
                      _buildCursorNumberButton('2'),
                      const SizedBox(width: 4),
                      _buildCursorNumberButton('3'),
                    ],
                  ),
                  const SizedBox(height: 4),
                  Row(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      _buildCursorNumberButton('0'),
                      const SizedBox(width: 4),
                      _buildCursorNumberButton('Del', isSpecial: true, color: const Color(0xFFCE9178)),
                      const SizedBox(width: 4),
                      _buildCursorNumberButton('Ent', isSpecial: true, color: const Color(0xFF6A9955)),
                    ],
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  // ë°ìŠ¤í¬í†± ë ˆì´ì•„ì›ƒ (í‚¤ë³´ë“œ ì „ìš© - UI ì»¨íŠ¸ë¡¤ ì—†ìŒ)
  Widget _buildDesktopControls() {
    return const SizedBox.shrink(); // ë¹ˆ ìœ„ì ¯ ë°˜í™˜ - ë°ìŠ¤í¬í†±ì—ì„œëŠ” í‚¤ë³´ë“œë§Œ ì‚¬ìš©
  }

  // íƒœë¸”ë¦¿ ë ˆì´ì•„ì›ƒ (ê¸°ì¡´ ë ˆì´ì•„ì›ƒ)
  Widget _buildTabletControls() {
    return Positioned(
      left: 0,
      right: 0,
      bottom: 0,
      child: Container(
        margin: const EdgeInsets.all(12),
        child: Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            // ì™¼ìª½: ë°©í–¥í‚¤ íŒ¨ë„ (ë°°ê²½ ì œê±°)
            Container(
              margin: const EdgeInsets.only(left: 60, bottom: 70), // ì™¼ìª½ 60px, í•˜ë‹¨ 70px ì¶”ê°€ ì—¬ë°±
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  // ìœ„ìª½ í™”ì‚´í‘œ (íƒœë¸”ë¦¿ ëª¨ë“œì—ì„œ 20% í¬ê²Œ)
                  _buildDirectionButton(
                    icon: Icons.keyboard_arrow_up_rounded,
                    onPressed: () => onDirectionKey('Up'),
                    isTabletSize: true,
                  ),
                  const SizedBox(height: 6), // ìˆ«ì ë²„íŠ¼ê³¼ ë™ì¼í•œ ê°„ê²©
                  // ì¤‘ê°„ ì¤„ (ì™¼ìª½, ì•„ë˜, ì˜¤ë¥¸ìª½)
                  Row(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      _buildDirectionButton(
                        icon: Icons.keyboard_arrow_left_rounded,
                        onPressed: () => onDirectionKey('Left'),
                        isTabletSize: true,
                      ),
                      const SizedBox(width: 6), // ìˆ«ì ë²„íŠ¼ê³¼ ë™ì¼í•œ ê°„ê²©
                      _buildDirectionButton(
                        icon: Icons.keyboard_arrow_down_rounded,
                        onPressed: () => onDirectionKey('Down'),
                        isTabletSize: true,
                      ),
                      const SizedBox(width: 6), // ìˆ«ì ë²„íŠ¼ê³¼ ë™ì¼í•œ ê°„ê²©
                        _buildDirectionButton(
                          icon: Icons.keyboard_arrow_right_rounded,
                          onPressed: () => onDirectionKey('Right'),
                          isTabletSize: true,
                        ),
                    ],
                  ),
                ],
              ),
            ),
            
            // ì˜¤ë¥¸ìª½: ìˆ«ìíŒ¨ë“œ (ë°•ìŠ¤ ì œê±°)
            Container(
              margin: const EdgeInsets.only(right: 30, bottom: 120),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  // ì²« ë²ˆì§¸ ì¤„: 7, 8, 9, - (íƒœë¸”ë¦¿ ëª¨ë“œì—ì„œ 10% í¬ê²Œ)
                  Row(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      _buildCursorNumberButton('7', isTabletSize: true),
                      const SizedBox(width: 6),
                      _buildCursorNumberButton('8', isTabletSize: true),
                      const SizedBox(width: 6),
                      _buildCursorNumberButton('9', isTabletSize: true),
                      const SizedBox(width: 6),
                      _buildCursorNumberButton('-', isSpecial: true, color: const Color(0xFF569CD6), isTabletSize: true),
                    ],
                  ),
                  const SizedBox(height: 6),
                  // ë‘ ë²ˆì§¸ ì¤„: 4, 5, 6, +
                  Row(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      _buildCursorNumberButton('4', isTabletSize: true),
                      const SizedBox(width: 6),
                      _buildCursorNumberButton('5', isTabletSize: true),
                      const SizedBox(width: 6),
                      _buildCursorNumberButton('6', isTabletSize: true),
                      const SizedBox(width: 6),
                      _buildCursorNumberButton('+', isSpecial: true, color: const Color(0xFF569CD6), isTabletSize: true),
                    ],
                  ),
                  const SizedBox(height: 6),
                  // ì„¸ ë²ˆì§¸ì™€ ë„¤ ë²ˆì§¸ ì¤„
                  Row(
                    mainAxisSize: MainAxisSize.min,
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      // ì™¼ìª½ 3x2 ê·¸ë¦¬ë“œ
                      Column(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          // ì„¸ ë²ˆì§¸ ì¤„: 1, 2, 3
                          Row(
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              _buildCursorNumberButton('1', isTabletSize: true),
                              const SizedBox(width: 6),
                              _buildCursorNumberButton('2', isTabletSize: true),
                              const SizedBox(width: 6),
                              _buildCursorNumberButton('3', isTabletSize: true),
                            ],
                          ),
                          const SizedBox(height: 6),
                          // ë„¤ ë²ˆì§¸ ì¤„: 0(2ì¹¸), Del
                          Row(
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              // 0 ë²„íŠ¼ (2ì¹¸ í¬ê¸°)
                              _buildCursorNumberButton('0', isWide: true, isTabletSize: true),
                              const SizedBox(width: 6),
                              _buildCursorNumberButton('Del', isSpecial: true, color: const Color(0xFFCE9178), isTabletSize: true),
                            ],
                          ),
                        ],
                      ),
                      const SizedBox(width: 6),
                      // ì˜¤ë¥¸ìª½ Enter ë²„íŠ¼ (2ì¤„ ë†’ì´)
                      _buildCursorNumberButton('Ent', isTall: true, isSpecial: true, color: const Color(0xFF6A9955), isTabletSize: true),
                    ],
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  // ë“œë¡­ë‹¤ìš´ ì˜¤ë²„ë ˆì´ í‘œì‹œ
  void _showDropdownOverlay() {
    _dropdownOverlay = OverlayEntry(
      builder: (context) => Stack(
        children: [
          // ì „ì²´ í™”ë©´ì„ ë®ëŠ” íˆ¬ëª…í•œ ë ˆì´ì–´ (ë“œë¡­ë‹¤ìš´ ì™¸ë¶€ í´ë¦­ ê°ì§€ìš©)
          Positioned.fill(
            child: GestureDetector(
              onTap: _hideDropdownOverlay,
              behavior: HitTestBehavior.opaque,
              child: Container(color: Colors.transparent),
            ),
          ),
          // ë“œë¡­ë‹¤ìš´ ë©”ë‰´
          CompositedTransformFollower(
            link: _dropdownLayerLink,
            targetAnchor: Alignment.bottomLeft,
            followerAnchor: Alignment.topLeft,
            offset: const Offset(0, 4),
            child: Material(
              color: Colors.transparent,
              child: Container(
                decoration: BoxDecoration(
                  color: const Color(0xFF252526),
                  borderRadius: BorderRadius.circular(8),
                  border: Border.all(
                    color: const Color(0xFF3C3C3C),
                    width: 1,
                  ),
                  boxShadow: [
                    BoxShadow(
                      color: Colors.black.withOpacity(0.3),
                      blurRadius: 8,
                      offset: const Offset(0, 2),
                    ),
                  ],
                ),
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  children: List.generate(10, (index) {
                    final page = index + 1;
                    final isSelected = page == currentPage;
                    
                    return InkWell(
                      onTap: () {
                        print('í˜ì´ì§€ ì„ íƒ: $page');
                        _changePage(page);
                        _hideDropdownOverlay();
                      },
                      borderRadius: page == 1 
                        ? const BorderRadius.only(topLeft: Radius.circular(7), topRight: Radius.circular(7))
                        : page == 10
                          ? const BorderRadius.only(bottomLeft: Radius.circular(7), bottomRight: Radius.circular(7))
                          : null,
                      child: Container(
                        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),
                        decoration: BoxDecoration(
                          color: isSelected 
                            ? const Color(0xFF606060)
                            : Colors.transparent,
                        ),
                        child: Row(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            if (isSelected)
                              const Icon(
                                Icons.check,
                                color: Color(0xFFC0C0C0),
                                size: 16,
                              ),
                            if (isSelected)
                              const SizedBox(width: 6),
                            Text(
                              '$page',
                              style: TextStyle(
                                color: isSelected 
                                  ? Colors.white
                                  : Colors.white.withOpacity(0.8),
                                fontSize: 13,
                                fontWeight: isSelected ? FontWeight.w500 : FontWeight.normal,
                              ),
                            ),
                            const SizedBox(width: 20), // ìµœì†Œ ë„ˆë¹„ í™•ë³´
                          ],
                        ),
                      ),
                    );
                  }),
                ),
              ),
            ),
          ),
        ],
      ),
    );
    
    Overlay.of(context).insert(_dropdownOverlay!);
  }
  
  // ë“œë¡­ë‹¤ìš´ ì˜¤ë²„ë ˆì´ ìˆ¨ê¸°ê¸°
  void _hideDropdownOverlay() {
    _dropdownOverlay?.remove();
    _dropdownOverlay = null;
    setState(() {
      isPageDropdownOpen = false;
    });
  }
  
  // í˜ì´ì§€ ë“œë¡­ë‹¤ìš´ ìœ„ì ¯
  Widget _buildPageDropdown() {
    return CompositedTransformTarget(
      link: _dropdownLayerLink,
      child: Material(
        color: Colors.transparent,
        child: InkWell(
          onTap: () {
            setState(() {
              isPageDropdownOpen = !isPageDropdownOpen;
              if (isPageDropdownOpen) {
                _showDropdownOverlay();
              } else {
                _hideDropdownOverlay();
              }
            });
          },
          borderRadius: BorderRadius.circular(6),
          child: Container(
            padding: EdgeInsets.symmetric(
              horizontal: isMobile ? 4.5 : 8, // ëª¨ë°”ì¼ì—ì„œ 5px ëŠ˜ë¦¼
              vertical: 4, // 26px ë†’ì´ë¥¼ ìœ„í•´ 4ë¡œ ë³€ê²½
            ),
            decoration: BoxDecoration(
              color: isPageDropdownOpen 
                ? const Color(0xFF707070)
                : const Color(0xFF707070).withOpacity(0.1),
              borderRadius: BorderRadius.circular(4),
              border: Border.all(
                color: isPageDropdownOpen 
                  ? const Color(0xFF707070)
                  : const Color(0xFF707070).withOpacity(0.3),
                width: 1,
              ),
            ),
            child: Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                SizedBox(
                  width: isMobile ? 16 : 20, // ëª¨ë°”ì¼ì—ì„œ ë„ˆë¹„ ì¤„ì„
                  child: Text(
                    '$currentPage',
                    textAlign: TextAlign.center,
                    style: TextStyle(
                      color: isPageDropdownOpen 
                        ? Colors.white
                        : const Color(0xFFC0C0C0),
                      fontSize: 12, // 12pxë¡œ ë³€ê²½
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                ),
                SizedBox(width: isMobile ? 2 : 4), // ëª¨ë°”ì¼ì—ì„œ ê°„ê²© ì¤„ì„
                Icon(
                  isPageDropdownOpen ? Icons.arrow_drop_up : Icons.arrow_drop_down,
                  color: isPageDropdownOpen 
                    ? Colors.white
                    : const Color(0xFFC0C0C0),
                  size: isMobile ? 14 : 16, // ëª¨ë°”ì¼ì—ì„œ ì•„ì´ì½˜ í¬ê¸° ì¤„ì„
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
  
  Widget _buildLayoutSwitchButton() {
    IconData getLayoutIcon() {
      switch (layoutMode) {
        case 'mobile': return Icons.smartphone_rounded;
        case 'tablet': return Icons.tablet_rounded;
        case 'desktop': return Icons.desktop_windows_rounded;
        default: return Icons.smartphone_rounded; // ê¸°ë³¸ê°’ì€ ëª¨ë°”ì¼
      }
    }
    
    String getLayoutLabel() {
      switch (layoutMode) {
        case 'mobile': return 'ëª¨ë°”ì¼';
        case 'tablet': return 'íƒœë¸”ë¦¿';
        case 'desktop': return 'ë°ìŠ¤í¬í†±';
        default: return 'ëª¨ë°”ì¼'; // ê¸°ë³¸ê°’ì€ ëª¨ë°”ì¼
      }
    }
    
    return Material(
      color: Colors.transparent,
      child: InkWell(
        onTap: () {
          setState(() {
            // ëª¨ë°”ì¼ â†’ íƒœë¸”ë¦¿ â†’ ë°ìŠ¤í¬í†± â†’ ëª¨ë°”ì¼ ìˆœí™˜
            switch (layoutMode) {
              case 'mobile':
                layoutMode = 'tablet';
                break;
              case 'tablet':
                layoutMode = 'desktop';
                break;
              case 'desktop':
                layoutMode = 'mobile';
                break;
              default:
                layoutMode = 'mobile'; // ê¸°ë³¸ê°’ì€ ëª¨ë°”ì¼
                break;
            }
          });
          
          // ë ˆì´ì•„ì›ƒ ë³€ê²½ í›„ ë·° ë§ì¶¤ ìë™ ì‹¤í–‰
          WidgetsBinding.instance.addPostFrameCallback((_) {
            if (isMobile || isTablet) {
              print('ë ˆì´ì•„ì›ƒ ë³€ê²½ í›„ - ëª¨ë°”ì¼/íƒœë¸”ë¦¿ ëª¨ë“œë¡œ currentPoint ì¤‘ì‹¬ ë§ì¶¤');
              centerCurrentPoint();
            } else {
              fitViewToDrawing();
            }
          });
        },
        borderRadius: BorderRadius.circular(6),
        child: Container(
          padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
          decoration: BoxDecoration(
            color: const Color(0xFF9CDCFE).withOpacity(0.1),
            borderRadius: BorderRadius.circular(6),
            border: Border.all(
              color: const Color(0xFF9CDCFE).withOpacity(0.3),
              width: 1,
            ),
          ),
          child: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              Icon(
                getLayoutIcon(),
                color: const Color(0xFF9CDCFE),
                size: 16,
              ),
              // ëª¨ë°”ì¼ ëª¨ë“œì—ì„œëŠ” í…ìŠ¤íŠ¸ ìˆ¨ê¹€, ë‹¤ë¥¸ ëª¨ë“œì—ì„œëŠ” í™”ë©´ì´ ëª¨ë°”ì¼ì´ ì•„ë‹ ë•Œë§Œ í…ìŠ¤íŠ¸ í‘œì‹œ
              if (layoutMode != 'mobile' && !isMobile) ...[
                const SizedBox(width: 6),
                Text(
                  getLayoutLabel(),
                  style: const TextStyle(
                    color: Color(0xFF9CDCFE),
                    fontSize: 11,
                    fontWeight: FontWeight.w500,
                  ),
                ),
              ],
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildCursorNumberButton(
    String label, {
    bool isSpecial = false,
    bool isWide = false,
    bool isTall = false,
    Color? color,
    bool isTabletSize = false, // íƒœë¸”ë¦¿ ëª¨ë“œìš© í¬ê¸° ì˜µì…˜
  }) {
    Color buttonColor = color ?? const Color(0xFF9CDCFE); // Cursor ì—°í•œ íŒŒë€ìƒ‰
    
    // íƒœë¸”ë¦¿ ëª¨ë“œì—ì„œëŠ” 40% í¬ê²Œ
    final double baseSize = isTabletSize ? 67.2 : 48.0; // 48 * 1.4 = 67.2
    final double wideSize = isTabletSize ? 142.8 : 102.0; // 102 * 1.4 = 142.8
    final double fontSize = isTabletSize ? 22.4 : 16.0; // 16 * 1.4 = 22.4
    
    double width = isWide ? wideSize : baseSize;
    double height = isTall ? wideSize : baseSize; // isTallë„ ê°™ì€ ë¹„ìœ¨ë¡œ ì¦ê°€
    
    return Material(
      color: Colors.transparent,
      child: InkWell(
        onTap: () => onNumberPadKey(label),
        borderRadius: BorderRadius.circular(6),
        child: Container(
          width: width,
          height: height,
          decoration: BoxDecoration(
            color: isSpecial ? buttonColor : buttonColor.withOpacity(0.1),
            borderRadius: BorderRadius.circular(6),
            border: Border.all(
              color: isSpecial ? buttonColor : buttonColor.withOpacity(0.3),
              width: 1,
            ),
          ),
          child: Center(
            child: Text(
              label,
              style: TextStyle(
                fontSize: fontSize,
                fontWeight: FontWeight.w600,
                color: isSpecial ? Colors.white : buttonColor,
              ),
            ),
          ),
        ),
      ),
    );
  }
}

// LinesPainter í´ë˜ìŠ¤ëŠ” ë³„ë„ë¡œ ì •ì˜
class LinesPainter extends CustomPainter {
  final List<Line> lines;
  final List<Circle> circles;
  final Offset currentPoint;
  final double viewScale;
  final Offset viewOffset;
  final double viewRotation;
  final int selectedLineIndex;
  final int selectedCircleIndex;
  final String? arrowDirection;
  final bool isDoubleDirectionPressed;
  final bool isPointDragging;
  final bool circleMode;
  final Offset? pointDragStart;
  final Offset? pointDragEnd;
  final Offset? circleCenter;
  final String? pendingOpeningType;
  final int? hoveredLineIndex;
  final Offset? selectedEndpoint;
  final bool isGroupDragging;
  final Set<int> draggedGroupLines;
  final Offset? snapTargetPoint;
  final Set<int> selectedGroupLines;
  final bool diagonalMode;
  final Offset? mousePosition;

  LinesPainter({
    required this.lines,
    required this.circles,
    required this.currentPoint,
    required this.viewScale,
    required this.viewOffset,
    required this.viewRotation,
    required this.selectedLineIndex,
    required this.selectedCircleIndex,
    this.arrowDirection,
    required this.isDoubleDirectionPressed,
    required this.isPointDragging,
    required this.circleMode,
    this.pointDragStart,
    this.pointDragEnd,
    this.circleCenter,
    this.pendingOpeningType,
    this.hoveredLineIndex,
    this.selectedEndpoint,
    required this.isGroupDragging,
    required this.draggedGroupLines,
    this.snapTargetPoint,
    required this.selectedGroupLines,
    required this.diagonalMode,
    this.mousePosition,
  });

  @override
  void paint(Canvas canvas, Size size) {
    // selectedLineIndex ìœ íš¨ì„± ê²€ì‚¬
    final safeSelectedIndex = (selectedLineIndex >= 0 && selectedLineIndex < lines.length) 
        ? selectedLineIndex 
        : -1;
    
    // hoveredLineIndex ìœ íš¨ì„± ê²€ì‚¬  
    final safeHoveredIndex = (hoveredLineIndex != null && hoveredLineIndex! >= 0 && hoveredLineIndex! < lines.length)
        ? hoveredLineIndex
        : null;
    
    // 1. ë¨¼ì € ëª¨ë“  ì„  ê·¸ë¦¬ê¸° (ì„ ì´ ìˆëŠ” ê²½ìš°ì—ë§Œ)
    for (int i = 0; i < lines.length; i++) {
      try {
        final line = lines[i];
        final start = _modelToScreen(line.start);
        final end = _modelToScreen(line.end);
        
        // ì¤Œ ë ˆë²¨ì— ë”°ë¥¸ ë™ì  ì„  ë‘ê»˜ ê³„ì‚° (ë” ë³´ìˆ˜ì ìœ¼ë¡œ ì¡°ì •)
        // ê·¸ë£¹ì— ì†í•œ ì„ ì´ë‚˜ ê°œë³„ ì„ íƒëœ ì„ ì€ êµµê²Œ í‘œì‹œ
        final isSelected = i == safeSelectedIndex || selectedGroupLines.contains(i);
        final baseStrokeWidth = isSelected ? 3.0 : 2.0;
        final adaptiveStrokeWidth = viewScale < 0.05 
          ? baseStrokeWidth / viewScale * 0.01 // ë§¤ìš° ì‘ì€ ì¤Œì—ì„œ ì„  ë‘ê»˜ ì•½ê°„ ì¦ê°€
          : baseStrokeWidth;
        
        // ì„ íƒëœ ê·¸ë£¹ì— ì†í•œ ì„ ì¸ì§€ í™•ì¸
        final isInSelectedGroup = selectedGroupLines.contains(i);
        
        // ë”ë¸”í´ë¦­í•œ ì„ ì— ëŒ€í•´ì„œë§Œ ë””ë²„ê¹…
        if (selectedGroupLines.isNotEmpty && safeSelectedIndex >= 0 && i == safeSelectedIndex) {
          print('Line $i: isInSelectedGroup=$isInSelectedGroup, safeSelectedIndex=$safeSelectedIndex, selectedGroupLines=$selectedGroupLines');
        }
        
        // ìƒ‰ìƒ ê²°ì • ë¡œì§ ìˆ˜ì •: ê·¸ë£¹ ì„ íƒì´ ìš°ì„ 
        Color lineColor;
        if (isInSelectedGroup) {
          lineColor = const Color(0xFF2196F3); // ì„ íƒëœ ê·¸ë£¹ì€ íŒŒë€ìƒ‰
        } else if (i == safeSelectedIndex) {
          lineColor = const Color(0xFF4CAF50); // ê°œë³„ ì„ íƒì€ ë…¹ìƒ‰
        } else {
          lineColor = Colors.white; // ê¸°ë³¸ì€ í°ìƒ‰
        }
        
        final paint = Paint()
          ..strokeWidth = adaptiveStrokeWidth.clamp(1.0, 4.0) // ìµœì†Œ 1, ìµœëŒ€ 4
          ..color = lineColor;
        
        if (line.openingType == 'window') {
          // í˜¸ë²„ íš¨ê³¼ê°€ ìˆëŠ” ê²½ìš° - ì°½ë¬¸ì—ë§Œ ì ìš©
          if (i == safeHoveredIndex && i != safeSelectedIndex) {
            final hoverStrokeWidth = viewScale < 0.05 
              ? 5.0 / viewScale * 0.01 
              : 5.0;
            final hoverPaint = Paint()
              ..strokeWidth = hoverStrokeWidth.clamp(2.0, 6.0)
              ..color = const Color(0xFF00ACC1).withOpacity(0.5)
              ..strokeCap = StrokeCap.round;
            _drawDashedLine(canvas, start, end, hoverPaint, 5, 5);
          }
          
          // ì°½ë¬¸ - ì ì„  (ì´ë¯¸ ìœ„ì—ì„œ ìƒ‰ìƒì„ ì„¤ì •í–ˆìœ¼ë¯€ë¡œ ê¸°ë³¸ ì°½ë¬¸ìƒ‰ë§Œ ì²˜ë¦¬)
          if (!isInSelectedGroup && i != safeSelectedIndex) {
            paint.color = const Color(0xFF00ACC1); // ê¸°ë³¸ ì°½ë¬¸ìƒ‰ë§Œ ì„¤ì •
          }
          final windowStrokeWidth = viewScale < 0.05 
            ? 3.0 / viewScale * 0.01 
            : 3.0;
          paint.strokeWidth = windowStrokeWidth.clamp(1.0, 4.0);
          _drawDashedLine(canvas, start, end, paint, 5, 5);
          
          // ì´ì¤‘ì„ 
          final angle = math.atan2(line.end.dy - line.start.dy, line.end.dx - line.start.dx);
          final offset = 5 * viewScale;
          final nx = offset * math.sin(angle);
          final ny = -offset * math.cos(angle);
          
          final doubleStrokeWidth = viewScale < 0.05 
            ? 1.0 / viewScale * 0.01 
            : 1.0;
          final doublePaint = Paint()
            ..color = paint.color // ìœ„ì—ì„œ ì„¤ì •í•œ ìƒ‰ìƒ ê·¸ëŒ€ë¡œ ì‚¬ìš©
            ..strokeWidth = doubleStrokeWidth.clamp(0.5, 2.0);
          
          canvas.drawLine(
            Offset(start.dx + nx, start.dy + ny),
            Offset(end.dx + nx, end.dy + ny),
            doublePaint,
          );
          canvas.drawLine(
            Offset(start.dx - nx, start.dy - ny),
            Offset(end.dx - nx, end.dy - ny),
            doublePaint,
          );
        } else {
          // ì¼ë°˜ ì„  í˜¸ë²„ íš¨ê³¼ - ì„ íƒë˜ì§€ ì•Šì€ ê²½ìš°ì—ë§Œ
          if (i == safeHoveredIndex && i != safeSelectedIndex) {
            // ê·¸ë¦¼ì íš¨ê³¼
            final shadowStrokeWidth = viewScale < 0.05 
              ? 4.0 / viewScale * 0.01 
              : 4.0;
            final shadowPaint = Paint()
              ..strokeWidth = shadowStrokeWidth.clamp(2.0, 6.0)
              ..color = Colors.white.withOpacity(0.2)
              ..strokeCap = StrokeCap.round
              ..maskFilter = const MaskFilter.blur(BlurStyle.normal, 4);
            canvas.drawLine(start, end, shadowPaint);
            
            // ë°ì€ ì„ 
            final hoverStrokeWidth = viewScale < 0.05 
              ? 2.5 / viewScale * 0.01 
              : 2.5;
            paint.strokeWidth = hoverStrokeWidth.clamp(1.0, 4.0);
            paint.color = Colors.white;
          }
          // ì´ ë¶€ë¶„ ì‚­ì œ - ì´ë¯¸ ìœ„ì—ì„œ ìƒ‰ìƒê³¼ ë‘ê»˜ë¥¼ ì„¤ì •í–ˆìœ¼ë¯€ë¡œ ì¤‘ë³µë˜ê³  ì˜¤íˆë ¤ ë¬¸ì œë¥¼ ì¼ìœ¼í‚´
          
          canvas.drawLine(start, end, paint);
        }
      } catch (e) {
        // ê°œë³„ ì„  ë Œë”ë§ ì˜¤ë¥˜ ì‹œ ë¡œê·¸ë§Œ ì¶œë ¥í•˜ê³  ê³„ì† ì§„í–‰
        print('LinesPainter: ì„  $i ë Œë”ë§ ì˜¤ë¥˜ - $e');
      }
    }
    
    // 2. ëª¨ë“  ì› ê·¸ë¦¬ê¸°
    for (int i = 0; i < circles.length; i++) {
      try {
        final circle = circles[i];
        final centerScreen = _modelToScreen(circle.center);
        final radiusScreen = circle.radius * viewScale;
        
        // ì„ íƒëœ ì›ì€ ë…¹ìƒ‰, ì¼ë°˜ ì›ì€ í°ìƒ‰
        final isSelected = i == selectedCircleIndex;
        final circleColor = isSelected 
          ? const Color(0xFF4CAF50) // ì„ íƒëœ ì›: ë…¹ìƒ‰ (ì„ ê³¼ ë™ì¼)
          : Colors.white; // ì¼ë°˜ ì›: í°ìƒ‰ (ì„ ê³¼ ë™ì¼)
        
        // ì¤Œ ë ˆë²¨ì— ë”°ë¥¸ ë™ì  ì› ë‘ê»˜ ê³„ì‚° (ë” ë³´ìˆ˜ì ìœ¼ë¡œ ì¡°ì •)
        final baseCircleStrokeWidth = isSelected ? 3.0 : 2.0;
        final adaptiveCircleStrokeWidth = viewScale < 0.05 
          ? baseCircleStrokeWidth / viewScale * 0.01 
          : baseCircleStrokeWidth;
        
        final paint = Paint()
          ..color = circleColor
          ..strokeWidth = adaptiveCircleStrokeWidth.clamp(1.0, 4.0) // ì„ íƒëœ ì›ì€ ë” ë‘ê»ê²Œ
          ..style = PaintingStyle.stroke;
        
        canvas.drawCircle(centerScreen, radiusScreen, paint);
        
        // ì¤‘ì‹¬ì  í‘œì‹œ ë˜ëŠ” í™”ì‚´í‘œ í‘œì‹œ
        if (isSelected && arrowDirection != null) {
          // ì„ íƒëœ ì›ì— ë°©í–¥í‚¤ê°€ ì„¤ì •ëœ ê²½ìš° í™”ì‚´í‘œ í‘œì‹œ
          _drawArrow(canvas, centerScreen, arrowDirection!);
        } else {
          // ì¼ë°˜ ì¤‘ì‹¬ì  í‘œì‹œ
          canvas.drawCircle(
            centerScreen,
            3,
            Paint()
              ..color = circleColor
              ..style = PaintingStyle.fill,
          );
        }
      } catch (e) {
        print('LinesPainter: ì› ë Œë”ë§ ì˜¤ë¥˜ - $e');
      }
    }
    
    // 3. ëª¨ë“  ì¹˜ìˆ˜ í‘œì‹œ (ì„  ìœ„ì— ê·¸ë ¤ì§)
    for (final line in lines) {
      _drawDimension(canvas, line);
    }
    
    // 4. ì›ì˜ ì¹˜ìˆ˜ í‘œì‹œ
    for (final circle in circles) {
      _drawCircleDimension(canvas, circle);
    }
    
    // ì  ë“œë˜ê·¸ ë¯¸ë¦¬ë³´ê¸°
    if (isPointDragging && pointDragStart != null && pointDragEnd != null) {
      final startScreen = _modelToScreen(pointDragStart!);
      final endScreen = _modelToScreen(pointDragEnd!);
      
      // ì  ë“œë˜ê·¸ ë¯¸ë¦¬ë³´ê¸° ì„  ê·¸ë¦¬ê¸° (ì‹¤ì„ ìœ¼ë¡œ)
      final previewPaint = Paint()
        ..color = const Color(0xFF4CAF50).withOpacity(0.8) // ë…¹ìƒ‰ ë°˜íˆ¬ëª…
        ..strokeWidth = 3
        ..strokeCap = StrokeCap.round;
      
      canvas.drawLine(startScreen, endScreen, previewPaint);
      
      // ì‹œì‘ì  í‘œì‹œ (íŒŒë€ìƒ‰)
      canvas.drawCircle(
        startScreen,
        8,
        Paint()
          ..color = const Color(0xFF2196F3).withOpacity(0.3)
          ..style = PaintingStyle.fill,
      );
      
      canvas.drawCircle(
        startScreen,
        5,
        Paint()
          ..color = Colors.white
          ..style = PaintingStyle.fill,
      );
      
      canvas.drawCircle(
        startScreen,
        5,
        Paint()
          ..color = const Color(0xFF2196F3)
          ..style = PaintingStyle.stroke
          ..strokeWidth = 2,
      );
      
      // ëì  í‘œì‹œ (ë…¹ìƒ‰)
      canvas.drawCircle(
        endScreen,
        8,
        Paint()
          ..color = const Color(0xFF4CAF50).withOpacity(0.3)
          ..style = PaintingStyle.fill,
      );
      
      canvas.drawCircle(
        endScreen,
        5,
        Paint()
          ..color = Colors.white
          ..style = PaintingStyle.fill,
      );
      
      canvas.drawCircle(
        endScreen,
        5,
        Paint()
          ..color = const Color(0xFF4CAF50)
          ..style = PaintingStyle.stroke
          ..strokeWidth = 2,
      );
      
      // ê¸¸ì´ í‘œì‹œ
      final distance = (pointDragEnd! - pointDragStart!).distance;
      final midPoint = Offset(
        (startScreen.dx + endScreen.dx) / 2,
        (startScreen.dy + endScreen.dy) / 2,
      );
      
      _drawText(
        canvas,
        '${distance.toStringAsFixed(0)}mm',
        midPoint,
        const Color(0xFF4CAF50),
        fontSize: 12,
        backgroundColor: Colors.black.withOpacity(0.7),
      );
    }
    
    // í˜„ì¬ ì  ê·¸ë¦¬ê¸° (ë“œë˜ê·¸ ì¤‘ì´ê±°ë‚˜ ì› ëª¨ë“œê°€ ì•„ë‹ˆê³ , ì›ì´ ì„ íƒë˜ì§€ ì•Šì•˜ì„ ë•Œë§Œ)
    if (!isPointDragging && !circleMode && selectedCircleIndex < 0) {
      final currentScreen = _modelToScreen(currentPoint);
      
      if (arrowDirection != null) {
        // í™”ì‚´í‘œ ê·¸ë¦¬ê¸°
        _drawArrow(canvas, currentScreen, arrowDirection!);
      } else {
        // ì‹¬í”Œí•œ ì†ì´ ì°¬ ì›
        canvas.drawCircle(
          currentScreen,
          5,
          Paint()
            ..color = const Color(0xFFE53935)
            ..style = PaintingStyle.fill,
        );
      }
    }
    
    // ì› ëª¨ë“œì—ì„œ ì„ íƒëœ ì¤‘ì‹¬ì 
    if (circleMode && circleCenter != null) {
      final centerScreen = _modelToScreen(circleCenter!);
      
      // í„ìŠ¤ íš¨ê³¼ë¥¼ ìœ„í•œ ì™¸ë¶€ ì›
      canvas.drawCircle(
        centerScreen,
        12,
        Paint()
          ..color = const Color(0xFFFF7043).withOpacity(0.2)
          ..style = PaintingStyle.fill,
      );
      
      // ë©”ì¸ ì›
      canvas.drawCircle(
        centerScreen,
        8,
        Paint()
          ..color = Colors.white
          ..style = PaintingStyle.fill,
      );
      
      // í…Œë‘ë¦¬
      canvas.drawCircle(
        centerScreen,
        8,
        Paint()
          ..color = const Color(0xFFFF7043)
          ..style = PaintingStyle.stroke
          ..strokeWidth = 3,
      );
    }
    
    // í˜¸ë²„ëœ ì  í‘œì‹œ ì œê±° - ì„ íƒëœ ëì ë§Œ í‘œì‹œ
    
    // ì ì—°ê²° ëª¨ë“œì¼ ë•Œ ëª¨ë“  ëì ì— ì‘ì€ í‘œì‹œ (ë””ë²„ê¹…ìš©)
    if (diagonalMode && !isPointDragging) {
      final dotColor = const Color(0xFFDCDCAA); // ì ì—°ê²° ë²„íŠ¼ê³¼ ë™ì¼í•œ ìƒ‰ìƒ
      for (final line in lines) {
        // ì‹œì‘ì 
        final startScreen = _modelToScreen(line.start);
        canvas.drawCircle(
          startScreen,
          4,
          Paint()
            ..color = dotColor
            ..style = PaintingStyle.fill,
        );
        
        // ëì 
        final endScreen = _modelToScreen(line.end);
        canvas.drawCircle(
          endScreen,
          4,
          Paint()
            ..color = dotColor
            ..style = PaintingStyle.fill,
        );
      }
      
      // ë§ˆìš°ìŠ¤/í„°ì¹˜ ìœ„ì¹˜ í‘œì‹œ (ë””ë²„ê¹…ìš©)
      if (mousePosition != null) {
        // ì‹­ìì„  í‘œì‹œ
        final crossPaint = Paint()
          ..color = Colors.red.withOpacity(0.5)
          ..strokeWidth = 1;
        canvas.drawLine(
          Offset(mousePosition!.dx - 20, mousePosition!.dy),
          Offset(mousePosition!.dx + 20, mousePosition!.dy),
          crossPaint,
        );
        canvas.drawLine(
          Offset(mousePosition!.dx, mousePosition!.dy - 20),
          Offset(mousePosition!.dx, mousePosition!.dy + 20),
          crossPaint,
        );
        
        // ìœ„ì¹˜ í…ìŠ¤íŠ¸
        final textPainter = TextPainter(
          text: TextSpan(
            text: '(${mousePosition!.dx.toInt()}, ${mousePosition!.dy.toInt()})',
            style: const TextStyle(
              color: Colors.red,
              fontSize: 10,
            ),
          ),
          textDirection: TextDirection.ltr,
        );
        textPainter.layout();
        textPainter.paint(canvas, mousePosition! + const Offset(5, -15));
      }
    }
    
    // ì„ íƒëœ ëì  í‘œì‹œ (ë¹¨ê°„ ì  ë˜ëŠ” íŒŒë€ ì )
    if (selectedEndpoint != null) {
      final selectedScreen = _modelToScreen(selectedEndpoint!);
      
      // ë°©í–¥í‚¤ ë‘ ë²ˆ ëˆŒë €ì„ ë•ŒëŠ” íŒŒë€ìƒ‰, ì•„ë‹ˆë©´ ë¹¨ê°„ìƒ‰
      final pointColor = isDoubleDirectionPressed 
        ? const Color(0xFF2196F3) // íŒŒë€ìƒ‰
        : const Color(0xFFE53935); // ë¹¨ê°„ìƒ‰
      
      canvas.drawCircle(
        selectedScreen,
        5,
        Paint()
          ..color = pointColor
          ..style = PaintingStyle.fill,
      );
    }
    
    // ê·¸ë£¹ ë“œë˜ê·¸ ì¤‘ì¼ ë•Œ ì‹œê°ì  í”¼ë“œë°±
    if (isGroupDragging) {
      // ë“œë˜ê·¸ ì¤‘ì¸ ì„ ë“¤ì„ ë°˜íˆ¬ëª…í•˜ê²Œ í‘œì‹œ
      for (int i in draggedGroupLines) {
        if (i < lines.length) {
          final line = lines[i];
          final startScreen = _modelToScreen(line.start);
          final endScreen = _modelToScreen(line.end);
          
          canvas.drawLine(
            startScreen,
            endScreen,
            Paint()
              ..color = const Color(0xFF2196F3).withOpacity(0.5)
              ..strokeWidth = 3,
          );
        }
      }
      
      // ìŠ¤ëƒ… ëŒ€ìƒì´ ìˆìœ¼ë©´ í‘œì‹œ
      if (snapTargetPoint != null) {
        final snapScreen = _modelToScreen(snapTargetPoint!);
        
        // ìŠ¤ëƒ… ëŒ€ìƒ ì ì„ ê°•ì¡°
        canvas.drawCircle(
          snapScreen,
          12,
          Paint()
            ..color = const Color(0xFF4CAF50).withOpacity(0.3)
            ..style = PaintingStyle.fill,
        );
        
        canvas.drawCircle(
          snapScreen,
          8,
          Paint()
            ..color = const Color(0xFF4CAF50)
            ..style = PaintingStyle.stroke
            ..strokeWidth = 2,
        );
      }
    }
  }

  void _drawArrow(Canvas canvas, Offset position, String direction) {
    // ë¯¸ë‹ˆë©€ ëª¨ë˜ ë””ìì¸
    const double arrowLength = 16.0;
    const double arrowAngle = 0.5; // í™”ì‚´í‘œ ê°ë„ (ë¼ë””ì•ˆ)
    
    // ë°©í–¥í‚¤ ë‘ ë²ˆ ëˆ„ë¦„ ìƒíƒœì— ë”°ë¼ ìƒ‰ìƒ ë³€ê²½
    Color arrowColor;
    if (isDoubleDirectionPressed) {
      arrowColor = const Color(0xFF2196F3); // íŒŒë€ìƒ‰ ê³„ì—´ (Material Blue)
    } else if (pendingOpeningType == 'window') {
      arrowColor = const Color(0xFFFF7043);
    } else {
      arrowColor = const Color(0xFFE53935);
    }
    
    // ì™¸ê³½ ê¸€ë¡œìš° íš¨ê³¼
    final glowPaint = Paint()
      ..color = arrowColor.withOpacity(0.3)
      ..strokeWidth = 8
      ..strokeCap = StrokeCap.round
      ..style = PaintingStyle.stroke;
    
    // ë©”ì¸ í™”ì‚´í‘œ ìŠ¤íŠ¸ë¡œí¬
    final strokePaint = Paint()
      ..color = arrowColor
      ..strokeWidth = 3
      ..strokeCap = StrokeCap.round
      ..strokeJoin = StrokeJoin.round
      ..style = PaintingStyle.stroke;
    
    // í™”ì‚´í‘œ ë ì 
    Offset endPoint;
    Offset leftWing;
    Offset rightWing;
    
    switch (direction) {
      case 'Up':
        endPoint = Offset(position.dx, position.dy - arrowLength);
        leftWing = Offset(
          endPoint.dx - arrowLength * math.sin(arrowAngle),
          endPoint.dy + arrowLength * math.cos(arrowAngle) * 0.48, // 0.6 * 0.8 = 0.48
        );
        rightWing = Offset(
          endPoint.dx + arrowLength * math.sin(arrowAngle),
          endPoint.dy + arrowLength * math.cos(arrowAngle) * 0.48, // 0.6 * 0.8 = 0.48
        );
        break;
        
      case 'Down':
        endPoint = Offset(position.dx, position.dy + arrowLength);
        leftWing = Offset(
          endPoint.dx - arrowLength * math.sin(arrowAngle),
          endPoint.dy - arrowLength * math.cos(arrowAngle) * 0.48, // 0.6 * 0.8 = 0.48
        );
        rightWing = Offset(
          endPoint.dx + arrowLength * math.sin(arrowAngle),
          endPoint.dy - arrowLength * math.cos(arrowAngle) * 0.48, // 0.6 * 0.8 = 0.48
        );
        break;
        
      case 'Left':
        endPoint = Offset(position.dx - arrowLength, position.dy);
        leftWing = Offset(
          endPoint.dx + arrowLength * math.cos(arrowAngle) * 0.48, // 0.6 * 0.8 = 0.48
          endPoint.dy - arrowLength * math.sin(arrowAngle),
        );
        rightWing = Offset(
          endPoint.dx + arrowLength * math.cos(arrowAngle) * 0.48, // 0.6 * 0.8 = 0.48
          endPoint.dy + arrowLength * math.sin(arrowAngle),
        );
        break;
        
      case 'Right':
        endPoint = Offset(position.dx + arrowLength, position.dy);
        leftWing = Offset(
          endPoint.dx - arrowLength * math.cos(arrowAngle) * 0.48, // 0.6 * 0.8 = 0.48
          endPoint.dy - arrowLength * math.sin(arrowAngle),
        );
        rightWing = Offset(
          endPoint.dx - arrowLength * math.cos(arrowAngle) * 0.48, // 0.6 * 0.8 = 0.48
          endPoint.dy + arrowLength * math.sin(arrowAngle),
        );
        break;
        
      default:
        return;
    }
    
    // ê¸€ë¡œìš° íš¨ê³¼ (ì„ íƒì )
    canvas.drawLine(position, endPoint, glowPaint);
    canvas.drawLine(leftWing, endPoint, glowPaint);
    canvas.drawLine(rightWing, endPoint, glowPaint);
    
    // ë©”ì¸ í™”ì‚´í‘œ ê·¸ë¦¬ê¸°
    canvas.drawLine(position, endPoint, strokePaint);
    canvas.drawLine(leftWing, endPoint, strokePaint);
    canvas.drawLine(rightWing, endPoint, strokePaint);
    
    // ì¤‘ì‹¬ì  - ì‘ì€ ì›
    canvas.drawCircle(
      position,
      4,
      Paint()
        ..color = Colors.white
        ..style = PaintingStyle.fill,
    );
    canvas.drawCircle(
      position,
      4,
      Paint()
        ..color = arrowColor
        ..strokeWidth = 2
        ..style = PaintingStyle.stroke,
    );
  }

  void _drawDimension(Canvas canvas, Line line) {
    final start = _modelToScreen(line.start);
    final end = _modelToScreen(line.end);
    
    final dx = line.end.dx - line.start.dx;
    final dy = line.end.dy - line.start.dy;
    final length = math.sqrt(dx * dx + dy * dy).round();
    
    if (length == 0) return;
    
    final midX = (start.dx + end.dx) / 2;
    final midY = (start.dy + end.dy) / 2;
    
    // í…ìŠ¤íŠ¸ ìœ„ì¹˜ ê³„ì‚° - 12í”½ì…€ ê³ ì • ê±°ë¦¬
    final angle = math.atan2(dy, dx);
    final offset = 12.0;
    double nx, ny;
    
    // íšŒì „ì´ ì—†ì„ ë•ŒëŠ” ê¸°ë³¸ ë°©ì‹
    if (viewRotation.abs() < 0.01) {
      nx = -math.sin(angle) * offset;
      ny = math.cos(angle) * offset;
    } else {
      // íšŒì „ì´ ìˆì„ ë•ŒëŠ” í™”ë©´ì—ì„œ ë³´ì´ëŠ” ì„ ì˜ ë°©í–¥ì„ ê¸°ì¤€ìœ¼ë¡œ ê³„ì‚°
      // í™”ë©´ ì¢Œí‘œê³„ì—ì„œì˜ ì„ ì˜ ë°©í–¥
      final screenStartX = start.dx * math.cos(viewRotation) - start.dy * math.sin(viewRotation);
      final screenStartY = start.dx * math.sin(viewRotation) + start.dy * math.cos(viewRotation);
      final screenEndX = end.dx * math.cos(viewRotation) - end.dy * math.sin(viewRotation);
      final screenEndY = end.dx * math.sin(viewRotation) + end.dy * math.cos(viewRotation);
      
      // í™”ë©´ì—ì„œì˜ ì„ ì˜ ê°ë„
      final screenAngle = math.atan2(screenEndY - screenStartY, screenEndX - screenStartX);
      
      // í™”ë©´ ê¸°ì¤€ìœ¼ë¡œ ìˆ˜ì§ ë°©í–¥ ì˜¤í”„ì…‹ (12í”½ì…€ ê³ ì •)
      final screenNx = -math.sin(screenAngle) * offset;
      final screenNy = math.cos(screenAngle) * offset;
      
      // ëª¨ë¸ ì¢Œí‘œê³„ë¡œ ì—­ë³€í™˜
      final cos = math.cos(-viewRotation);
      final sin = math.sin(-viewRotation);
      nx = screenNx * cos - screenNy * sin;
      ny = screenNx * sin + screenNy * cos;
    }
    
    canvas.save();
    canvas.translate(midX + nx, midY + ny);
    
    // í…ìŠ¤íŠ¸ íšŒì „ - í™”ë©´ íšŒì „ì„ ê³ ë ¤
    double textAngle = -angle - viewRotation;
    // í…ìŠ¤íŠ¸ê°€ í•­ìƒ ì½ê¸° ì‰¬ìš´ ë°©í–¥ì´ ë˜ë„ë¡ ì¡°ì •
    while (textAngle > math.pi / 2) {
      textAngle -= math.pi;
    }
    while (textAngle < -math.pi / 2) {
      textAngle += math.pi;
    }
    canvas.rotate(textAngle);
    
    // í…ìŠ¤íŠ¸ ì™¸ê³½ì„  (stroke) ê·¸ë¦¬ê¸°
    final outlinePainter = TextPainter(
      text: TextSpan(
        text: length.toString(),
        style: TextStyle(
          fontSize: 16.0,
          fontWeight: FontWeight.w600,
          foreground: Paint()
            ..style = PaintingStyle.stroke
            ..strokeWidth = 4
            ..color = const Color(0xFF212830),
        ),
      ),
      textDirection: TextDirection.ltr,
    );
    outlinePainter.layout();
    outlinePainter.paint(
      canvas,
      Offset(-outlinePainter.width / 2, -outlinePainter.height / 2),
    );
    
    // í…ìŠ¤íŠ¸ ì±„ìš°ê¸° (fill) ê·¸ë¦¬ê¸°
    final fillPainter = TextPainter(
      text: TextSpan(
        text: length.toString(),
        style: const TextStyle(
          color: Color(0xFFFFB300),
          fontSize: 16.0,
          fontWeight: FontWeight.w600,
        ),
      ),
      textDirection: TextDirection.ltr,
    );
    fillPainter.layout();
    fillPainter.paint(
      canvas,
      Offset(-fillPainter.width / 2, -fillPainter.height / 2),
    );
    
    canvas.restore();
  }

  void _drawCircleDimension(Canvas canvas, Circle circle) {
    final centerScreen = _modelToScreen(circle.center);
    final diameter = (circle.radius * 2).round();
    
    if (diameter == 0) return;
    
    // ì§€ë¦„ í‘œì‹œ ìœ„ì¹˜ - ì›ì˜ ìš°ì¸¡ ìƒë‹¨
    final textX = centerScreen.dx + (circle.radius * viewScale * 0.7);
    final textY = centerScreen.dy - (circle.radius * viewScale * 0.7);
    
    canvas.save();
    canvas.translate(textX, textY);
    
    // í™”ë©´ íšŒì „ì„ ê³ ë ¤í•œ í…ìŠ¤íŠ¸ íšŒì „
    canvas.rotate(-viewRotation);
    
    // ì§€ë¦„ í‘œì‹œ í…ìŠ¤íŠ¸ (Ã˜ ê¸°í˜¸ì™€ í•¨ê»˜)
    final dimensionText = 'Ã˜$diameter';
    
    // í…ìŠ¤íŠ¸ ì™¸ê³½ì„  (stroke) ê·¸ë¦¬ê¸°
    final outlinePainter = TextPainter(
      text: TextSpan(
        text: dimensionText,
        style: TextStyle(
          fontSize: 14.0,
          fontWeight: FontWeight.w600,
          foreground: Paint()
            ..style = PaintingStyle.stroke
            ..strokeWidth = 3
            ..color = const Color(0xFF212830),
        ),
      ),
      textDirection: TextDirection.ltr,
    );
    outlinePainter.layout();
    outlinePainter.paint(
      canvas,
      Offset(-outlinePainter.width / 2, -outlinePainter.height / 2),
    );
    
    // í…ìŠ¤íŠ¸ ì±„ìš°ê¸° (fill) ê·¸ë¦¬ê¸°
    final fillPainter = TextPainter(
      text: TextSpan(
        text: dimensionText,
        style: const TextStyle(
          color: Color(0xFFFFB300),
          fontSize: 14.0,
          fontWeight: FontWeight.w600,
        ),
      ),
      textDirection: TextDirection.ltr,
    );
    fillPainter.layout();
    fillPainter.paint(
      canvas,
      Offset(-fillPainter.width / 2, -fillPainter.height / 2),
    );
    
    canvas.restore();
  }

  void _drawDashedLine(Canvas canvas, Offset start, Offset end, Paint paint, double dashWidth, double dashSpace) {
    final distance = (end - start).distance;
    final dx = (end.dx - start.dx) / distance;
    final dy = (end.dy - start.dy) / distance;
    
    double currentDistance = 0;
    while (currentDistance < distance) {
      final dashEnd = currentDistance + dashWidth;
      if (dashEnd > distance) {
        canvas.drawLine(
          Offset(start.dx + dx * currentDistance, start.dy + dy * currentDistance),
          end,
          paint,
        );
      } else {
        canvas.drawLine(
          Offset(start.dx + dx * currentDistance, start.dy + dy * currentDistance),
          Offset(start.dx + dx * dashEnd, start.dy + dy * dashEnd),
          paint,
        );
      }
      currentDistance += dashWidth + dashSpace;
    }
  }

  void _drawText(
    Canvas canvas,
    String text,
    Offset position,
    Color color, {
    double fontSize = 14.0,
    Color? backgroundColor,
    FontWeight fontWeight = FontWeight.w600,
  }) {
    final textPainter = TextPainter(
      text: TextSpan(
        text: text,
        style: TextStyle(
          color: color,
          fontSize: fontSize,
          fontWeight: fontWeight,
        ),
      ),
      textDirection: TextDirection.ltr,
    );
    
    textPainter.layout();
    
    final textOffset = Offset(
      position.dx - textPainter.width / 2,
      position.dy - textPainter.height / 2,
    );
    
    // ë°°ê²½ìƒ‰ì´ ìˆìœ¼ë©´ ë°°ê²½ ê·¸ë¦¬ê¸°
    if (backgroundColor != null) {
      final backgroundRect = Rect.fromLTWH(
        textOffset.dx - 4,
        textOffset.dy - 2,
        textPainter.width + 8,
        textPainter.height + 4,
      );
      
      canvas.drawRRect(
        RRect.fromRectAndRadius(backgroundRect, const Radius.circular(4)),
        Paint()..color = backgroundColor,
      );
    }
    
    textPainter.paint(canvas, textOffset);
  }

  Offset _modelToScreen(Offset model) {
    // íšŒì „ ë³€í™˜ ì ìš©
    final cos = math.cos(viewRotation);
    final sin = math.sin(viewRotation);
    
    // íšŒì „ëœ ì¢Œí‘œ
    final rotatedX = model.dx * cos - model.dy * sin;
    final rotatedY = model.dx * sin + model.dy * cos;
    
    return Offset(
      viewOffset.dx + rotatedX * viewScale,
      viewOffset.dy - rotatedY * viewScale,
    );
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => true;
}